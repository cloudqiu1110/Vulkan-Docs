// Copyright (c) 2015-2017 The Khronos Group Inc.
// Copyright notice at https://www.khronos.org/registry/speccopyright.html

[[synchronization]]
= 同步与缓存控制

对资源的访问同步是Vulkan应用程序的主要职责。主机端的命令和设备端的其他命令的执行顺序只有少数几个隐式的保证，需要显式的指定。
内存缓存和其他优化也需要显式的管理，要求数据流在应用程序的控制之下。

尽管在不同的命令之间有一些隐式的保证，在Vulkan中提供了四种显示的同步原语：

<<synchronization-fences,栅栏>>::
	栅栏可以用来和主机端交流设备端的任务已经执行完成。

<<synchronization-semaphores,信号量>>::
	信号量可以用来控制多个队列对资源的访问。

<<synchronization-events,事件>>::
	事件提供了精细粒度的同步原语，可以在命令缓冲区之内或者被主机端激发，可以在命令缓冲区内等待或者主机端被查询。

<<synchronization-pipeline-barriers,管线屏障>>::
	管线屏障也在命令缓冲区内提供了同步控制，但是只是单点的，而非可分离激发和等待操作。

除了这里的基本的原语， 在本章的概念上，<<renderpass, Render Passes>> 为大多数渲染任务提供了同步框架。
本章中很多需要应用程序来同步原语的情况，可以被render pass更加高效的表达出来。


[[synchronization-dependencies]]
== 执行与内存依赖

一个 _操作_ 是主机端、设备端或者外部入口如展示引擎等之上任意数量的工作。
同步命令引入了显式的 _执行依赖_，_内存依赖_，有命令的两个_synchronization scopes_ 定义的两个操作集合之间的 _memory dependencies_ 。


[[synchronization-dependencies-scopes]]
同步范围定义了哪些其他的同步命令可以创建执行依赖。
不再同步命令的同步范围内的任何类型的操作将不被包含进入生成的依赖之中。
例如，对于很多同步命令来说，同步范围可以被限制到只执行特定<<synchronization-pipeline-stages,管线阶段>>的操作上，这允许其他的管线阶段被排除在依赖之外。
其他的范围选项也是可行的，依赖于特定的命令。

[[synchronization-dependencies-execution]]
_执行依赖_ 保证了两个集合的操作其中的一个一定在另外一个之前发生。
如果一个操作在另外一个操作之前发生了，那么第一个操作一定会在第二个操作初始化之前完成。
更准确的表述是：

  * 假定 *A* and *B* 是相互独立的操作集合
  * 假定 *S* 是同步命令
  * 假定 *A~S~* 和 *B~S~* 是 *S* 的同步范围.
  * 假定 *A'* 是集合 *A* 与 *A~S~* 的交集
  * 假定 *B'* 是集合 *B* 与 *B~S~*的交集
  * 提交 *A*, *S* and *B* 来按照顺序执行，将导致在 *A'* 和 *B'* 产程一个执行依赖    
  * 执行依赖 *E* 保证 *A'* 在*B'* 之前发生

[[synchronization-dependencies-chains]]
一个 _执行依赖链_ 是一系列的执行依赖，形成了第一个依赖的 *A'*  与最后一个依赖的 *B'* 之间的 “先行发生”的关系。
对于每一对连续的执行依赖，如果 第一个依赖中*B~S~* 与第二个依赖中*A~S~*的交集不是空集，那么就存在一个依赖链。
一个执行依赖链之中单个执行依赖的形成可以通过代入如下执行依赖的描述所描述：

  * 假设 *S* 是一个同步命令集合，由一个执行依赖链所生成。
  * 假设 *A~S~* 是 *S*之中第一个命令的第一个同步作用域。
  * 假设 *B~S~* 是 *S*中最后一个命令的第二个同步作用域。
    

.注意
[NOTE]
====
一个执行依赖is inherently also 多重执行依赖-
一个 依赖在  *A'*的每个子集与   *B'* 的每个子集之间 存在，且对执行依赖链同样成立。
例如，一个 带有多重<<synchronization-pipeline-stages,管线阶段>>阶段掩码 的 同步命令 高效的在每个源阶段与每个目标阶段 之间生成一个依赖。
这对于 理解执行链在其没有涉及到同步命令的依赖时如何构建的 很有用。
同样，在一个执行依赖链中相邻的依赖都可以被认为是一个执行依赖链 。
====

单单就执行顺序无法保证其他操作集写入的结果可以被另一个操作集读取。
 

[[synchronization-dependencies-available-and-visible]]
附加操作的两个类型是用来控制内存访问的。
_可见性操作_ 导致 特定的内存写入对于未来的访问变得 _可用_ 。
Any available value remains available until a subsequent write to the same
memory location occurs (whether it is made available or not) or the memory
is freed.
_可见性操作_ 导致任何可用的值对于特定的内存访问变得  _可见_ 。

[[synchronization-dependencies-memory]]
 一个_内存依赖_ 是一个执行依赖，它包含可用性、可见性操作：

  * 第一个操作集合在可用性操作之前发生。
  * 可用性操作在可见性操作之前发生。
  * 可见性操作在第二个操作集合之前发生。

一旦被写入的值对于一个特定类型内存访问可见，那么它们可以被该类型内存访问读取或者写入。
Vulkan中多数同步命令定义了一个内存依赖。

[[synchronization-dependencies-access-scopes]]
内存依赖的 _访问作用域_ 定义了 特定的内存访问的可用性与可见性。
 在一个内存依赖的第一个 访问作用域 与出现在  *A'*的 任何类型的访问是可用的。
 在一个内存依赖第二个访问作用域 与出现在 *B'*的任何类型的访问让可用的写入对其变得可见。
不在同步命令的访问作用域的任何类型操作 将不被产生的依赖所包含。

一个内存依赖强制保证了 两个操作集合之间 内存访问与 执行顺序的可用性、可见性。 
参考 <<synchronization-dependencies-chains, 执行依赖链>>一节的描述:

  * 假定 *a* 是由 *A'*执行的 内存访问的集合。
  * 假定 *b*  是由 *B*执行的 内存访问的集合。 
  * 假定 *a~S~* 是 在 *S*中第一个命令的第一个访问作用域。
  * 假定 *b~S~* 是 在 *S*中最后一个命令的第二个访问作用域。
  * 假定 *a'* 是*a* and *a~S~*的子集。
  * 假定 *b'* 是*b* and *b~S~*的子集。
  * 提交 *A*, *S* and *B* 来执行，依此序，将会在*A'* and *B'*之间 产生一个内存依赖*m*。
  * 内存依赖*m* guarantees that:
  ** 在*a'*中的内存写入 变得可用。
  ** 可用内存写入，包括那些在 a'*中的，变得对*b'*可见。

[NOTE]
.注意
====
执行与内存依赖是用来解决数据危害的，亦即，保证读写操作依良好定义的顺序执行。
“读后写”的数据错误可以被执行依赖解决，但是“写后读”与“写后写”数据错误需要内存操作之间有合适的内存依赖。
若应用程序并不包含依赖以解决这些数据危害问题，那么内存访问的执行顺序与结果是未定义的。
====


[[synchronization-image-layout-transitions]]
=== 图像布局转换
图形子资源可以从一个 <<resources-image-layouts,布局>> 到另外一个，作为 <<synchronization-dependencies-memory,内存依赖>>的一部分。 (e.g. by using an
<<synchronization-image-memory-barriers,图像内存屏障>>).
当内存依赖指定了一个布局转换，在内存依赖中它发生在availability操作之后，发生在visibility操作之前。
图像布局转换操作可以对绑定到图像子资源范围的所有内存执行读、写，故应用程序必须保证所有的内存写入结果需要在布局转换被执行之前
<<synchronization-dependencies-available-and-visible, 变为可用>>。
可用的内存对布局转换自动可见，且布局转换写入的内存也是自动变为可用。

布局转换总是应用到图像子资源的特定范围，且指定老的布局和新的布局。
若老的布局与新布局并不匹配，转换可以发生。老布局必须与图像子资源范围的当前布局匹配，除了一个例外。
老布局可以被指定为 ename:VK_IMAGE_LAYOUT_UNDEFINED，即便做如此操作会导致图像子资源范围的内容变得无效。


.注意
[NOTE]
====
设定老的布局为 ename:VK_IMAGE_LAYOUT_UNDEFINED 暗示着图像子资源的内容不需要被保留。
Vulkan驱动实现可能使用这信息以避免昂贵的数据转换操作。
====

.注意
[NOTE]
====
应用程序必须保证 布局转换 在 所有的访问老布局的图像的操作 之后 发生， 且在所有访问新布局的图像的操作之前 发生。 
布局转换是潜在的读写操作，所以不定义一个合适的 内存依赖来保证顺序将会导致数据竞争。
====

在一次图像布局转换之后，共享绑定到转换之后的图像子资源范围的内存的 其他的资源，它们的任何部分内存内容都都可能是未定义的。


[[synchronization-pipeline-stages]]
=== 管线阶段

<<fundamentals-queueoperation-command-types, action command>> 执行的计算由多个操作组成。这些操作由一些被称作“管线阶段”的逻辑独立执行单元执行。
被执行的管线阶段依赖于被使用的 action command，和action  command被记录所在的当前的命令缓冲区阶段。
<<drawing,Drawing commands>>, <<dispatch,dispatching commands>>,
<<copies,copy commands>>, 和 <<clears,clear commands>> 都在不同的  <<synchronization-pipeline-stages-types,管线阶段>>集合中被执行。

跨管线阶段的操作的执行必须参照于<<synchronization-implicit, implicit ordering guarantees>>，特别是包含 <<synchronization-pipeline-stages-order, 管线阶段排序>>。
否则，跨管线阶段执行可能会互相重叠，或者乱序，除非通过执行依赖来强制保证。

// refBegin VkPipelineStageFlagBits - Bitmask specifying 管线阶段

一些同步命令包含管线阶段参数，对命令的那些阶段限制了 <<synchronization-dependencies-scopes, 同步作用域>> 。
这允许了 在准确执行依赖与 action命令执行的访问之间 更加精确的控制。
Vulkan实现应该使用这些 管线阶段来避免不必要的暂停与cache刷新。

可以使用如下位掩码来指定管线阶段：

include::../api/enums/VkPipelineStageFlagBits.txt[]

每一个bit的含义如下：

  * ename:VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT: 任何命令被队列初次接受的管线阶段。
ifdef::VK_NVX_device_generated_commands[]
  * ename:VK_PIPELINE_STAGE_COMMAND_PROCESS_BIT_NVX: Stage of the pipeline
    where device-side generation of commands via
    flink:vkCmdProcessCommandsNVX is handled.
endif::VK_NVX_device_generated_commands[]
  * ename:VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT: Stage of the 管线where
    Draw/DispatchIndirect data structures are consumed.
ifdef::VK_NVX_device_generated_commands[]
    This stage also includes reading commands written by
    flink:vkCmdProcessCommandsNVX.
endif::VK_NVX_device_generated_commands[]
  * ename:VK_PIPELINE_STAGE_VERTEX_INPUT_BIT: Stage of the 管线where
    vertex and 索引 buffers are consumed.
  * ename:VK_PIPELINE_STAGE_VERTEX_SHADER_BIT: Vertex shader stage.
  * ename:VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT: Tessellation
    control shader stage.
  * ename:VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT: Tessellation
    evaluation shader stage.
  * ename:VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT: Geometry shader stage.
  * ename:VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT: Fragment shader stage.
  * ename:VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT: Stage of the pipeline
    where early fragment tests (depth and stencil tests before fragment
    shading) are performed.
    This stage also includes <<renderpass-load-store-ops, subpass load
    operations>> for framebuffer attachments with a depth/stencil format.
  * ename:VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT: Stage of the pipeline
    where late fragment tests (depth and stencil tests after fragment
    shading) are performed.
    This stage also includes <<renderpass-load-store-ops, subpass store
    operations>> for framebuffer attachments with a depth/stencil format.
  * ename:VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT: Stage of the
    管线after blending where the final color values are output from the
    pipeline.
    This stage also includes <<renderpass-load-store-ops, subpass load and
    store operations>> and multisample resolve operations for framebuffer
    attachments with a color format.
  * [[synchronization-pipeline-stages-transfer]]
    ename:VK_PIPELINE_STAGE_TRANSFER_BIT: Execution of copy commands.
    This includes the operations resulting from all <<copies,copy
    commands>>, <<clears,clear commands>> (with the exception of
    flink:vkCmdClearAttachments), and flink:vkCmdCopyQueryPoolResults.
  * ename:VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT: Execution of a compute
    shader.
  * ename:VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT: Final stage in the pipeline
    where operations generated by all commands complete execution.
  * ename:VK_PIPELINE_STAGE_HOST_BIT: A pseudo-stage indicating 执行on
    the host of reads/writes of 设备memory.
    This stage is not invoked by any commands recorded in a 命令buffer.
  * ename:VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT: Execution of all graphics
    管线阶段.
    Equivalent to the logical or of:

  ** ename:VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT
  ** ename:VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT
  ** ename:VK_PIPELINE_STAGE_VERTEX_INPUT_BIT
  ** ename:VK_PIPELINE_STAGE_VERTEX_SHADER_BIT
  ** ename:VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT
  ** ename:VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT
  ** ename:VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT
  ** ename:VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT
  ** ename:VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT
  ** ename:VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT
  ** ename:VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT
  ** ename:VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT

  * ename:VK_PIPELINE_STAGE_ALL_COMMANDS_BIT: Equivalent to the logical or
    of every other 管线stage flag that is supported on the 队列it is
    used with.

[NOTE]
.注意
====
在源阶段掩码中只有 ename:VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT的一个执行依赖，将只阻止该阶段在被提交的命令中顺序执行。
如同这个阶段并不执行任何真实的操作，外界无法观测到。实际上，它并不延迟处理下一个命令。
同样，在目标阶段掩码中只有ename:VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT的一个执行依赖 ，不会有效等待之前的任何命令去完成。

当定义了一个内存依赖, 只使用ename:VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT 或者
ename:VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT时， 将不会让任何访问变得可用、可见，因为这些阶段不会访问内存。

当所需的执行依赖被其他方式所满足时 - 例如, 在不同队列之间的信号量操作，完成布局转换和 队列所有权转移操作中，ename:VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT 与
ename:VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT 将很有用。
====

// refEnd VkPipelineStageFlagBits

[[synchronization-pipeline-stages-masks]]
若一个同步命令包含一个目标阶段掩码，它的第一个<<synchronization-dependencies-scopes, 同步作用域>> 将只包含 由该掩码指定的管线阶段的执行， 
同样包含<<synchronization-pipeline-stages-order, 逻辑上更早的 >> 阶段。
若一个同步命令包含一个源阶段掩码，它的第二个<<synchronization-dependencies-scopes, 同步作用域>> 将只包含 由该掩码指定的管线阶段的执行，同样包含<<synchronization-pipeline-stages-order, 逻辑上稍后>> 阶段。

<<synchronization-dependencies-access-scopes, 访问作用域>> 受同样的方式所影响。 
若一个同步命令包含一个目标阶段掩码，她的第一个<<synchronization-dependencies-access-scopes, 访问作用域>> 只包含 由该掩码指定的管线阶段 所执行的 内存访问。
若一个同步命令包含一个源阶段掩码，它的第二个<<synchronization-dependencies-access-scopes, 访问作用域>> 只包含 由该掩码指定的管线阶段 所执行的内存访问。

[NOTE]
.注意
====
Vulkan实现可能并不支持为了每个同步操作在每个管线阶段进行同步。
若Vulkan实现并不支持同步的一个管线阶段出现在 目标阶段掩码，那么它可以为了逻辑上的后续阶段替换该阶段。
若Vulkan实现并不支持同步的一个管线阶段出现在源阶段掩码，那么它可以为了逻辑上的之前的阶段替换该阶段。

例如，若一个Vulkan实现无法在顶点着色器执行完成后激发事件，它可以在颜色附件输出完成之后再激发事件。
若Vulkan实现做出了此种替换，它必须不能影响执行或者内存依赖、图像或缓冲区内存屏障的语义。
====

某些管线阶段只在支持特定操作集合的队列中可以使用。
下表陈列了，每个管线阶段标志位，以及队列必须支持的队列兼容性标志。
当表格的第二列出现了多个标志位，这表示管线阶段被带有其中任意一个标志位的队列所支持，
向获知有关队列兼容性的更多详细信息，请参考
<<devsandqueues-physical-device-enumeration, 物理设备枚举 >>
和 <<devsandqueues-queues, 队列>>.

[[synchronization-pipeline-stages-supported]]
.Supported 管线stage flags
[cols="60%,40%",options="header"]
|====
|Pipeline 阶段 flag                                          | Required队列capability flag
|ename:VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT                      | None required
|ename:VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT                    | ename:VK_QUEUE_GRAPHICS_BIT or ename:VK_QUEUE_COMPUTE_BIT
|ename:VK_PIPELINE_STAGE_VERTEX_INPUT_BIT                     | ename:VK_QUEUE_GRAPHICS_BIT
|ename:VK_PIPELINE_STAGE_VERTEX_SHADER_BIT                    | ename:VK_QUEUE_GRAPHICS_BIT
|ename:VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT      | ename:VK_QUEUE_GRAPHICS_BIT
|ename:VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT   | ename:VK_QUEUE_GRAPHICS_BIT
|ename:VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT                  | ename:VK_QUEUE_GRAPHICS_BIT
|ename:VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT                  | ename:VK_QUEUE_GRAPHICS_BIT
|ename:VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT             | ename:VK_QUEUE_GRAPHICS_BIT
|ename:VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT              | ename:VK_QUEUE_GRAPHICS_BIT
|ename:VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT          | ename:VK_QUEUE_GRAPHICS_BIT
|ename:VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT                   | ename:VK_QUEUE_COMPUTE_BIT
|ename:VK_PIPELINE_STAGE_TRANSFER_BIT                         | ename:VK_QUEUE_GRAPHICS_BIT, ename:VK_QUEUE_COMPUTE_BIT or ename:VK_QUEUE_TRANSFER_BIT
|ename:VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT                   | None required
|ename:VK_PIPELINE_STAGE_HOST_BIT                             | None required
|ename:VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT                     | ename:VK_QUEUE_GRAPHICS_BIT
|ename:VK_PIPELINE_STAGE_ALL_COMMANDS_BIT                     | None required
ifdef::VK_NVX_device_generated_commands[]
|ename:VK_PIPELINE_STAGE_COMMAND_PROCESS_BIT_NVX              | ename:VK_QUEUE_GRAPHICS_BIT or ename:VK_QUEUE_COMPUTE_BIT
endif::VK_NVX_device_generated_commands[]
|====

[[synchronization-pipeline-stages-order]]
管线阶段 that execute as a result of a 命令logically complete
执行in a specific order, such that completion of a 逻辑上稍后
管线阶段 must: not happen-before completion of a logically earlier
阶段.
This means that including any given 阶段 in the 目标阶段掩码 for a
particular synchronization 命令also implies that any logically earlier
阶段s are included in *A~S~* for that command.

Similarly, initiation of a logically earlier 管线阶段 must: not
happen-after initiation of a 逻辑上稍后 管线阶段.
Including any given 阶段 in the 源阶段掩码 for a particular
synchronization 命令also implies that any 逻辑上稍后 阶段s are
included in *B~S~* for that command.

.注意
[NOTE]
====
当定义 
一个<<synchronization-memory-barriers, 内存屏障>> 的<<synchronization-dependencies-access-scopes, 访问作用域>> ，
逻辑上更早/更晚的 阶段 并没有被包含。
====

[[synchronization-pipeline-stages-types]]
管线阶段的顺序依赖于 特定的管线；图像、计算、转移或者 host管线。 

对于图形管线，如下阶段按顺序发生：

  * ename:VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT
  * ename:VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT
  * ename:VK_PIPELINE_STAGE_VERTEX_INPUT_BIT
  * ename:VK_PIPELINE_STAGE_VERTEX_SHADER_BIT
  * ename:VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT
  * ename:VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT
  * ename:VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT
  * ename:VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT
  * ename:VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT
  * ename:VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT
  * ename:VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT
  * ename:VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT

对于计算管线，如下阶段按顺序发生：

  * ename:VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT
  * ename:VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT
  * ename:VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT
  * ename:VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT

对于转换管线，如下阶段按顺序发生：

  * ename:VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT
  * ename:VK_PIPELINE_STAGE_TRANSFER_BIT
  * ename:VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT

对于CPU端操作，只会有一个阶段会发生，所以不需要保证顺序：

  * ename:VK_PIPELINE_STAGE_HOST_BIT

ifdef::VK_NVX_device_generated_commands[]
For the 命令processing pipeline, the following 阶段s occur in this
order:

  * ename:VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT
  * ename:VK_PIPELINE_STAGE_COMMAND_PROCESS_BIT_NVX
  * ename:VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT
endif::VK_NVX_device_generated_commands[]

[[synchronization-access-types]]
=== 访问类型

Memory in Vulkan can: be accessed from within shader invocations and via
some fixed-function 阶段s of the pipeline.
The _access type_ is a function of the <<descriptorsets, descriptor type>>
used, or how a fixed-function 阶段 访问memory.
Each access type corresponds to a bit flag in slink:VkAccessFlagBits.

[[synchronization-access-masks]]
Some synchronization commands take sets of 访问类型 as parameters to
define the <<synchronization-dependencies-access-scopes, 访问作用域>> of
a内存依赖.
若a synchronization 命令includes a 源访问掩码, its first
<<synchronization-dependencies-access-scopes, 访问作用域>> only includes
访问via the 访问类型 specified in that mask.
Similarly, if a synchronization 命令includes a 目标访问掩码,
its second <<synchronization-dependencies-access-scopes, 访问作用域>> only
includes 访问via the 访问类型 specified in that mask.

// refBegin VkAccessFlagBits Bitmask specifying内存访问类型 that will participate in a内存依赖

可以被设置的访问类型包含如下：

[[synchronization-access-flags]]
include::../api/enums/VkAccessFlagBits.txt[]

  * ename:VK_ACCESS_INDIRECT_COMMAND_READ_BIT: Read access to一个indirect
    命令structure read as part of一个indirect drawing or dispatch
    command.
  * ename:VK_ACCESS_INDEX_READ_BIT: Read access to一个索引 缓冲区 as part
    of一个indexed drawing command, bound by flink:vkCmdBindIndexBuffer.
  * ename:VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT: Read access to a vertex
    缓冲区 as part of a drawing command, bound by
    flink:vkCmdBindVertexBuffers.
  * ename:VK_ACCESS_UNIFORM_READ_BIT: Read access to a
    <<descriptorsets-uniformbuffer, uniform 缓冲区>>.
  * ename:VK_ACCESS_INPUT_ATTACHMENT_READ_BIT: Read access to an
    <<renderpass, input attachment>> within a renderpass during fragment
    shading.
  * ename:VK_ACCESS_SHADER_READ_BIT: Read access to a
    <<descriptorsets-storagebuffer, storage buffer>>,
    <<descriptorsets-uniformtexelbuffer, uniform texel buffer>>,
    <<descriptorsets-storagetexelbuffer, storage texel buffer>>,
    <<descriptorsets-sampledimage, sampled image>>, or
    <<descriptorsets-storageimage, storage image>>.
  * ename:VK_ACCESS_SHADER_WRITE_BIT: Write access to a
    <<descriptorsets-storagebuffer, storage buffer>>,
    <<descriptorsets-storagetexelbuffer, storage texel buffer>>, or
    <<descriptorsets-storageimage, storage image>>.
  * ename:VK_ACCESS_COLOR_ATTACHMENT_READ_BIT: Read access to a
    <<renderpass, color attachment>>, such as via <<framebuffer-blending,
    blending>>, <<framebuffer-logicop, logic operations>>, or via certain
    <<renderpass-load-store-ops, subpass load operations>>.
  * ename:VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT: Write access to a
    <<renderpass, color or resolve attachment>> during a <<renderpass,
    render pass>> or via certain <<renderpass-load-store-ops, subpass load
    and store operations>>.
  * ename:VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT: Read access to a
    <<renderpass, depth/stencil attachment>>, via <<fragops-ds-state, depth
    or stencil operations>> or via certain <<renderpass-load-store-ops,
    subpass load operations>>.
  * ename:VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT: Write access to a
    <<renderpass, depth/stencil attachment>>, via <<fragops-ds-state, depth
    or stencil operations>> or via certain <<renderpass-load-store-ops,
    subpass load and store operations>>.
  * ename:VK_ACCESS_TRANSFER_READ_BIT: Read access to一个图像or缓冲区in
    a <<copies, copy>> operation.
  * ename:VK_ACCESS_TRANSFER_WRITE_BIT: Write access to一个图像or buffer
    in a <<clears, clear>> or <<copies, copy>> operation.
  * ename:VK_ACCESS_HOST_READ_BIT: Read access by a host operation.
    Accesses of this type are not performed through a resource, but directly
    on memory.
  * ename:VK_ACCESS_HOST_WRITE_BIT: Write access by a host operation.
    Accesses of this type are not performed through a resource, but directly
    on memory.
  * ename:VK_ACCESS_MEMORY_READ_BIT: Read access via non-specific entities.
    These entities include the Vulkan 设备and host, but may: also include
    entities external to the Vulkan 设备or otherwise not part of the core
    Vulkan pipeline.
    When included in a 目标访问掩码, makes all available writes
    visible to all future read 访问on entities known to the Vulkan
    device.
  * ename:VK_ACCESS_MEMORY_WRITE_BIT: Write access via non-specific
    entities.
    These entities include the Vulkan 设备and host, but may: also include
    entities external to the Vulkan 设备or otherwise not part of the core
    Vulkan pipeline.
    When included in a 源访问掩码, all writes that are performed by
    entities known to the Vulkan 设备are made available.
    When included in a 目标访问掩码, makes all available writes
    visible to all future write 访问on entities known to the Vulkan
    device.
ifdef::VK_NVX_device_generated_commands[]
  * ename:VK_ACCESS_COMMAND_PROCESS_READ_BIT_NVX: Reads from sname:VkBuffer
    inputs to flink:vkCmdProcessCommandsNVX.
  * ename:VK_ACCESS_COMMAND_PROCESS_WRITE_BIT_NVX: Writes to the target
    命令缓冲区in flink:vkCmdProcessCommandsNVX.
endif::VK_NVX_device_generated_commands[]

Certain 访问类型 are only performed by a subset of 管线阶段.
Any synchronization 命令that takes both 阶段掩码s and 访问掩码
uses both to define the <<synchronization-dependencies-access-scopes, access
scopes>> - only the specified 访问类型 performed by the specified 阶段s
are included in the 访问作用域.
An application must: not specify一个access flag in a synchronization command
if it does not include a 管线阶段 in the corresponding 阶段掩码 that
is able to perform 访问of that type.
The following table lists, for each access flag, which 管线阶段 can:
perform that type of access.

[[synchronization-access-types-supported]]
.Supported access types
[cols="50,50",options="header"]
|====
|Access flag                                                  | Supported 管线阶段
|ename:VK_ACCESS_INDIRECT_COMMAND_READ_BIT                    | ename:VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT
|ename:VK_ACCESS_INDEX_READ_BIT                               | ename:VK_PIPELINE_STAGE_VERTEX_INPUT_BIT
|ename:VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT                    | ename:VK_PIPELINE_STAGE_VERTEX_INPUT_BIT
|ename:VK_ACCESS_UNIFORM_READ_BIT                             | ename:VK_PIPELINE_STAGE_VERTEX_SHADER_BIT, ename:VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT, ename:VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT, ename:VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT, ename:VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT, or ename:VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT
|ename:VK_ACCESS_INPUT_ATTACHMENT_READ_BIT                    | ename:VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT
|ename:VK_ACCESS_SHADER_READ_BIT                              | ename:VK_PIPELINE_STAGE_VERTEX_SHADER_BIT, ename:VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT, ename:VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT, ename:VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT, ename:VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT, or ename:VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT
|ename:VK_ACCESS_SHADER_WRITE_BIT                             | ename:VK_PIPELINE_STAGE_VERTEX_SHADER_BIT, ename:VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT, ename:VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT, ename:VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT, ename:VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT, or ename:VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT
|ename:VK_ACCESS_COLOR_ATTACHMENT_READ_BIT                    | ename:VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT
|ename:VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT                   | ename:VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT
|ename:VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT            | ename:VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT, or ename:VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT
|ename:VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT           | ename:VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT, or ename:VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT
|ename:VK_ACCESS_TRANSFER_READ_BIT                            | ename:VK_PIPELINE_STAGE_TRANSFER_BIT
|ename:VK_ACCESS_TRANSFER_WRITE_BIT                           | ename:VK_PIPELINE_STAGE_TRANSFER_BIT
|ename:VK_ACCESS_HOST_READ_BIT                                | ename:VK_PIPELINE_STAGE_HOST_BIT
|ename:VK_ACCESS_HOST_WRITE_BIT                               | ename:VK_PIPELINE_STAGE_HOST_BIT
|ename:VK_ACCESS_MEMORY_READ_BIT                              | N/A
|ename:VK_ACCESS_MEMORY_WRITE_BIT                             | N/A
ifdef::VK_NVX_device_generated_commands[]
|ename:VK_ACCESS_COMMAND_PROCESS_READ_BIT_NVX                 | ename:VK_PIPELINE_STAGE_COMMAND_PROCESS_BIT_NVX
|ename:VK_ACCESS_COMMAND_PROCESS_WRITE_BIT_NVX                | ename:VK_PIPELINE_STAGE_COMMAND_PROCESS_BIT_NVX
endif::VK_NVX_device_generated_commands[]
|====


[[synchronization-framebuffer-regions]]
=== Framebuffer Region Dependencies

就<<synchronization-pipeline-stages, 管线阶段>> 所操作的缓冲区而言，都是  _framebuffer-space_pipeline 阶段。
这些阶段如下：

  * ename:VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT
  * ename:VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT
  * ename:VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT
  * ename:VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT

对于这些管现阶段而言，从操作的第一个set到第二个set可以是单 _framebuffer-global_ 依赖，也可以被拆分成多个  _framebuffer-local_ 依赖。

带有non-framebuffer-space 管现阶段的依赖，既不 framebuffer-global ，也不 framebuffer-local。

一个 _framebuffer region_ 是一个 sample (x, y, layer, sample) 坐标的集合，是整个缓冲区的一个子集。

一个单 framebuffer-local 依赖，保证对于单个缓冲区区域，操作的第一个set与 可用性操作再 可见性操作、操作的第二个set之前发生。
对于一个framebuffer-local 依赖，不保证 缓冲区区域之间的顺序。

一个framebuffer-global 依赖，保证对所有缓冲区区域的操作的第一个set 在对任何缓冲区区域的第二个set 之前发生。

.注意
[NOTE]
====
因为 fragment调用并没有在任何分组中被指定运行，帧缓冲区区域的大小取决于Vulkan实现，应用程序并不知道，而且，必须认为比单个sample要大。
====

若a synchronization 命令includes a pname:dependencyFlags parameter, and
specifies the ename:VK_DEPENDENCY_BY_REGION_BIT flag, then it defines
framebuffer-local dependencies for the framebuffer-space 管线阶段 in
that synchronization command, for all framebuffer regions.
若no pname:dependencyFlags parameter is included, or the
ename:VK_DEPENDENCY_BY_REGION_BIT flag is not specified, then a
framebuffer-global 依赖is specified for those 阶段s.
The ename:VK_DEPENDENCY_BY_REGION_BIT flag does not affect the dependencies
between non-framebuffer-space 管线阶段, nor does it affect the
dependencies between framebuffer-space and non-framebuffer-space pipeline
阶段s.

.注意
[NOTE]
====
Framebuffer-local dependencies are more optimal for most architectures;
particularly tile-based architectures - which can keep framebuffer-regions
entirely in on-chip registers and thus avoid external bandwidth across such
a 依赖.
Including a framebuffer-global 依赖in your rendering will usually
force all implementations to flush data to memory, or to a higher level
cache, breaking any potential locality optimizations.
====


[[synchronization-implicit]]
== 隐式同步保障

Vulkan支持少量的隐式顺序保证，确保命令提交的顺序是有意义的，且在常规的操作中避免不必要的复杂性。

[[synchronization-submission-order]]
_Submission order_ 是Vulkan中基础的排序，对于记录并提交到单个队列的 <<fundamentals-queueoperation-command-types, action and
synchronization commands>> 的顺序是有意义的。显式的或者隐式的排序保证了，在Vulakn中以此为前提的不同命令之间所有工作，这种排序都是有意义的。

Submission order for any given set of commands is based on the order in
which they were recorded to 命令缓冲区and then submitted.
This order is determined as follows:

  . The initial order is determined by the order in which
    flink:vkQueueSubmit commands are executed on the host, for a single
    queue, from first to last.
  . The order in which slink:VkSubmitInfo structures are specified in the
    pname:pSubmits parameter of flink:vkQueueSubmit, from lowest索引to
    highest.
  . The order in which 命令缓冲区are specified in the
    pname:pCommandBuffers member of slink:VkSubmitInfo, from lowest索引to
    highest.
  . The order in which commands were recorded to a 命令缓冲区on the
    host, from first to last:
  ** For commands recorded outside a render pass, this includes all other
     commands recorded outside a renderpass, including
     flink:vkCmdBeginRenderPass and flink:vkCmdEndRenderPass commands; it
     does not directly include commands inside a render pass.
  ** For commands recorded inside a render pass, this includes all other
     commands recorded inside the same subpass, including the
     flink:vkCmdBeginRenderPass and flink:vkCmdEndRenderPass commands that
     delimit the same renderpass instance; it does not include commands
     recorded to other subpasses.

记录到一个命令缓冲区的<<fundamentals-queueoperation-command-types, 原子和同步命令>>执行 <<synchronization-submission-order, 提交顺序>> 中
ename:VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT 管线阶段 -- 在此阶段内每个命令之间形成了一个隐式的执行依赖。

<<fundamentals-queueoperation-command-types, 状态命令>> 并不在设备上执行任何操作，反而，当它们在CPU端执行时设置命令缓冲区的状态，
依他们被记录的顺序。
<<fundamentals-queueoperation-command-types, Action commands>> consume the
current state of the 命令缓冲区when they are recorded, and will execute
state changes on the 设备as required to match the recorded state.

<<queries-order, 查询命令>>, <<drawing-primitive-order, 图元流经图形管线的顺序>> 和
<<synchronization-image-barrier-layout-transition-order, 图像内存屏障的一部分图像布局转换>> 也给予提交顺序 提供了额外的保证。

<<synchronization-pipeline-stages-order, 管线阶段>>的执行，
within a given 命令also has a loose ordering, dependent only on a single
command.


[[synchronization-fences]]
== 栅栏

// refBegin VkFence Opaque handle to a fence object

栅栏是同步原语，可以用来在CPU端队列上插入一个依赖。栅栏由两个状态：激发的、未激发的。一个栅栏可以被当作<<devsandqueues-submission, 队列提交 >> 命令
执行的一部分从而被激发。
栅栏可以在CPU端被  flink:vkResetFences 设置为 未激发状态。
栅栏可以在CPU端让 flink:vkWaitForFences 命令等待，且当前的状态可以通过 flink:vkGetFenceStatus 查询。 

栅栏 可以使用如下  sname:VkFence  handle表示：

include::../api/handles/VkFence.txt[]

// refEnd VkFence

// refBegin vkCreateFence Create a new fence object

可调用如下命令掉创建栅栏：

include::../api/protos/vkCreateFence.txt[]

  * pname:device 是创建栅栏的逻辑设备。
  * pname:pCreateInfo 是一个指针，指向一个  sname:VkFenceCreateInfo 数据结构的实例，它包含如何创建栅栏的信息。
  * pname:pAllocator 控制CPU端内存分配，如  <<memory-allocation, 内存分配>> 一章详述。
  * pname:pFence 指向一个handle，它包含被创建并返回的栅栏对象。

include::../validity/protos/vkCreateFence.txt[]

// refBegin VkFenceCreateInfo Structure specifying parameters of a newly created fence

sname:VkFenceCreateInfo 类型数据结构定义如下：

include::../api/structs/VkFenceCreateInfo.txt[]

  * pname:sType 是数据结构的类型。
  * pname:pNext 是 `NULL` 或者一个指向拓展特定的数据结构的指针。
  * pname:flags 定义了初始状态和栅栏的行为。
    Bits which can: be set include:
+
--
// refBegin VkFenceCreateFlagBits Bitmask specifying initial state and behavior of a fence
include::../api/enums/VkFenceCreateFlagBits.txt[]
--
+
若pname:flags 包含 ename:VK_FENCE_CREATE_SIGNALED_BIT，那么栅栏对象被创建时处于已经激发的状态；否则就处于未激发状态。

include::../validity/structs/VkFenceCreateInfo.txt[]

// refBegin vkDestroyFence Destroy a fence object

可调用如下命令来销毁fence：

include::../api/protos/vkDestroyFence.txt[]

  * pname:device 是销毁栅栏对象的逻辑设备。
  * pname:fence 是需要被销毁的栅栏的handle。
  * pname:pAllocator 控制CPU端内存分配，如 <<memory-allocation, 内存分配>> 一章详述。

.正确使用
****
  * 所有指向 pname:fence的 <<devsandqueues-submission, 队列提交 >> 命令 必须已经完成执行力。
  * 若 sname:VkAllocationCallbacks 在创建栅栏是被提供，那么在此时需要提供一套兼容的回调函数。
  * 若在创建栅栏时没有提供 sname:VkAllocationCallbacks，那么这个 pname:pAllocator 必须: 是 `NULL`
****

include::../validity/protos/vkDestroyFence.txt[]

// refBegin vkGetFenceStatus Return the status of a fence

可调用如下命令来查询CPU端栅栏的状态：

include::../api/protos/vkGetFenceStatus.txt[]

  * pname:device 是拥有该栅栏的逻辑设备。
  * pname:fence 是需要被查询的栅栏handle。

若调用成功, fname:vkGetFenceStatus 返回栅栏对象的状态，用如下代码表示：

.Fence Object Status Codes
[width="80%",options="header"]
|====
| Status | Meaning
| ename:VK_SUCCESS |  pname:fence 指定的栅栏对象已经被激发。
| ename:VK_NOT_READY | pname:fence 指定的栅栏对象未被激发。
|====

若一个 <<devsandqueues-submission, 队列提交 >> 命令被暂停执行，那么这个命令的返回值可能会立即过期。

include::../validity/protos/vkGetFenceStatus.txt[]

[[synchronization-fences-unsignaling]]
// refBegin vkResetFences Resets one or more fence objects

可调用如下命令，在CPU端设置栅栏的状态为非激发：

include::../api/protos/vkResetFences.txt[]

  * pname:device 是拥有栅栏的逻辑设备。
  * pname:fenceCount 是需要被重置的栅栏数量。
  * pname:pFences 是一个指针，指向一个需要被重置的栅栏的数组。 

当 flink:vkResetFences 在CPU端被执行，它为每一个栅栏定义了一个 _fence unsignal operation_，它把栅栏设置为非激发状态。

若在flink:vkResetFences执行时，pname:pFences数组中任何一个已经处于非激发状态，那么flink:vkResetFences 将对于该栅栏没有效果。

.正确使用
****
  * pname:pFences数组中任何元素当前都不能和任何在队列上未执行完成的队列命令关联。
****

include::../validity/protos/vkResetFences.txt[]

[[synchronization-fences-signaling]]
当一个栅栏被当作 <<devsandqueues-submission, 队列提交>> 命令的一部分，提交到队列时，它在被当作该命令的一部分的批量任务上定义了一个内存依赖，
且定义了一个 _fence signal operation_，该operation设置栅栏为激发状态。

第一个<<synchronization-dependencies-scopes, 同步范围>>包含同一个 <<devsandqueues-submission, queue
submission>> 内提交的批量任务。
通过 flink:vkQueueSubmit 定义的栅栏激发操作此外还包含在第一个同步范围内 通过flink:vkQueueSubmit提交到同一个队列的之前的队列提交。

第二个<<synchronization-dependencies-scopes, 同步范围>>只包含栅栏激发操作。

第一个<<synchronization-dependencies-access-scopes,  访问范围>>包含此设备操纵的所有内存访问。

第二个 <<synchronization-dependencies-access-scopes, 访问范围>> 是空的。

// refBegin vkWaitForFences Wait for one or more fences to become signaled

在CPU端，可调用如下命令来等待一个或者多个栅栏来进入激发状态：

include::../api/protos/vkWaitForFences.txt[]

  * pname:device 是拥有栅栏的逻辑设备。
  * pname:fenceCount 是需要等待的栅栏的数量。
  * pname:pFences 是指针，指向 pname:fenceCount 个栅栏的handle的数组。    
  * pname:waitAll 是接触等待必须要满足的条件。
	 若pname:waitAll 是 ename:VK_TRUE，那么条件就是pname:pFences中所有的栅栏都是激发状态的。
	 否则，条件就是pname:pFences中至少一个栅栏是激发状态的。
  * pname:timeout 是过期时间，单位为纳秒。pname:timeout 被调整为Vulkan实现所允许的精确度下最接近的值，故可能比一纳秒也大很多，
     所以，真实过期时间比给定的时间要长。  

若调用 fname:vkWaitForFences时，条件都满足了，那么fname:vkWaitForFences 直接立刻返回。
若调用 fname:vkWaitForFences时，条件没有被满足，那么fname:vkWaitForFences 将阻塞，并且等待pname:timeout 纳秒，以检测条件是否被满足。


若 pname:timeout 为0，那么 fname:vkWaitForFences 不等待，但是将返回栅栏当前的状态。
若条件不满足，将返回ename:VK_TIMEOUT，即使实际上并没有执行等待。

若条件被满足之前指定的timeout 时间过期，fname:vkWaitForFences 将返回 ename:VK_TIMEOUT。
若在 pname:timeout纳秒过期之前条件已经满足，fname:vkWaitForFences 将返回 ename:VK_SUCCESS。

include::../validity/protos/vkWaitForFences.txt[]

[[synchronization-fences-waiting]]
等待一个栅栏变为激发状态就 定义了一个行依赖 ，或者通过  flink:vkWaitForFences、或轮询flink:vkGetFenceStatus。

第一个<<synchronization-dependencies-scopes, 同步作用域>>只包含栅栏的激发操作。

第二个<<synchronization-dependencies-scopes, 同步作用域>>包含主机端  flink:vkWaitForFences操作或者flink:vkGetFenceStatus 操作，
指示栅栏已经被激发。

.注意
[NOTE]
====
激发栅栏与 在host端等待，并不保证 内存访问的结果对于host端可见。
为了提供该保证，应用程序必须在设备写入与 将激发栅栏的提交结束之间 插入一个内存屏障，
且pname:dstAccessMask 设置为 ename:VK_ACCESS_HOST_READ_BIT，pname:dstStageMask 设置为 ename:VK_PIPELINE_STAGE_HOST_BIT，
pname:srcStageMask 与 pname:srcAccessMask 成员被设置为合适的值来保证 写入完成。
若 内存被分配时带有ename:VK_MEMORY_PROPERTY_HOST_COHERENT_BIT，那么fname:vkInvalidateMappedMemoryRanges 必须在栅栏
被激发之后被调用，以此保证写入对于host端可见，细节如<<memory-device-hostaccess,Host Access to Device Memory Objects>>小节所述。
====

ifdef::VK_EXT_display_control[]
include::VK_EXT_display_control/fence_events.txt[]
endif::VK_EXT_display_control[]

[[synchronization-semaphores]]
== 信号量

// refBegin VkSemaphore Opaque handle to a semaphore object

信号量是同步原语，可用来在提交到队列的批量任务之间插入依赖。
信号量有两种状态：激发的、未激发的。
当批量命令执行完成后，信号量可以被激发。
批量任务在真正执行前，可以等待信号量被激发，且信号量在批量任务开始执行时是未激发的。

信号量可以使用 sname:VkSemaphore handle表示:

include::../api/handles/VkSemaphore.txt[]

// refEnd VkSemaphore

// refBegin vkCreateSemaphore Create a new队列semaphore object

可调用如下命令创建信号量：

include::../api/protos/vkCreateSemaphore.txt[]

  * pname:device 是创建信号量的逻辑设备。
  * pname:pCreateInfo 是一个指针，指向一个 sname:VkSemaphoreCreateInfo 数据结构实例，它包含如何创建信号量的信息。    
  * pname:pAllocator 控制CPU端内存分配，如 <<memory-allocation, 内存分配 >> 一章详述。
  * pname:pSemaphore 指向被返回的信号量对象的handle。

当创建好后，信号量处于未激发状态。

include::../validity/protos/vkCreateSemaphore.txt[]

// refBegin VkSemaphoreCreateInfo Structure specifying parameters of a newly created semaphore

sname:VkSemaphoreCreateInfo 类型数据结构定义如下：

include::../api/structs/VkSemaphoreCreateInfo.txt[]

  * pname:sType 是数据结构的类型。
  * pname:pNext 是 `NULL` 或者一个指向拓展特定的数据结构的指针。
  * pname:flags 被保留。

include::../validity/structs/VkSemaphoreCreateInfo.txt[]

// refBegin vkDestroySemaphore Destroy a semaphore object

可调用如下命令来销毁信号量：

include::../api/protos/vkDestroySemaphore.txt[]

  * pname:device 是销毁信号量的逻辑设备。
  * pname:semaphore 是需要被销毁的信号量的handle。
  * pname:pAllocator 控制CPU端内存分配，如 <<memory-allocation, 内存分配 >> 一章详述。

.正确使用
****
  * All submitted batches that refer to pname:semaphore must: have completed
    execution
  * 若sname:VkAllocationCallbacks 当 pname:semaphore 被创建时提供，那么这里就应该提供兼容的一系列callback。    
  * 若sname:VkAllocationCallbacks 在创建 pname:semaphore 时没有被提供，那么pname:pAllocator 必须为  `NULL`
****

include::../validity/protos/vkDestroySemaphore.txt[]


[[synchronization-semaphores-signaling]]
=== 激发信号量

当一个批量任务  通过一个<<devsandqueues-submission, 队列提交>>提交到队列，它包含了需要被激发的信号量，
它定义了一个批量任务上内存依赖，定义了 _semaphore signal operations_ ，该操作设置信号量为激发状态。

第一<<synchronization-dependencies-scopes, 同步作用域>>
包含被提交到同批次的每个命令。
通过flink:vkQueueSubmit定义的 信号量激发操作，包含之前通过flink:vkQueueSubmit提交到同一队列的所有批次，
包含同一<<devsandqueues-submission,队列提交>> 命令所提交的批量，只是在批量数组中占据较小的索引号。


第二个 <<synchronization-dependencies-scopes, 同步作用域>>只包含信号量激发操作。

第一个<<synchronization-dependencies-access-scopes, 访问作用域>>包含所有的device执行的内存访问。

第二个 <<synchronization-dependencies-access-scopes, 访问作用域>> 是空的。


[[synchronization-semaphores-waiting]]
=== 等待信号量 & 取消激发

当一个批次通过 一个<<devsandqueues-submission, 队列提交>>提交到队列，它包含一个在等待的信号量，
其定义了一个在之前的信号量激发的操作与批次之间的内存依赖，且定义了 _semaphore unsignal operations_ ，该操作把信号量设置为未激发状态。

第一访问作用域包含所有的信号量激发的操作，该操作作用于在同一批次上等待的信号量，并且在等待完成之前发生。

第二<<synchronization-dependencies-scopes, 同步作用域>>包含提交到同一批次的每一个命令。

以flink:vkQueueSubmit为例, 第二个同步作用域 被限制
limited to operations on the 管线阶段 determined by the
<<synchronization-pipeline-stages-masks, 源阶段掩码>> specified
by the corresponding element of pname:pWaitDstStageMask.
Also, in the case of flink:vkQueueSubmit, the second 同步作用域
additionally includes all batches subsequently submitted to the same queue
via flink:vkQueueSubmit, including batches that are submitted in the same
<<devsandqueues-submission,队列submission>> command, but at a higher
index within the array of batches.

第一<<synchronization-dependencies-access-scopes, 访问作用域  >> 是空的。

第二<<synchronization-dependencies-access-scopes,访问作用域>>包含设备访问的所有内存。

信号量反激发操作在 执行依赖的操作的第一个集合之后发生，在执行依赖的操作的第二个集合之前发生。

.注意
[NOTE]
====
不像栅栏或者事件，等待信号量的行为也会反激发该信号量。
若两个操作被指定等待同一个信号量，且没有其他的执行依赖处于这些操作之间，那么此行为就是未定义的。
一个执行依赖 必须出现以保证对那些等待的第一个的信号量反激发操作，在信号量被再次激发之前发生，且在第二次取消之间发生。
信号量等待与激发应该成对出现。
====

ifdef::VK_KHR_swapchain[]
.注意
[NOTE]
====
A common scenario for using pname:pWaitDstStageMask with values other than
ename:VK_PIPELINE_STAGE_ALL_COMMANDS_BIT is when synchronizing a window
system presentation操作against subsequent 命令缓冲区which
render the next frame.
In this case, a presentation 图像must: not be overwritten until the
presentation操作completes, but other 管线阶段 can: execute
without waiting.
A mask of ename:VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT prevents
subsequent color attachment writes from executing until the semaphore
signals.
Some implementations may: be able to execute transfer operations and/or
vertex processing work before the semaphore is signaled.

若一个图像布局转换需要在一个可展示的图像上进行操作，且在该图像被帧缓冲区使用之前，那么就可以在获取图像之后被当作第一个
操作被提交到队列，且不应该阻止其他操作与该展示操作有所覆盖。
例如，一个 sname:VkImageMemoryBarrier 应该使用：

  * pname:srcStageMask = ename:VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT
  * pname:srcAccessMask = 0
  * pname:dstStageMask = ename:VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT
  * pname:dstAccessMask = ename:VK_ACCESS_COLOR_ATTACHMENT_READ_BIT |
    ename:VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT.
  * pname:oldLayout = etext:VK_IMAGE_LAYOUT_PRESENT_SRC_KHR
  * pname:newLayout = ename:VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL

同样, pname:oldLayout 可以是ename:VK_IMAGE_LAYOUT_UNDEFINED，若此图像的内容不需要被保留。

这个屏障在之前的展现操作与后续的颜色附件输出操作之间 实现了一个依赖链，且在二者之间进行了布局转换，在之前的工作与
后续的顶点处理阶段之间并没有引入依赖。
更准确的来说，信号量在展现操作完成后激发，信号量在 
ename:VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT 阶段之前一直等待，且在同一种阶段与两者之间的执行的布局转换 之间存在依赖。
====
endif::VK_KHR_swapchain[]


[[synchronization-events]]
== 事件

// refBegin VkEvent Opaque handle to a event object

事件是它同步原语， 可用于在提交到同一个队列的不同命令之间，或者在CPU端与队列之间，插入高度优化的依赖。
事件有两种状态：激发的、未激发的。
应用程序可以在CPU端或者设备端激发一个事件，或者取消激发状态。
设备可在进一步执行其他操作之前等待事件直至其变为激发被激发。
在CPU端没有命令等待事件变被激发，事件的当前状态也是可以被查询。

使用sname:VkEvent handle表示事件:

include::../api/handles/VkEvent.txt[]

// refEnd VkEvent

// refBegin vkCreateEvent Create a new event object

可调用如下命令来创建事件：

include::../api/protos/vkCreateEvent.txt[]

  * pname:device 是创建事件的逻辑设备。
  * pname:pCreateInfo 是一个指针，指向一个 sname:VkEventCreateInfo 数据结构实例，它包含了创建事件所需的信息。
  * pname:pAllocator 控制CPU端内存分配，如 <<memory-allocation, 内存分配 >> 一章详述。
  * pname:pEvent 指向被创建的事件对象的handle。

创建完成后，事件对象处于未激发状态。

include::../validity/protos/vkCreateEvent.txt[]

// refBegin VkEventCreateInfo Structure specifying parameters of a newly created event

sname:VkEventCreateInfo 类型数据结构定义如下：

include::../api/structs/VkEventCreateInfo.txt[]

  * pname:sType 是数据结构的类型。
  * pname:pNext 是 `NULL` 或者一个指向拓展特定的数据结构的指针。
  * pname:flags 被保留。

include::../validity/structs/VkEventCreateInfo.txt[]

// refBegin vkDestroyEvent Destroy一个event object

调用如下命令来销毁事件：

include::../api/protos/vkDestroyEvent.txt[]

  * pname:device 是销毁事件的逻辑设备。
  * pname:event 是需要被销毁的事件。
  * pname:pAllocator 控制CPU端内存分配，如 <<memory-allocation, 内存分配 >> 一章详述。

.正确使用
****
  * All submitted commands that refer to pname:event must: have completed
    execution
  * 若sname:VkAllocationCallbacks were provided when pname:event was
    created, a compatible set of callbacks must: be provided here
  * 若no sname:VkAllocationCallbacks were provided when pname:event was
    created, pname:pAllocator must: be `NULL`
****

include::../validity/protos/vkDestroyEvent.txt[]

// refBegin vkGetEventStatus Retrieve the status of一个event object

可在CU端使用如下命令来查询事件的状态：

include::../api/protos/vkGetEventStatus.txt[]

  * pname:device 是拥有该事件的逻辑设备。
  * pname:event 是需要被查询的事件handle。

Upon success, fname:vkGetEventStatus returns the state of the event object
with the following return codes:

.Event Object Status Codes
[width="80%",options="header"]
|====
| Status | Meaning
| ename:VK_EVENT_SET | The event specified by pname:event is signaled.
| ename:VK_EVENT_RESET | The event specified by pname:event is unsignaled.
|====

若a fname:vkCmdSetEvent or fname:vkCmdResetEvent 命令is pending
execution, then the value returned by this 命令may: immediately be out
of date.

The state of一个event can: be updated by the host.
The state of the event is immediately changed, and subsequent calls to
fname:vkGetEventStatus will return the new state.
若an event is already in the requested state, then updating it to the same
state has no effect.

include::../validity/protos/vkGetEventStatus.txt[]

[[synchronization-events-signaling-host]]
// refBegin vkSetEvent Set一个event to signaled state

可通过如下命令，在CPU端来设置事件的状态为 激发状态：

include::../api/protos/vkSetEvent.txt[]

  * pname:device 是拥有该事件的逻辑设备。
  * pname:event 是需要被设置的事件。

当 flink:vkSetEvent 在CPU端执行是，它定义了一个  _event signal operation_ ，此操作设置事件为已激发状态。

 在 flink:vkSetEvent 被执行时，若 pname:event 已经处于激发状态，那么 flink:vkSetEvent 没有任何效果，不会导致事件激发操作。

include::../validity/protos/vkSetEvent.txt[]

[[synchronization-events-unsignaling-host]]
// refBegin vkResetEvent Reset一个event to non-signaled state

可通过如下命令，在CPU端来设置事件的状态为 未激发状态：

include::../api/protos/vkResetEvent.txt[]

  * pname:device 是拥有该事件的逻辑设备。
  * pname:event 是需要被重置的事件。

当在CPU端执行 flink:vkResetEvent 时，它定义了一个 _event unsignal operation_ ，它会把事件重置为非激发状态。
若在执行 flink:vkResetEvent时，pname:event 已经处于非激发状态，那么 flink:vkResetEvent没有任何效果，不会导致事件取消激发操作。


.正确使用
****
  * pname:event must: not be waited on by a fname:vkCmdWaitEvents command
    that is currently executing
****

include::../validity/protos/vkResetEvent.txt[]

在GPU端，也可通过如下的被插入到命令缓冲区的命令，来设置事件的状态:

[[synchronization-events-signaling-device]]
// refBegin vkCmdSetEvent Set一个event object to signaled state

可使用如下命令在GPU端 来激发事件：

include::../api/protos/vkCmdSetEvent.txt[]

  * pname:commandBuffer 是命令被记录所在的命令缓冲区。
  * pname:event 是将被激发的事件。
  * pname:stageMask 指定了 用来决定何时激发 pname:event 的 <<synchronization-pipeline-stages,源阶段掩码>>。

当flink:vkCmdSetEvent 被提交到队列，它在被提交到队列的命令上 定义了一个执行依赖， 且定义了一个时间激发操作，将设置时间为已激发状态。

The first <<synchronization-dependencies-scopes, 同步作用域>>
includes every 命令previously submitted to the same queue, including
those in the same 命令缓冲区and batch.
The 同步作用域 is limited to operations on the 管线阶段
determined by the <<synchronization-pipeline-stages-masks, 源阶段掩码>> specified by pname:stageMask.

The second <<synchronization-dependencies-scopes, 同步作用域>>
includes only the event signal operation.

若在GPU执行 flink:vkCmdSetEvent 时， pname:event 已经处于激发状态，那么flink:vkCmdSetEvent 没有任何作用，将不会导致任何事件激发操作，
不会生成执行依赖。

.正确使用
****
  * pname:stageMask must: not include ename:VK_PIPELINE_STAGE_HOST_BIT
  * 若the <<features-features-geometryShader, 几何着色器>> feature is
    not enabled, pname:stageMask must: not contain
    ename:VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT
  * 若the <<features-features-tessellationShader, 细分着色器>>
    feature is not enabled, pname:stageMask must: not contain
    ename:VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT or
    ename:VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT
****

include::../validity/protos/vkCmdSetEvent.txt[]

[[synchronization-events-unsignaling-device]]
// refBegin vkCmdResetEvent Reset一个event object to non-signaled state


可使用如下命令在GPU端 设置事件为未激发状态：

include::../api/protos/vkCmdResetEvent.txt[]

  * pname:commandBuffer 是命令被记录所在的命令缓冲区。
  * pname:event 是需被被设置为为激发状态的事件。
  * pname:stageMask 指定了 用来决定何时取消激发 pname:event 的 <<synchronization-pipeline-stages,源阶段掩码>>。

当 flink:vkCmdResetEvent 被提交到队列，它在提交到队列的命令之间定义了一个执行依赖，且定义了一个时间反取消操作，该操作重置时间为未激发状态状态。

The first <<synchronization-dependencies-scopes, 同步作用域>>
includes every 命令previously submitted to the same queue, including
those in the same 命令缓冲区and batch.
The同步作用域 is limited to operations on the 管线阶段
determined by the <<synchronization-pipeline-stages-masks, source stage
mask>> specified by pname:stageMask.

The second <<synchronization-dependencies-scopes, 同步作用域>>
includes only the event unsignal operation.

若pname:event is already in the unsignaled state when flink:vkCmdResetEvent
is executed on the device, then flink:vkCmdResetEvent has no effect, no
event unsignal操作occurs, and no 执行依赖is generated.

.正确使用
****
  * pname:stageMask must: not include ename:VK_PIPELINE_STAGE_HOST_BIT
  * 若the <<features-features-geometryShader, 几何着色器>> feature is
    not enabled, pname:stageMask must: not contain
    ename:VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT
  * 若the <<features-features-tessellationShader, 细分着色器>>
    feature is not enabled, pname:stageMask must: not contain
    ename:VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT or
    ename:VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT
  * When this 命令executes, pname:event must: not be waited on by a
    fname:vkCmdWaitEvents 命令that is currently executing
****

include::../validity/protos/vkCmdResetEvent.txt[]

// refBegin vkCmdWaitEvents Wait for one or more events and insert a set of memory

可调用如下命令来在一个设备上等待一个或者多个事件进入激发状态：

[[synchronization-events-waiting-device]]
include::../api/protos/vkCmdWaitEvents.txt[]

  * pname:commandBuffer是命令被记录所在的命令缓冲区。
  * pname:eventCount 是数组pname:pEvents array的长度。
  * pname:pEvents 是需要被等待的事件对象handle的数组。
  * pname:srcStageMask is the <<synchronization-pipeline-stages, 源阶段掩码>>
  * pname:dstStageMask is the <<synchronization-pipeline-stages, 目标阶段掩码>>.
  * pname:memoryBarrierCount is the length of the pname:pMemoryBarriers
    array.
  * pname:pMemoryBarriers is a pointer to一个array of slink:VkMemoryBarrier
    structures.
  * pname:bufferMemoryBarrierCount is the length of the
    pname:pBufferMemoryBarriers array.
  * pname:pBufferMemoryBarriers is a pointer to一个array of
    slink:VkBufferMemoryBarrier structures.
  * pname:imageMemoryBarrierCount is the length of the
    pname:pImageMemoryBarriers array.
  * pname:pImageMemoryBarriers is a pointer to一个array of
    slink:VkImageMemoryBarrier structures.

当 fname:vkCmdWaitEvents 被提交到队列，它在之前的事件激发操作与稍后的命令之间 定义了一个内存依赖。 

The first 同步作用域 only includes event signal operations that
operate on members of pname:pEvents, and the operations that happened-before
the event signal operations.
Event signal operations performed by flink:vkCmdSetEvent that were
previously submitted to the same队列are included in the first
同步作用域, if the <<synchronization-pipeline-stages-order, logically latest>> 管线阶段 in their pname:stageMask parameter is
<<synchronization-pipeline-stages-order, logically earlier>> than or equal
to the <<synchronization-pipeline-stages-order, logically latest>> pipeline
stage in pname:srcStageMask.
Event signal operations performed by flink:vkSetEvent are only included in
the first 同步作用域 if ename:VK_PIPELINE_STAGE_HOST_BIT is
included in pname:srcStageMask.

The second <<synchronization-dependencies-scopes,同步作用域>>
includes commands subsequently submitted to the same queue, including those
in the same 命令缓冲区and batch.
The second 同步作用域 is limited to operations on the 管线
阶段s determined by the <<synchronization-pipeline-stages-masks,
源阶段掩码>> specified by pname:dstStageMask.

The first <<synchronization-dependencies-access-scopes, 访问作用域>> is
limited to access in the 管线阶段 determined by the
<<synchronization-pipeline-stages-masks, 目标阶段掩码>> specified by
pname:srcStageMask.
Within that, the first 访问作用域 only includes the first 访问作用域
defined by elements of the pname:pMemoryBarriers,
pname:pBufferMemoryBarriers and pname:pImageMemoryBarriers arrays, which
each define a set of <<synchronization-memory-barriers, 内存屏障>>.
若no 内存屏障 are specified, then the first 访问作用域 includes no
accesses.

The second <<synchronization-dependencies-access-scopes, 访问作用域>> is
limited to access in the 管线阶段 determined by the
<<synchronization-pipeline-stages-masks, 源阶段掩码>> specified
by pname:dstStageMask.
Within that, the second 访问作用域 only includes the second 访问作用域
defined by elements of the pname:pMemoryBarriers,
pname:pBufferMemoryBarriers and pname:pImageMemoryBarriers arrays, which
each define a set of <<synchronization-memory-barriers, 内存屏障>>.
若no 内存屏障 are specified, then the second 访问作用域 includes
no accesses.

[NOTE]
.注意
====
flink:vkCmdWaitEvents is used with flink:vkCmdSetEvent to define a memory
依赖between two sets of action commands, roughly in the same way as
管线barriers, but split into two commands such that work between the
two may: execute unhindered.
====

[NOTE]
.注意
====
Applications should: be careful to avoid race conditions when using events.
There is no direct ordering guarantee between a flink:vkCmdResetEvent
命令and a flink:vkCmdWaitEvents 命令submitted after it, so some
other 执行依赖must: be included between these commands (e.g. a
semaphore).
====

.正确使用
****
  * pname:srcStageMask must: be the bitwise OR of the pname:stageMask
    parameter used in previous calls to fname:vkCmdSetEvent with any of the
    members of pname:pEvents and ename:VK_PIPELINE_STAGE_HOST_BIT if any of
    the members of pname:pEvents was set using fname:vkSetEvent
  * 若the <<features-features-geometryShader, 几何着色器>> feature is
    not enabled, pname:srcStageMask must: not contain
    ename:VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT
  * 若the <<features-features-geometryShader, 几何着色器>> feature is
    not enabled, pname:dstStageMask must: not contain
    ename:VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT
  * 若the <<features-features-tessellationShader,  细分着色器>>
    feature is not enabled, pname:srcStageMask must: not contain
    ename:VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT or
    ename:VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT
  * 若the <<features-features-tessellationShader, 细分着色器>>
    feature is not enabled, pname:dstStageMask must: not contain
    ename:VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT or
    ename:VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT
  * 若pname:pEvents includes one or more events that will be signaled by
    fname:vkSetEvent after pname:commandBuffer has been submitted to a
    queue, then fname:vkCmdWaitEvents must: not be called inside a render
    pass instance
  * Any 管线阶段 included in pname:srcStageMask or pname:dstStageMask
    must: be supported by the capabilities of the队列族specified by
    the pname:queueFamilyIndex member of the slink:VkCommandPoolCreateInfo
    structure that was used to create the sname:VkCommandPool that
    pname:commandBuffer was allocated from, as specified in the
    <<synchronization-pipeline-stages-supported, table of supported pipeline
    stages>>.
  * Any given element of pname:pMemoryBarriers, pname:pBufferMemoryBarriers
    or pname:pImageMemoryBarriers must: not have any access flag included in
    its pname:srcAccessMask member if that bit is not supported by any of
    the 管线阶段 in pname:srcStageMask, as specified in the
    <<synchronization-access-types-supported, table of supported access
    types>>.
  * Any given element of pname:pMemoryBarriers, pname:pBufferMemoryBarriers
    or pname:pImageMemoryBarriers must: not have any access flag included in
    its pname:dstAccessMask member if that bit is not supported by any of
    the 管线阶段 in pname:dstStageMask, as specified in the
    <<synchronization-access-types-supported, table of supported access
    types>>.
****

include::../validity/protos/vkCmdWaitEvents.txt[]


[[synchronization-pipeline-barriers]]
== 管线屏障

flink:vkCmdPipelineBarrier 是一个同步命令，它在提交到同一个队列的不同命令之间插入一个依赖，或者在同一个subpass内的不同命令之间插入一个依赖。

// refBegin vkCmdPipelineBarrier Insert a内存依赖

可调用如下命令来记录一个管线屏障：

include::../api/protos/vkCmdPipelineBarrier.txt[]

  * pname:commandBuffer 是命令被记录所在的命令缓冲区。
  * pname:srcStageMask 定义了一个 <<synchronization-pipeline-stages-masks, 源阶段掩码>>。
  * pname:dstStageMask 定义了一个 <<synchronization-pipeline-stages-masks, 目标阶段掩码>>。
  * pname:dependencyFlags is a bitmask of elink:VkDependencyFlagBits.
    The bits that can: be included in pname:dependencyFlags are:
+
--
// refBegin VkDependencyFlagBits Bitmask specifying how 执行and内存dependencies are formed
include::../api/enums/VkDependencyFlagBits.txt[]
--
  ** ename:VK_DEPENDENCY_BY_REGION_BIT signifies that dependencies will be
     <<synchronization-framebuffer-regions, framebuffer-local>>.

  * pname:memoryBarrierCount 是数组 pname:pMemoryBarriers的长度。
  * pname:pMemoryBarriers 是一个指针，指向一个slink:VkMemoryBarrier 数据类型的数组。
  * pname:bufferMemoryBarrierCount 是数组 pname:pBufferMemoryBarriers 的长度。
  * pname:pBufferMemoryBarriers 是一个指针，指向一个 slink:VkBufferMemoryBarrier 数据类型的数组。
  * pname:imageMemoryBarrierCount 是数组 pname:pImageMemoryBarriers 的长度。
  * pname:pImageMemoryBarriers 是一个指针，指向一个slink:VkImageMemoryBarrier 数据类型的数组。

当 flink:vkCmdPipelineBarrier 被提交到队列，它在命令被提交到队列之前与之后的命令之间 定义了一个内存依赖。

若flink:vkCmdPipelineBarrier was recorded outside a render pass instance,
the first <<synchronization-dependencies-scopes, 同步作用域>>
includes every 命令submitted to the same队列before it, including
those in the same 命令缓冲区and batch.
若flink:vkCmdPipelineBarrier was recorded inside a render pass instance,
the first 同步作用域 includes only commands submitted before it
within the same subpass.
In either case, the first 同步作用域 is limited to operations on
the 管线阶段 determined by the
<<synchronization-pipeline-stages-masks, 目标阶段掩码>> specified by
pname:srcStageMask.

若flink:vkCmdPipelineBarrier was recorded outside a render pass instance,
the second <<synchronization-dependencies-scopes, 同步作用域>>
includes every 命令submitted to the same队列after it, including those
in the same 命令缓冲区and batch.
若flink:vkCmdPipelineBarrier was recorded inside a render pass instance,
the second 同步作用域 includes only commands submitted after it
within the same subpass.
In either case, the second 同步作用域 is limited to operations on
the 管线阶段 determined by the
<<synchronization-pipeline-stages-masks, 源阶段掩码>> specified
by pname:dstStageMask.

The first <<synchronization-dependencies-access-scopes, 访问作用域>> is
limited to access in the 管线阶段 determined by the
<<synchronization-pipeline-stages-masks, 目标阶段掩码>> specified by
pname:srcStageMask.
Within that, the first 访问作用域 only includes the first 访问作用域
defined by elements of the pname:pMemoryBarriers,
pname:pBufferMemoryBarriers and pname:pImageMemoryBarriers arrays, which
each define a set of <<synchronization-memory-barriers, 内存屏障>>.
若no 内存屏障 are specified, then the first 访问作用域 includes no
accesses.

The second <<synchronization-dependencies-access-scopes, 访问作用域>> is
limited to access in the 管线阶段 determined by the
<<synchronization-pipeline-stages-masks, 源阶段掩码>> specified
by pname:dstStageMask.
Within that, the second 访问作用域 only includes the second 访问作用域s
defined by elements of the pname:pMemoryBarriers,
pname:pBufferMemoryBarriers and pname:pImageMemoryBarriers arrays, which
each define a set of <<synchronization-memory-barriers, 内存屏障>>.
若no 内存屏障 are specified, then the second 访问作用域 includes
no accesses.

若pname:dependencyFlags includes ename:VK_DEPENDENCY_BY_REGION_BIT, then
any 依赖between <<synchronization-framebuffer-regions,
framebuffer-space>> 管线阶段 is
<<synchronization-framebuffer-regions, framebuffer-local>> - otherwise it is
<<synchronization-framebuffer-regions, framebuffer-global>>.

.正确使用
****
  * 若  <<features-features-geometryShader, 几何着色器>> 特性没有被启用，pname:srcStageMask 必须: 不能包含 ename:VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT
  * 若 <<features-features-geometryShader,几何着色器>> 特性没有被启用， pname:dstStageMask 必须: 不能包含 ename:VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT
  * 若 <<features-features-tessellationShader,  细分着色器>> 特性没有被启用，pname:srcStageMask必须: 不能包含 ename:VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT或者
    ename:VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT
  * 若 <<features-features-tessellationShader,  细分着色器>>特性没有被启用，pname:dstStageMask 必须: 不能包含 ename:VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT 或者
    ename:VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT
  * 若 fname:vkCmdPipelineBarrier 在一个render pass实例内被调用， 此 render pass 在创建时必须: 与当前subpass自身存在一个 sname:VkSubpassDependency 
    另外:
  ** pname:srcStageMask must: contain a subset of the bit values in the
     pname:srcStageMask member of that instance of sname:VkSubpassDependency
  ** pname:dstStageMask must: contain a subset of the bit values in the
     pname:dstStageMask member of that instance of sname:VkSubpassDependency
  ** The pname:srcAccessMask of any element of pname:pMemoryBarriers or
     pname:pImageMemoryBarriers must: contain a subset of the bit values the
     pname:srcAccessMask member of that instance of
     sname:VkSubpassDependency
  ** The pname:dstAccessMask of any element of pname:pMemoryBarriers or
     pname:pImageMemoryBarriers must: contain a subset of the bit values the
     pname:dstAccessMask member of that instance of
     sname:VkSubpassDependency
  ** pname:dependencyFlags must: be equal to the pname:dependencyFlags
     member of that instance of sname:VkSubpassDependency
  * 若fname:vkCmdPipelineBarrier is called within a render pass instance,
    pname:bufferMemoryBarrierCount must: be `0`
  * 若fname:vkCmdPipelineBarrier is called within a render pass instance,
    the pname:image member of any element of pname:pImageMemoryBarriers
    must: be equal to one of the elements of pname:pAttachments that the
    current pname:framebuffer was created with, that is also referred to by
    one of the elements of the pname:pColorAttachments,
    pname:pResolveAttachments or pname:pDepthStencilAttachment members of
    the sname:VkSubpassDescription instance that the current subpass was
    created with
  * 若fname:vkCmdPipelineBarrier is called within a render pass instance,
    the pname:oldLayout and pname:newLayout members of any element of
    pname:pImageMemoryBarriers must: be equal to the pname:layout member of
   一个element of the pname:pColorAttachments, pname:pResolveAttachments or
    pname:pDepthStencilAttachment members of the sname:VkSubpassDescription
    instance that the current subpass was created with, that refers to the
    same pname:image
  * 若fname:vkCmdPipelineBarrier is called within a render pass instance,
    the pname:oldLayout and pname:newLayout members of一个element of
    pname:pImageMemoryBarriers must: be equal
  * 若fname:vkCmdPipelineBarrier is called within a render pass instance,
    the pname:srcQueueFamilyIndex and pname:dstQueueFamilyIndex members of
    any element of pname:pImageMemoryBarriers must: be
    ename:VK_QUEUE_FAMILY_IGNORED
  * Any 管线 stage included in pname:srcStageMask or pname:dstStageMask
    must: be supported by the capabilities of the队列族specified by
    the pname:queueFamilyIndex member of the slink:VkCommandPoolCreateInfo
    structure that was used to create the sname:VkCommandPool that
    pname:commandBuffer was allocated from, as specified in the
    <<synchronization-pipeline-stages-supported, table of supported pipeline
    stages>>.
  * Any given element of pname:pMemoryBarriers, pname:pBufferMemoryBarriers
    or pname:pImageMemoryBarriers must: not have any access flag included in
    its pname:srcAccessMask member if that bit is not supported by any of
    the 管线阶段 in pname:srcStageMask, as specified in the
    <<synchronization-access-types-supported, table of supported access
    types>>.
  * Any given element of pname:pMemoryBarriers, pname:pBufferMemoryBarriers
    or pname:pImageMemoryBarriers must: not have any access flag included in
    its pname:dstAccessMask member if that bit is not supported by any of
    the 管线阶段 in pname:dstStageMask, as specified in the
    <<synchronization-access-types-supported, table of supported access
    types>>.
****

include::../validity/protos/vkCmdPipelineBarrier.txt[]


[[synchronization-pipeline-barriers-subpass-self-dependencies]]
=== Subpass Self-dependency

若fname:vkCmdPipelineBarrier is called inside a render pass instance, the
following restrictions apply.
For a given subpass to allow a 管线 barrier, the render pass must:
declare a _self-dependency_ from that subpass to itself.
That is, there must: exist a sname:VkSubpassDependency in the subpass
依赖list for the render pass with pname:srcSubpass and
pname:dstSubpass equal to that subpass index.
More than one self-依赖can: be declared for each subpass.
Self-dependencies must: only include 管线 stage bits that are graphics
stages.
Self-dependencies must: not have any earlier 管线阶段 depend on any
later 管线阶段.
更准确来说，这意味着pname:srcStageMask 的最后一个管线阶段，不能在pname:dstStageMask 的第一个管线阶段之后（）。 this means that whatever is the last 管线stage in
pname:srcStageMask must: be no later than whatever is the first pipeline
stage in pname:dstStageMask (the latest source stage can: be equal to the
earliest 目标 stage).
若the source and 源阶段掩码s both include framebuffer-space
stages, then pname:dependencyFlags must: include
ename:VK_DEPENDENCY_BY_REGION_BIT.

A fname:vkCmdPipelineBarrier 命令inside a render pass instance must: be
a _subset_ of one of the self-dependencies of the subpass it is used in,
meaning that the阶段掩码s and 访问掩码 must: each include only a
subset of the bits of the corresponding mask in that self-dependency.
若the self-依赖has ename:VK_DEPENDENCY_BY_REGION_BIT set, then so
must: the 管线barrier.
管线barriers within a render pass instance can: only be types
sname:VkMemoryBarrier or sname:VkImageMemoryBarrier.
若a sname:VkImageMemoryBarrier is used, the图像and图像subresource
range specified in the barrier must: be a subset of one of the图像views
used by the framebuffer in the current subpass.
Additionally, pname:oldLayout must: be equal to pname:newLayout, and both
the pname:srcQueueFamilyIndex and pname:dstQueueFamilyIndex must: be
ename:VK_QUEUE_FAMILY_IGNORED.


[[synchronization-memory-barriers]]
== 内存屏障

_Memory barriers_ are used to explicitly control access to缓冲区and image
子资源ranges.
内存屏障用来 <<synchronization-queue-transfers,  在队列族之间转移所有权>>,
<<synchronization-image-layout-transitions, 改变 图像布局>>, 和 定义<<synchronization-dependencies-available-and-visible, 可用性与可见性操作>>。
它们显式的定义了<<synchronization-access-types, 访问类型>>和 包含在 包含它们的同步命令所创建的 内存依赖的
<<synchronization-dependencies-access-scopes, 访问作用域>>的缓冲区、图像子资源区间。

[[synchronization-global-memory-barriers]]
=== 全局内存屏障

全局内存屏障可应用于涉及到执行时所有内存对象的内存访问。

// refBegin VkMemoryBarrier Structure specifying a global 内存屏障

sname:VkMemoryBarrier 类型数据结构定义如下：

include::../api/structs/VkMemoryBarrier.txt[]

  * pname:sType 是数据结构的类型。
  * pname:pNext 是 `NULL` 或者一个指向拓展特定的数据结构的指针。
  * pname:srcAccessMask 定义了一个 <<synchronization-access-masks, 源访问掩码>>.
  * pname:dstAccessMask 定义了一个<<synchronization-access-masks, 目标访问掩码>>.

第一 <<synchronization-dependencies-access-scopes, 访问作用域>> 受pname:srcAccessMask指定的<<synchronization-access-masks, 源访问掩码>> 中的访问类型 限制。

第二<<synchronization-dependencies-access-scopes, 访问作用域>> 受 pname:dstAccessMask指定的<<synchronization-access-masks, 目标访问掩码>>
中的访问类型限制。

include::../validity/structs/VkMemoryBarrier.txt[]



[[synchronization-buffer-memory-barriers]]
=== 缓冲区内存屏障

缓冲区内存屏障 只应用于涉及到特定缓冲区区间内存访问。亦即，一个由缓冲区内存屏障 形成的内存依赖， 被<<synchronization-dependencies-access-scopes, 限定(scoped)>>
访问特定的缓冲区区间。
缓冲区内存屏障 也可以: 用于为特定的缓冲区区间 定义一个<<synchronization-queue-transfers, 队列族所有权转移>> 。

// refBegin VkBufferMemoryBarrier Structure specifying a缓冲区内存屏障

sname:VkBufferMemoryBarrier 类型数据结构定义如下：

include::../api/structs/VkBufferMemoryBarrier.txt[]

  * pname:sType 是数据结构的类型。
  * pname:pNext 是 `NULL` 或者一个指向拓展特定的数据结构的指针。
  * pname:srcAccessMask 定义了一个 <<synchronization-access-masks, 源访问掩码>>.
  * pname:dstAccessMask 定义了一个<<synchronization-access-masks, 目标访问掩码>>.
  * pname:srcQueueFamilyIndex 是<<synchronization-queue-transfers, 队列族所有权转移>>的源队列族。
  * pname:dstQueueFamilyIndex 是<<synchronization-queue-transfers, 队列族所有权转移>>的目标队列族。
  * pname:buffer 是 所占内存被屏障所影响的 缓冲区的handle。
  * pname:offset 是 pname:buffer所占内存的offset字节数；这是与绑定到缓冲区基础offset的相对值。 (参考 flink:vkBindBufferMemory).
  * pname:size 是pname:buffer所占内存 受影响区域的字节数，或者值为ename:VK_WHOLE_SIZE，表示使用pname:offset 到缓冲区结束的所有区间。

第一<<synchronization-dependencies-access-scopes, 访问作用域>> 被 pname:srcAccessMask指定的<<synchronization-access-masks, 源访问掩码>>中的 访问类型
限制只能通过指定的缓冲区区间访问内存。
若pname:srcAccessMask 包含 ename:VK_ACCESS_HOST_WRITE_BIT，由该访问类型操作的内存写入结果也是可见的，如同该访问类型没有通过资源进行操作。

The second <<synchronization-dependencies-access-scopes, 访问作用域>> is
limited to access to内存through the specified缓冲区range, via access
types in the <<synchronization-access-masks, 目标访问掩码>>
specified by pname:dstAccessMask.
若pname:dstAccessMask includes ename:VK_ACCESS_HOST_WRITE_BIT or
ename:VK_ACCESS_HOST_READ_BIT, available内存writes are also made visible
to 访问of those types, as those 访问类型 are not performed through
a resource.

若pname:srcQueueFamilyIndex is not equal to pname:dstQueueFamilyIndex, and
pname:srcQueueFamilyIndex is equal to the current 队列族, then the
内存屏障 defines a <<synchronization-queue-transfers-release, 队列组释放操作>> for the specified缓冲区range, and the second
访问作用域 includes no access, as if pname:dstAccessMask was `0`.

若pname:dstQueueFamilyIndex is not equal to pname:srcQueueFamilyIndex, and
pname:dstQueueFamilyIndex is equal to the current 队列族, then the
内存屏障 defines a <<synchronization-queue-transfers-acquire, queue
family acquire operation>> for the specified缓冲区range, and the first
访问作用域 includes no access, as if pname:srcAccessMask was `0`.

.正确使用
****
  * pname:offset must: be less than the size of pname:buffer
  * 若pname:size is not equal to ename:VK_WHOLE_SIZE, pname:size must: be
    greater than `0`
  * 若pname:size is not equal to ename:VK_WHOLE_SIZE, pname:size must: be
    less than or equal to than the size of pname:buffer minus pname:offset
  * 若pname:buffer was created with a sharing mode of
    ename:VK_SHARING_MODE_CONCURRENT, pname:srcQueueFamilyIndex and
    pname:dstQueueFamilyIndex must: both be ename:VK_QUEUE_FAMILY_IGNORED
  * 若pname:buffer was created with a sharing mode of
    ename:VK_SHARING_MODE_EXCLUSIVE, pname:srcQueueFamilyIndex and
    pname:dstQueueFamilyIndex must: either both be
    ename:VK_QUEUE_FAMILY_IGNORED, or both be a valid队列族(see
    <<devsandqueues-queueprops>>)
  * 若pname:buffer was created with a sharing mode of
    ename:VK_SHARING_MODE_EXCLUSIVE, and pname:srcQueueFamilyIndex and
    pname:dstQueueFamilyIndex are valid队列families, at least one of them
    must: be the same as the family of the队列that will execute this
    barrier
****

include::../validity/structs/VkBufferMemoryBarrier.txt[]


[[synchronization-image-memory-barriers]]
=== 图像内存屏障

图像内存屏障 only apply to内存访问involving a specific
image 子资源range.
That is, a内存依赖formed from an图像内存屏障 is
<<synchronization-dependencies-access-scopes, scoped>> to access via the
specified图像子资源range.
图像内存屏障 can: also be used to define
<<synchronization-image-layout-transitions, 图像布局转换s>> or a
<<synchronization-queue-transfers, 队列族所有权转移>> for the
specified图像子资源range.

// refBegin VkImageMemoryBarrier Structure specifying the parameters of an图像内存屏障

sname:VkImageMemoryBarrier 类型数据结构定义如下：

include::../api/structs/VkImageMemoryBarrier.txt[]

  * pname:sType 是数据结构的类型。
  * pname:pNext 是 `NULL` 或者一个指向拓展特定的数据结构的指针。
  * pname:srcAccessMask  定义了一个 <<synchronization-access-masks, 源访问掩码>>.
  * pname:dstAccessMask  定义了一个<<synchronization-access-masks, 目标访问掩码>>.
  * pname:oldLayout is the old 布局in an
    <<synchronization-image-layout-transitions, 图像布局转换>>.
  * pname:newLayout is the new 布局in an
    <<synchronization-image-layout-transitions, 图像布局转换>>.
  * pname:srcQueueFamilyIndex is the source队列族for a
    <<synchronization-queue-transfers, 队列族所有权转移>>.
  * pname:dstQueueFamilyIndex is the 目标队列族for a
    <<synchronization-queue-transfers, 队列族所有权转移>>.
  * pname:image is a handle to the图像affected by this barrier.
  * pname:subresourceRange describes the <<resources-image-views, image
    子资源range>> within pname:image that is affected by this barrier.

The first <<synchronization-dependencies-access-scopes, 访问作用域>> is
limited to access to内存through the specified图像子资源range,
via 访问类型 in the <<synchronization-access-masks, 源访问掩码>>
specified by pname:srcAccessMask.
若pname:srcAccessMask includes ename:VK_ACCESS_HOST_WRITE_BIT, memory
writes performed by that access type are also made visible, as that access
type is not performed through a resource.

第二<<synchronization-dependencies-access-scopes, 访问作用域>> 被限制只能通过特定的图像子资源范围来 访问内存，
由通过pname:dstAccessMask指定的<<synchronization-access-masks, 目标访问掩码>>中的 访问类型。
若pname:dstAccessMask includes ename:VK_ACCESS_HOST_WRITE_BIT or
ename:VK_ACCESS_HOST_READ_BIT, available内存writes are also made visible
to accesses of those types, as those 访问类型 are not performed through
a resource.

若pname:srcQueueFamilyIndex is not equal to pname:dstQueueFamilyIndex, and
pname:srcQueueFamilyIndex is equal to the current 队列族, then the
内存屏障 defines a <<synchronization-queue-transfers-release, 队列族 release operation>> for the specified图像子资源range, and
the second 访问作用域 includes no access, as if pname:dstAccessMask was
`0`.

若pname:dstQueueFamilyIndex is not equal to pname:srcQueueFamilyIndex, and
pname:dstQueueFamilyIndex is equal to the current 队列族, then the
内存屏障 defines a <<synchronization-queue-transfers-acquire, queue
family acquire operation>> for the specified图像子资源range, and
the first 访问作用域 includes no access, as if pname:srcAccessMask was
`0`.

若pname:oldLayout is not equal to pname:newLayout, then the 内存屏障
defines一个<<synchronization-image-layout-transitions, 图像布局转换>> for the specified图像子资源range.

[[synchronization-image-barrier-layout-transition-order]]
Layout transitions that are performed via图像内存屏障 execute in
their entirety in <<synchronization-submission-order, 提交顺序>>,
relative to other 图像布局转换s submitted to the same queue,
including those performed by <<renderpass, render passes>>.
In effect there is一个implicit 执行依赖from each such layout
transition to all 布局transitions previously submitted to the same queue.

.正确使用
****
  * pname:oldLayout must: be ename:VK_IMAGE_LAYOUT_UNDEFINED or the current
    布局of the图像subresources affected by the barrier
  * pname:newLayout must: not be ename:VK_IMAGE_LAYOUT_UNDEFINED or
    ename:VK_IMAGE_LAYOUT_PREINITIALIZED
  * 若pname:image was created with a sharing mode of
    ename:VK_SHARING_MODE_CONCURRENT, pname:srcQueueFamilyIndex and
    pname:dstQueueFamilyIndex must: both be ename:VK_QUEUE_FAMILY_IGNORED
  * 若pname:image was created with a sharing mode of
    ename:VK_SHARING_MODE_EXCLUSIVE, pname:srcQueueFamilyIndex and
    pname:dstQueueFamilyIndex must: either both be
    ename:VK_QUEUE_FAMILY_IGNORED, or both be a valid队列族(see
    <<devsandqueues-queueprops>>)
  * 若pname:image was created with a sharing mode of
    ename:VK_SHARING_MODE_EXCLUSIVE, and pname:srcQueueFamilyIndex and
    pname:dstQueueFamilyIndex are valid队列families, at least one of them
    must: be the same as the family of the队列that will execute this
    barrier
  * pname:subresourceRange must: be a valid图像子资源range for the
   图像(see <<resources-image-views>>)
  * 若pname:image has a depth/stencil format with both depth and stencil
    components, then pname:aspectMask member of pname:subresourceRange must:
    include both ename:VK_IMAGE_ASPECT_DEPTH_BIT and
    ename:VK_IMAGE_ASPECT_STENCIL_BIT
  * 若either pname:oldLayout or pname:newLayout is
    ename:VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL then pname:image must:
    have been created with ename:VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT set
  * 若either pname:oldLayout or pname:newLayout is
    ename:VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL then pname:image
    must: have been created with
    ename:VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT set
  * 若either pname:oldLayout or pname:newLayout is
    ename:VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL then pname:image
    must: have been created with
    ename:VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT set
  * 若either pname:oldLayout or pname:newLayout is
    ename:VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL then pname:image must:
    have been created with ename:VK_IMAGE_USAGE_SAMPLED_BIT or
    ename:VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT set
  * 若either pname:oldLayout or pname:newLayout is
    ename:VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL then pname:image must: have
    been created with ename:VK_IMAGE_USAGE_TRANSFER_SRC_BIT set
  * 若either pname:oldLayout or pname:newLayout is
    ename:VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL then pname:image must: have
    been created with ename:VK_IMAGE_USAGE_TRANSFER_DST_BIT set
****

include::../validity/structs/VkImageMemoryBarrier.txt[]


[[synchronization-queue-transfers]]
=== 队列族主权转移

Resources created with a elink:VkSharingMode of
ename:VK_SHARING_MODE_EXCLUSIVE must: have their ownership explicitly
transferred from one队列族to another in order to access their
content in a well-defined manner on a队列in a different 队列族.
If内存dependencies are correctly expressed between uses of such a
resource between two queues in different families, but no ownership transfer
is defined, the contents of that resource are undefined for any read
accesses performed by the second 队列族.

.注意
[NOTE]
====
若an application does not need the contents of a resource to remain valid
when transferring from one队列族to another, then the ownership
transfer should: be skipped.
====

A 队列族所有权转移 consists of two distinct parts:

  . Release exclusive ownership from the source 队列族
  . Acquire exclusive ownership for the 目标 队列族

An application must: ensure that these operations occur in the correct order
by defining一个执行依赖between them, e.g. using a semaphore.

[[synchronization-queue-transfers-release]] A _release operation_ is used to
release exclusive ownership of a range of a缓冲区or图像subresource
range.
一个释放操作is defined by executing a
<<synchronization-buffer-memory-barriers, 缓冲区内存屏障>> (for a
buffer range) or一个<<synchronization-image-memory-barriers,图像memory
barrier>> (for an图像子资源range), on a队列from the source queue
family.
The pname:srcQueueFamilyIndex parameter of the barrier must: be set to the
source队列族index, and the pname:dstQueueFamilyIndex parameter to
the 目标队列族index.
pname:dstStageMask is ignored for such a barrier, such that no visibility
operation is executed - the value of this mask does not affect the validity
of the barrier.
释放操作在可用性操作之后发生。

[[synchronization-queue-transfers-acquire]]一个_acquire operation_ is used
to acquire exclusive ownership of a range of a缓冲区or图像subresource
range.
一个获取操作通过 在目标队列族的一个队列上执行一个 
<<synchronization-buffer-memory-barriers,缓冲区内存屏障>> (for a
buffer range) 或者一个<<synchronization-image-memory-barriers,图像内存屏障>> (for an图像子资源range)来定义。
The pname:srcQueueFamilyIndex parameter of the barrier must: be set to the
source队列族index, and the pname:dstQueueFamilyIndex parameter to
the 目标队列族index.
pname:srcStageMask is ignored for such a barrier, such that no availability
operation is executed - the value of this mask does not affect the validity
of the barrier.
The acquire操作happens-before the visibility operation.

.注意
[NOTE]
====
Whilst it is not invalid to provide 目标 or 源访问掩码 for
内存屏障 used for release or acquire operations, respectively, they
have no practical effect.
Access after a release操作has undefined results, and so visibility
for those accesses has no practical effect.
Similarly, write access before一个acquire操作will produce undefined
results for future access, so availability of those writes has no practical
use.
In一个earlier version of the specification, these were required to match on
both sides - but this was subsequently relaxed.
It is now recommended that these masks are simply set to 0.
====

若the transfer is via an图像内存屏障, and an
<<synchronization-image-layout-transitions, 图像布局转换>> is
desired, then the values of pname:oldLayout and pname:newLayout in the
release 内存屏障 must: be equal to values of pname:oldLayout and
pname:newLayout in the acquire 内存屏障.
Although the 图像布局转换 is submitted twice, it will only be
executed once.
A 布局transition specified in this way happens-after the release
operation and happens-before the acquire operation.

若the values of pname:srcQueueFamilyIndex and pname:dstQueueFamilyIndex are
equal, no ownership transfer is performed, and the barrier operates as if
they were both set to ename:VK_QUEUE_FAMILY_IGNORED.

队列族所有权转移s may: perform read and write accesses on all
memory bound to the图像子资源or缓冲区range, so applications must:
ensure that all内存writes have been made
<<synchronization-dependencies-available-and-visible, available>> before a
队列族所有权转移 is executed.
Available内存is automatically made visible to队列族release and
acquire operations, and writes performed by those operations are
automatically made available.

一旦一个队列族已经获取到一个缓冲区区间或者图像ename:VK_SHARING_MODE_EXCLUSIVE 子资源区间的所有权，那么它的内容对于其他队列族就是未定义的，除非所有权发生转移。

The contents of any portion of another resource which aliases内存that is
bound to the transferred缓冲区or图像子资源range are undefined
after a release or acquire operation.


[[synchronization-wait-idle]]
== 等待空闲操作

// refBegin vkQueueWaitIdle Wait for a队列to become idle

在Host端等待 一个指定队列 未完成的队列操作的执行完成，需要调用：

include::../api/protos/vkQueueWaitIdle.txt[]

  * pname:queue 是等待行为所在的队列。

fname:vkQueueWaitIdle is equivalent to submitting a fence to a队列and
waiting with一个infinite timeout for that fence to signal.

include::../validity/protos/vkQueueWaitIdle.txt[]

// refBegin vkDeviceWaitIdle Wait for a设备to become idle

在host端等待 for the 未执行的队列操作的执行 一个给定的 逻辑设备上所有的队列, call:

include::../api/protos/vkDeviceWaitIdle.txt[]

  * pname:device 是需要闲置的逻辑设备。

对于pname:device所拥有的所有队列， fname:vkDeviceWaitIdle 与调用calling fname:vkQueueWaitIdle等同。

include::../validity/protos/vkDeviceWaitIdle.txt[]


[[synchronization-submission-host-writes]]
== CPU端写入顺序保证

命令缓冲区的批量任务通过flink:vkQueueSubmit被提交到 队列，它定义了一个与之前的host操作关联的内存依赖，且 被提交到队列的命令缓冲区的执行。

第一个<<synchronization-dependencies-scopes, 同步作用域>> 是 host端 执行模型定义的，但包含 
在host端的flink:vkQueueSubmit 的执行、在此之前发生的任何执行。

第二个<<synchronization-dependencies-scopes, 同步作用域>>包含每一个 被提交到同一个<<devsandqueues-submission,队列提交>>命令
，和未来提交到同一个队列上的命令。

第一个<<synchronization-dependencies-access-scopes, 访问作用域>>包含所有的host端写入到可映射设备内存，该内存要么是一致的，
或者被 flink:vkFlushMappedMemoryRanges所刷新。


第二个 <<synchronization-dependencies-access-scopes, 访问作用域>>
包含所有的由设备执行访问的内存。
