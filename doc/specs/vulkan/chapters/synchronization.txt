// Copyright (c) 2015-2017 The Khronos Group Inc.
// Copyright notice at https://www.khronos.org/registry/speccopyright.html

[[synchronization]]
= 同步与缓存控制

对资源的访问同步是Vulkan应用程序的主要职责。主机端的命令和设备端的其他命令的执行顺序只有少数几个隐式的保证，需要显式的指定。
内存缓存和其他优化也需要显式的管理，要求数据流在应用程序的控制之下。

尽管在不同的命令之间有一些隐式的保证，在Vulkan中提供了四种显示的同步原语：

<<synchronization-fences,栅栏>>::
	栅栏可以用来和主机端交流设备端的任务已经执行完成。

<<synchronization-semaphores,信号量>>::
	信号量可以用来控制多个队列对资源的访问。

<<synchronization-events,事件>>::
	事件提供了精细粒度的同步原语，可以在命令缓冲区之内或者被主机端激发，可以在命令缓冲区内等待或者主机端被查询。

<<synchronization-pipeline-barriers,管线屏障>>::
	管线屏障也在命令缓冲区内提供了同步控制，但是只是单点的，而非可分离激发和等待操作。

除了这里的基本的原语， 在本章的概念上，<<renderpass, Render Passes>> 为大多数渲染任务提供了同步框架。
本章中很多需要应用程序来同步原语的情况，可以被render pass更加高效的表达出来。


[[synchronization-dependencies]]
== 执行与内存依赖

一个 _操作_ 是主机端、设备端或者外部入口如展示引擎等之上任意数量的工作。
同步命令引入了显式的 _执行依赖_，_内存依赖_，有命令的两个_synchronization scopes_ 定义的两个操作集合之间的 _memory dependencies_ 。


[[synchronization-dependencies-scopes]]
同步范围定义了哪些其他的同步命令可以创建执行依赖。
不再同步命令的同步范围内的任何类型的操作将不被包含进入生成的依赖之中。
例如，对于很多同步命令来说，同步范围可以被限制到只执行特定<<synchronization-pipeline-stages,pipeline stages>>的操作上，这允许其他的管线阶段被排除在依赖之外。
其他的范围选项也是可行的，依赖于特定的命令。

[[synchronization-dependencies-execution]]
_执行依赖_ 保证了两个集合的操作其中的一个一定在另外一个之前发生。
如果一个操作在另外一个操作之前发生了，那么第一个操作一定会在第二个操作初始化之前完成。
更准确的表述是：

  * 假定 *A* and *B* 是相互独立的操作集合
  * 假定 *S* 是同步命令
  * 假定 *A~S~* 和 *B~S~* 是 *S* 的同步范围.
  * 假定 *A'* 是集合 *A* 与 *A~S~* 的交集
  * 假定 *B'* 是集合 *B* 与 *B~S~*的交集
  * 提交 *A*, *S* and *B* 来按照顺序执行，将导致在 *A'* 和 *B'* 产程一个执行依赖    
  * 执行依赖 *E* 保证 *A'* 在*B'* 之前发生

[[synchronization-dependencies-chains]]
一个 _execution dependency chain_ 是一系列的执行依赖，形成了第一个依赖的 *A'*  与最后一个依赖的 *B'* 之间的 “先行发生”的关系。
对于每一对连续的执行依赖，如果 第一个依赖中*B~S~* 与第二个依赖中*A~S~*的交集不是空集，那么就存在一个依赖链。
The formation of a single execution dependency from an execution dependency
chain can be described by substituting the following in the description of
execution dependencies:

  * Let *S* be a set of synchronization commands that generate an execution
    dependency chain.
  * Let *A~S~* be the first synchronization scope of the first command in
    *S*.
  * Let *B~S~* be the second synchronization scope of the last command in
    *S*.

.注意
[NOTE]
====
An execution dependency is inherently also multiple execution dependencies -
a dependency exists between each subset of *A'* and each subset of *B'*, and
the same is true for execution dependency chains.
For example, a synchronization command with multiple
<<synchronization-pipeline-stages,pipeline stages>> in its stage masks
effectively generates one dependency between each source stage and each
destination stage.
This can be useful to think about when considering how execution chains are
formed if they do not involve all parts of a synchronization command's
dependency.
Similarly, any set of adjacent dependencies in an execution dependency chain
can: be considered an execution dependency chain in its own right.
====

单单就执行顺序无法保证其他操作集写入的结果可以被另一个操作集读取。
 

[[synchronization-dependencies-available-and-visible]]
附加操作的两个类型是用来控制内存访问的。
_Availability operations_ cause the values generated by specified memory
write accesses to become _available_ for future access.
Any available value remains available until a subsequent write to the same
memory location occurs (whether it is made available or not) or the memory
is freed.
_Visibility operations_ cause any available values to become _visible_ to
specified memory accesses.

[[synchronization-dependencies-memory]]
A _memory dependency_ is an execution dependency which includes availability
and visibility operations such that:

  * The first set of operations happens-before the availability operation.
  * The availability operation happens-before the visibility operation.
  * The visibility operation happens-before the second set of operations.

Once written values are made visible to a particular type of memory access,
they can: be read or written by that type of memory access.
Most synchronization commands in Vulkan define a memory dependency.

[[synchronization-dependencies-access-scopes]]
The specific memory accesses that are made available and visible are defined
by the _access scopes_ of a memory dependency.
Any type of access that is in a memory dependency's first access scope and
occurs in *A'* is made available.
Any type of access that is in a memory dependency's second access scope and
occurs in *B'* has any available writes made visible to it.
Any type of operation that is not in a synchronization command's access
scopes will not be included in the resulting dependency.

A memory dependency enforces availability and visibility of memory accesses
and execution order between two sets of operations.
Adding to the description of <<synchronization-dependencies-chains,
execution dependency chains>>:

  * Let *a* be the set of memory accesses performed by *A'*.
  * Let *b* be the set of memory accesses performed by *B'*.
  * Let *a~S~* be the first access scope of the first command in *S*.
  * Let *b~S~* be the second access scope of the last command in *S*.
  * Let *a'* be the intersection of sets *a* and *a~S~*.
  * Let *b'* be the intersection of sets *b* and *b~S~*.
  * Submitting *A*, *S* and *B* for execution, in that order, will result in
    a memory dependency *m* between *A'* and *B'*.
  * Memory dependency *m* guarantees that:
  ** Memory writes in *a'* are made available.
  ** Available memory writes, including those from *a'*, are made visible to
     *b'*.

[NOTE]
.注意
====
执行与内存依赖是用来解决数据危害的，亦即，保证读写操作依良好定义的顺序执行。
“读后写”的数据错误可以被执行依赖解决，但是“写后读”与“写后写”数据错误需要内存操作之间有合适的内存依赖。
若应用程序并不包含依赖以解决这些数据危害问题，那么内存访问的执行顺序与结果是未定义的。
====


[[synchronization-image-layout-transitions]]
=== 图像布局转换
图形子资源可以从一个 <<resources-image-layouts,布局>> 到另外一个，作为 <<synchronization-dependencies-memory,内存依赖>>的一部分。 (e.g. by using an
<<synchronization-image-memory-barriers,image memory barrier>>).
当内存依赖指定了一个布局转换，在内存依赖中它发生在availability操作之后，发生在visibility操作之前。
图像布局转换操作可以对绑定到图像子资源范围的所有内存执行读、写，故应用程序必须保证所有的内存写入结果需要在布局转换被执行之前
<<synchronization-dependencies-available-and-visible, 变为可用>>。
可用的内存对布局转换自动可见，且布局转换写入的内存也是自动变为可用。

布局转换总是应用到图像子资源的特定范围，且指定老的布局和新的布局。
若老的布局与新布局并不匹配，转换可以发生。老布局必须与图像子资源范围的当前布局匹配，除了一个例外。
老布局可以被指定为 ename:VK_IMAGE_LAYOUT_UNDEFINED，即便做如此操作会导致图像子资源范围的内容变得无效。


.注意
[NOTE]
====
设定老的布局为 ename:VK_IMAGE_LAYOUT_UNDEFINED 暗示着图像子资源的内容不需要被保留。
Vulkan驱动实现可能使用这信息以避免昂贵的数据转换操作。
====

.注意
[NOTE]
====
Applications must: ensure that layout transitions happen-after all
operations accessing the image with the old layout, and happen-before any
operations that will access the image with the new layout.
Layout transitions are potentially read/write operations, so not defining
appropriate memory dependencies to guarantee this will result in a data
race.
====

在一次图像布局转换之后，共享绑定到转换之后的图像子资源范围的内存的 其他的资源，它们的任何部分内存内容都都可能是未定义的。


[[synchronization-pipeline-stages]]
=== 管线阶段

<<fundamentals-queueoperation-command-types, action command>> 执行的计算由多个操作组成。这些操作由一些被称作“管线阶段”的逻辑独立执行单元执行。
被执行的管线阶段依赖于被使用的 action command，和action  command被记录所在的当前的命令缓冲区阶段。
<<drawing,Drawing commands>>, <<dispatch,dispatching commands>>,
<<copies,copy commands>>, 和 <<clears,clear commands>> 都在不同的  <<synchronization-pipeline-stages-types,pipeline stages>>集合中被执行。

跨管线阶段的操作的执行必须参照于<<synchronization-implicit, implicit ordering guarantees>>，特别是包含 <<synchronization-pipeline-stages-order, 管线阶段排序>>。
否则，跨管线阶段执行可能会互相重叠，或者乱序，除非通过执行依赖来强制保证。

// refBegin VkPipelineStageFlagBits - Bitmask specifying pipeline stages

Several of the synchronization commands include pipeline stage parameters,
restricting the <<synchronization-dependencies-scopes, synchronization
scopes>> for that command to just those stages.
This allows fine grained control over the exact execution dependencies and
accesses performed by action commands.
Implementations should: use these pipeline stages to avoid unnecessary
stalls or cache flushing.

Pipeline stages are specified using a bitmask:

include::../api/enums/VkPipelineStageFlagBits.txt[]

每一个bit的含义如下：

  * ename:VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT: Stage of the pipeline where any
    commands are initially received by the queue.
ifdef::VK_NVX_device_generated_commands[]
  * ename:VK_PIPELINE_STAGE_COMMAND_PROCESS_BIT_NVX: Stage of the pipeline
    where device-side generation of commands via
    flink:vkCmdProcessCommandsNVX is handled.
endif::VK_NVX_device_generated_commands[]
  * ename:VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT: Stage of the pipeline where
    Draw/DispatchIndirect data structures are consumed.
ifdef::VK_NVX_device_generated_commands[]
    This stage also includes reading commands written by
    flink:vkCmdProcessCommandsNVX.
endif::VK_NVX_device_generated_commands[]
  * ename:VK_PIPELINE_STAGE_VERTEX_INPUT_BIT: Stage of the pipeline where
    vertex and index buffers are consumed.
  * ename:VK_PIPELINE_STAGE_VERTEX_SHADER_BIT: Vertex shader stage.
  * ename:VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT: Tessellation
    control shader stage.
  * ename:VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT: Tessellation
    evaluation shader stage.
  * ename:VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT: Geometry shader stage.
  * ename:VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT: Fragment shader stage.
  * ename:VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT: Stage of the pipeline
    where early fragment tests (depth and stencil tests before fragment
    shading) are performed.
    This stage also includes <<renderpass-load-store-ops, subpass load
    operations>> for framebuffer attachments with a depth/stencil format.
  * ename:VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT: Stage of the pipeline
    where late fragment tests (depth and stencil tests after fragment
    shading) are performed.
    This stage also includes <<renderpass-load-store-ops, subpass store
    operations>> for framebuffer attachments with a depth/stencil format.
  * ename:VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT: Stage of the
    pipeline after blending where the final color values are output from the
    pipeline.
    This stage also includes <<renderpass-load-store-ops, subpass load and
    store operations>> and multisample resolve operations for framebuffer
    attachments with a color format.
  * [[synchronization-pipeline-stages-transfer]]
    ename:VK_PIPELINE_STAGE_TRANSFER_BIT: Execution of copy commands.
    This includes the operations resulting from all <<copies,copy
    commands>>, <<clears,clear commands>> (with the exception of
    flink:vkCmdClearAttachments), and flink:vkCmdCopyQueryPoolResults.
  * ename:VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT: Execution of a compute
    shader.
  * ename:VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT: Final stage in the pipeline
    where operations generated by all commands complete execution.
  * ename:VK_PIPELINE_STAGE_HOST_BIT: A pseudo-stage indicating execution on
    the host of reads/writes of device memory.
    This stage is not invoked by any commands recorded in a command buffer.
  * ename:VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT: Execution of all graphics
    pipeline stages.
    Equivalent to the logical or of:

  ** ename:VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT
  ** ename:VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT
  ** ename:VK_PIPELINE_STAGE_VERTEX_INPUT_BIT
  ** ename:VK_PIPELINE_STAGE_VERTEX_SHADER_BIT
  ** ename:VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT
  ** ename:VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT
  ** ename:VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT
  ** ename:VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT
  ** ename:VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT
  ** ename:VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT
  ** ename:VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT
  ** ename:VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT

  * ename:VK_PIPELINE_STAGE_ALL_COMMANDS_BIT: Equivalent to the logical or
    of every other pipeline stage flag that is supported on the queue it is
    used with.

[NOTE]
.注意
====
An execution dependency with only ename:VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT
in the destination stage mask will only prevent that stage from executing in
subsequently submitted commands.
As this stage does not perform any actual execution, this is not observable
- in effect, it does not delay processing of subsequent commands.
Similarly an execution dependency with only
ename:VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT in the source stage mask will
effectively not wait for any prior commands to complete.

When defining a memory dependency, using only
ename:VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT or
ename:VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT would never make any accesses
available and/or visible because these stages do not access memory.

ename:VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT and
ename:VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT are useful for accomplishing layout
transitions and queue ownership operations when the required execution
dependency is satisfied by other means - for example, semaphore operations
between queues.
====

// refEnd VkPipelineStageFlagBits

[[synchronization-pipeline-stages-masks]]
If a synchronization command includes a source stage mask, its first
<<synchronization-dependencies-scopes, synchronization scope>> only includes
execution of the pipeline stages specified in that mask, as well as any
<<synchronization-pipeline-stages-order, logically earlier>> stages.
If a synchronization command includes a destination stage mask, its second
<<synchronization-dependencies-scopes, synchronization scope>> only includes
execution of the pipeline stages specified in that mask, as well as any
<<synchronization-pipeline-stages-order, logically later>> stages.

<<synchronization-dependencies-access-scopes, Access scopes>> are affected
in a similar way.
If a synchronization command includes a source stage mask, its first
<<synchronization-dependencies-access-scopes, access scope>> only includes
memory access performed by pipeline stages specified in that mask.
If a synchronization command includes a destination stage mask, its second
<<synchronization-dependencies-access-scopes, access scope>> only includes
memory access performed by pipeline stages specified in that mask.

[NOTE]
.注意
====
Vulkan实现可能并不支持为了每个同步操作在每个管线阶段进行同步。
若Vulkan实现并不支持同步的一个管线阶段出现在 source stage mask，那么它可以为了逻辑上的后续阶段替换该阶段。
若Vulkan实现并不支持同步的一个管线阶段出现在destination stage mask，那么它可以为了逻辑上的之前的阶段替换该阶段。

例如，若一个Vulkan实现无法在顶点着色器执行完成后激发事件，它可以在颜色附件输出完成之后再激发事件。
若Vulkan实现做出了此种替换，它必须不能影响执行或者内存依赖、图像或缓冲区内存屏障的语义。
====

某些管线阶段只在支持特定操作集合的队列中可以使用。
下表陈列了，每个管线阶段标志位，以及队列必须支持的队列兼容性标志。
当表格的第二列出现了多个标志位，这表示管线阶段被带有其中任意一个标志位的队列所支持，
向获知有关队列兼容性的更多详细信息，请参考
<<devsandqueues-physical-device-enumeration, 物理设备枚举 >>
和 <<devsandqueues-queues, 队列>>.

[[synchronization-pipeline-stages-supported]]
.Supported pipeline stage flags
[cols="60%,40%",options="header"]
|====
|Pipeline stage flag                                          | Required queue capability flag
|ename:VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT                      | None required
|ename:VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT                    | ename:VK_QUEUE_GRAPHICS_BIT or ename:VK_QUEUE_COMPUTE_BIT
|ename:VK_PIPELINE_STAGE_VERTEX_INPUT_BIT                     | ename:VK_QUEUE_GRAPHICS_BIT
|ename:VK_PIPELINE_STAGE_VERTEX_SHADER_BIT                    | ename:VK_QUEUE_GRAPHICS_BIT
|ename:VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT      | ename:VK_QUEUE_GRAPHICS_BIT
|ename:VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT   | ename:VK_QUEUE_GRAPHICS_BIT
|ename:VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT                  | ename:VK_QUEUE_GRAPHICS_BIT
|ename:VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT                  | ename:VK_QUEUE_GRAPHICS_BIT
|ename:VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT             | ename:VK_QUEUE_GRAPHICS_BIT
|ename:VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT              | ename:VK_QUEUE_GRAPHICS_BIT
|ename:VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT          | ename:VK_QUEUE_GRAPHICS_BIT
|ename:VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT                   | ename:VK_QUEUE_COMPUTE_BIT
|ename:VK_PIPELINE_STAGE_TRANSFER_BIT                         | ename:VK_QUEUE_GRAPHICS_BIT, ename:VK_QUEUE_COMPUTE_BIT or ename:VK_QUEUE_TRANSFER_BIT
|ename:VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT                   | None required
|ename:VK_PIPELINE_STAGE_HOST_BIT                             | None required
|ename:VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT                     | ename:VK_QUEUE_GRAPHICS_BIT
|ename:VK_PIPELINE_STAGE_ALL_COMMANDS_BIT                     | None required
ifdef::VK_NVX_device_generated_commands[]
|ename:VK_PIPELINE_STAGE_COMMAND_PROCESS_BIT_NVX              | ename:VK_QUEUE_GRAPHICS_BIT or ename:VK_QUEUE_COMPUTE_BIT
endif::VK_NVX_device_generated_commands[]
|====

[[synchronization-pipeline-stages-order]]
Pipeline stages that execute as a result of a command logically complete
execution in a specific order, such that completion of a logically later
pipeline stage must: not happen-before completion of a logically earlier
stage.
This means that including any given stage in the source stage mask for a
particular synchronization command also implies that any logically earlier
stages are included in *A~S~* for that command.

Similarly, initiation of a logically earlier pipeline stage must: not
happen-after initiation of a logically later pipeline stage.
Including any given stage in the destination stage mask for a particular
synchronization command also implies that any logically later stages are
included in *B~S~* for that command.

.注意
[NOTE]
====
Logically earlier/later stages are not included when defining the
<<synchronization-dependencies-access-scopes, access scopes>> of a
<<synchronization-memory-barriers,memory barrier>>.
====

[[synchronization-pipeline-stages-types]]
The order of pipeline stages depends on the particular pipeline; graphics,
compute, transfer or host.

对于图形管线，如下阶段按顺序发生：

  * ename:VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT
  * ename:VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT
  * ename:VK_PIPELINE_STAGE_VERTEX_INPUT_BIT
  * ename:VK_PIPELINE_STAGE_VERTEX_SHADER_BIT
  * ename:VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT
  * ename:VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT
  * ename:VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT
  * ename:VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT
  * ename:VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT
  * ename:VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT
  * ename:VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT
  * ename:VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT

对于计算管线，如下阶段按顺序发生：

  * ename:VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT
  * ename:VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT
  * ename:VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT
  * ename:VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT

对于转换管线，如下阶段按顺序发生：

  * ename:VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT
  * ename:VK_PIPELINE_STAGE_TRANSFER_BIT
  * ename:VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT

对于CPU端操作，只会有一个阶段会发生，所以不需要保证顺序：

  * ename:VK_PIPELINE_STAGE_HOST_BIT

ifdef::VK_NVX_device_generated_commands[]
For the command processing pipeline, the following stages occur in this
order:

  * ename:VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT
  * ename:VK_PIPELINE_STAGE_COMMAND_PROCESS_BIT_NVX
  * ename:VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT
endif::VK_NVX_device_generated_commands[]

[[synchronization-access-types]]
=== 访问类型

Memory in Vulkan can: be accessed from within shader invocations and via
some fixed-function stages of the pipeline.
The _access type_ is a function of the <<descriptorsets, descriptor type>>
used, or how a fixed-function stage accesses memory.
Each access type corresponds to a bit flag in slink:VkAccessFlagBits.

[[synchronization-access-masks]]
Some synchronization commands take sets of access types as parameters to
define the <<synchronization-dependencies-access-scopes, access scopes>> of
a memory dependency.
If a synchronization command includes a 源访问掩码, its first
<<synchronization-dependencies-access-scopes, access scope>> only includes
accesses via the access types specified in that mask.
Similarly, if a synchronization command includes a 目标访问掩码,
its second <<synchronization-dependencies-access-scopes, access scope>> only
includes accesses via the access types specified in that mask.

// refBegin VkAccessFlagBits Bitmask specifying memory access types that will participate in a memory dependency

可以被设置的访问类型包含如下：

[[synchronization-access-flags]]
include::../api/enums/VkAccessFlagBits.txt[]

  * ename:VK_ACCESS_INDIRECT_COMMAND_READ_BIT: Read access to an indirect
    command structure read as part of an indirect drawing or dispatch
    command.
  * ename:VK_ACCESS_INDEX_READ_BIT: Read access to an index buffer as part
    of an indexed drawing command, bound by flink:vkCmdBindIndexBuffer.
  * ename:VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT: Read access to a vertex
    buffer as part of a drawing command, bound by
    flink:vkCmdBindVertexBuffers.
  * ename:VK_ACCESS_UNIFORM_READ_BIT: Read access to a
    <<descriptorsets-uniformbuffer, uniform buffer>>.
  * ename:VK_ACCESS_INPUT_ATTACHMENT_READ_BIT: Read access to an
    <<renderpass, input attachment>> within a renderpass during fragment
    shading.
  * ename:VK_ACCESS_SHADER_READ_BIT: Read access to a
    <<descriptorsets-storagebuffer, storage buffer>>,
    <<descriptorsets-uniformtexelbuffer, uniform texel buffer>>,
    <<descriptorsets-storagetexelbuffer, storage texel buffer>>,
    <<descriptorsets-sampledimage, sampled image>>, or
    <<descriptorsets-storageimage, storage image>>.
  * ename:VK_ACCESS_SHADER_WRITE_BIT: Write access to a
    <<descriptorsets-storagebuffer, storage buffer>>,
    <<descriptorsets-storagetexelbuffer, storage texel buffer>>, or
    <<descriptorsets-storageimage, storage image>>.
  * ename:VK_ACCESS_COLOR_ATTACHMENT_READ_BIT: Read access to a
    <<renderpass, color attachment>>, such as via <<framebuffer-blending,
    blending>>, <<framebuffer-logicop, logic operations>>, or via certain
    <<renderpass-load-store-ops, subpass load operations>>.
  * ename:VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT: Write access to a
    <<renderpass, color or resolve attachment>> during a <<renderpass,
    render pass>> or via certain <<renderpass-load-store-ops, subpass load
    and store operations>>.
  * ename:VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT: Read access to a
    <<renderpass, depth/stencil attachment>>, via <<fragops-ds-state, depth
    or stencil operations>> or via certain <<renderpass-load-store-ops,
    subpass load operations>>.
  * ename:VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT: Write access to a
    <<renderpass, depth/stencil attachment>>, via <<fragops-ds-state, depth
    or stencil operations>> or via certain <<renderpass-load-store-ops,
    subpass load and store operations>>.
  * ename:VK_ACCESS_TRANSFER_READ_BIT: Read access to an image or buffer in
    a <<copies, copy>> operation.
  * ename:VK_ACCESS_TRANSFER_WRITE_BIT: Write access to an image or buffer
    in a <<clears, clear>> or <<copies, copy>> operation.
  * ename:VK_ACCESS_HOST_READ_BIT: Read access by a host operation.
    Accesses of this type are not performed through a resource, but directly
    on memory.
  * ename:VK_ACCESS_HOST_WRITE_BIT: Write access by a host operation.
    Accesses of this type are not performed through a resource, but directly
    on memory.
  * ename:VK_ACCESS_MEMORY_READ_BIT: Read access via non-specific entities.
    These entities include the Vulkan device and host, but may: also include
    entities external to the Vulkan device or otherwise not part of the core
    Vulkan pipeline.
    When included in a 目标访问掩码, makes all available writes
    visible to all future read accesses on entities known to the Vulkan
    device.
  * ename:VK_ACCESS_MEMORY_WRITE_BIT: Write access via non-specific
    entities.
    These entities include the Vulkan device and host, but may: also include
    entities external to the Vulkan device or otherwise not part of the core
    Vulkan pipeline.
    When included in a 源访问掩码, all writes that are performed by
    entities known to the Vulkan device are made available.
    When included in a 目标访问掩码, makes all available writes
    visible to all future write accesses on entities known to the Vulkan
    device.
ifdef::VK_NVX_device_generated_commands[]
  * ename:VK_ACCESS_COMMAND_PROCESS_READ_BIT_NVX: Reads from sname:VkBuffer
    inputs to flink:vkCmdProcessCommandsNVX.
  * ename:VK_ACCESS_COMMAND_PROCESS_WRITE_BIT_NVX: Writes to the target
    command buffer in flink:vkCmdProcessCommandsNVX.
endif::VK_NVX_device_generated_commands[]

Certain access types are only performed by a subset of pipeline stages.
Any synchronization command that takes both stage masks and 访问掩码
uses both to define the <<synchronization-dependencies-access-scopes, access
scopes>> - only the specified access types performed by the specified stages
are included in the access scope.
An application must: not specify an access flag in a synchronization command
if it does not include a pipeline stage in the corresponding stage mask that
is able to perform accesses of that type.
The following table lists, for each access flag, which pipeline stages can:
perform that type of access.

[[synchronization-access-types-supported]]
.Supported access types
[cols="50,50",options="header"]
|====
|Access flag                                                  | Supported pipeline stages
|ename:VK_ACCESS_INDIRECT_COMMAND_READ_BIT                    | ename:VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT
|ename:VK_ACCESS_INDEX_READ_BIT                               | ename:VK_PIPELINE_STAGE_VERTEX_INPUT_BIT
|ename:VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT                    | ename:VK_PIPELINE_STAGE_VERTEX_INPUT_BIT
|ename:VK_ACCESS_UNIFORM_READ_BIT                             | ename:VK_PIPELINE_STAGE_VERTEX_SHADER_BIT, ename:VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT, ename:VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT, ename:VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT, ename:VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT, or ename:VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT
|ename:VK_ACCESS_INPUT_ATTACHMENT_READ_BIT                    | ename:VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT
|ename:VK_ACCESS_SHADER_READ_BIT                              | ename:VK_PIPELINE_STAGE_VERTEX_SHADER_BIT, ename:VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT, ename:VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT, ename:VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT, ename:VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT, or ename:VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT
|ename:VK_ACCESS_SHADER_WRITE_BIT                             | ename:VK_PIPELINE_STAGE_VERTEX_SHADER_BIT, ename:VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT, ename:VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT, ename:VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT, ename:VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT, or ename:VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT
|ename:VK_ACCESS_COLOR_ATTACHMENT_READ_BIT                    | ename:VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT
|ename:VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT                   | ename:VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT
|ename:VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT            | ename:VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT, or ename:VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT
|ename:VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT           | ename:VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT, or ename:VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT
|ename:VK_ACCESS_TRANSFER_READ_BIT                            | ename:VK_PIPELINE_STAGE_TRANSFER_BIT
|ename:VK_ACCESS_TRANSFER_WRITE_BIT                           | ename:VK_PIPELINE_STAGE_TRANSFER_BIT
|ename:VK_ACCESS_HOST_READ_BIT                                | ename:VK_PIPELINE_STAGE_HOST_BIT
|ename:VK_ACCESS_HOST_WRITE_BIT                               | ename:VK_PIPELINE_STAGE_HOST_BIT
|ename:VK_ACCESS_MEMORY_READ_BIT                              | N/A
|ename:VK_ACCESS_MEMORY_WRITE_BIT                             | N/A
ifdef::VK_NVX_device_generated_commands[]
|ename:VK_ACCESS_COMMAND_PROCESS_READ_BIT_NVX                 | ename:VK_PIPELINE_STAGE_COMMAND_PROCESS_BIT_NVX
|ename:VK_ACCESS_COMMAND_PROCESS_WRITE_BIT_NVX                | ename:VK_PIPELINE_STAGE_COMMAND_PROCESS_BIT_NVX
endif::VK_NVX_device_generated_commands[]
|====


[[synchronization-framebuffer-regions]]
=== Framebuffer Region Dependencies

就<<synchronization-pipeline-stages, 管线阶段>> 所操作的缓冲区而言，都是  _framebuffer-space_pipeline 阶段。
这些阶段如下：

  * ename:VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT
  * ename:VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT
  * ename:VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT
  * ename:VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT

对于这些管现阶段而言，从操作的第一个set到第二个set可以是单 _framebuffer-global_ 依赖，也可以被拆分成多个  _framebuffer-local_ 依赖。

带有non-framebuffer-space 管现阶段的依赖，既不 framebuffer-global ，也不 framebuffer-local。

一个 _framebuffer region_ 是一个 sample (x, y, layer, sample) 坐标的集合，是整个缓冲区的一个子集。

一个单 framebuffer-local 依赖，保证对于单个缓冲区区域，操作的第一个set与 可用性操作再 可见性操作、操作的第二个set之前发生。
对于一个framebuffer-local 依赖，不保证 缓冲区区域之间的顺序。

一个framebuffer-global 依赖，保证对所有缓冲区区域的操作的第一个set 在对任何缓冲区区域的第二个set 之前发生。

.注意
[NOTE]
====
因为 fragment调用并没有在任何分组中被指定运行，帧缓冲区区域的大小取决于Vulkan实现，应用程序并不知道，而且，必须认为比单个sample要大。
====

If a synchronization command includes a pname:dependencyFlags parameter, and
specifies the ename:VK_DEPENDENCY_BY_REGION_BIT flag, then it defines
framebuffer-local dependencies for the framebuffer-space pipeline stages in
that synchronization command, for all framebuffer regions.
If no pname:dependencyFlags parameter is included, or the
ename:VK_DEPENDENCY_BY_REGION_BIT flag is not specified, then a
framebuffer-global dependency is specified for those stages.
The ename:VK_DEPENDENCY_BY_REGION_BIT flag does not affect the dependencies
between non-framebuffer-space pipeline stages, nor does it affect the
dependencies between framebuffer-space and non-framebuffer-space pipeline
stages.

.注意
[NOTE]
====
Framebuffer-local dependencies are more optimal for most architectures;
particularly tile-based architectures - which can keep framebuffer-regions
entirely in on-chip registers and thus avoid external bandwidth across such
a dependency.
Including a framebuffer-global dependency in your rendering will usually
force all implementations to flush data to memory, or to a higher level
cache, breaking any potential locality optimizations.
====


[[synchronization-implicit]]
== 隐式同步保障

Vulkan支持少量的隐式顺序保证，确保命令提交的顺序是有意义的，且在常规的操作中避免不必要的复杂性。

[[synchronization-submission-order]]
_Submission order_ 是Vulkan中基础的排序，对于记录并提交到单个队列的 <<fundamentals-queueoperation-command-types, action and
synchronization commands>> 的顺序是有意义的。显式的或者隐式的排序保证了，在Vulakn中以此为前提的不同命令之间所有工作，这种排序都是有意义的。

Submission order for any given set of commands is based on the order in
which they were recorded to command buffers and then submitted.
This order is determined as follows:

  . The initial order is determined by the order in which
    flink:vkQueueSubmit commands are executed on the host, for a single
    queue, from first to last.
  . The order in which slink:VkSubmitInfo structures are specified in the
    pname:pSubmits parameter of flink:vkQueueSubmit, from lowest index to
    highest.
  . The order in which command buffers are specified in the
    pname:pCommandBuffers member of slink:VkSubmitInfo, from lowest index to
    highest.
  . The order in which commands were recorded to a command buffer on the
    host, from first to last:
  ** For commands recorded outside a render pass, this includes all other
     commands recorded outside a renderpass, including
     flink:vkCmdBeginRenderPass and flink:vkCmdEndRenderPass commands; it
     does not directly include commands inside a render pass.
  ** For commands recorded inside a render pass, this includes all other
     commands recorded inside the same subpass, including the
     flink:vkCmdBeginRenderPass and flink:vkCmdEndRenderPass commands that
     delimit the same renderpass instance; it does not include commands
     recorded to other subpasses.

<<fundamentals-queueoperation-command-types, Action and synchronization
commands>> recorded to a command buffer execute the
ename:VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT pipeline stage in
<<synchronization-submission-order, submission order>> - forming an implicit
execution dependency between this stage in each command.

<<fundamentals-queueoperation-command-types, State commands>> do not execute
any operations on the device, instead they set the state of the command
buffer when they execute on the host, in the order that they are recorded.
<<fundamentals-queueoperation-command-types, Action commands>> consume the
current state of the command buffer when they are recorded, and will execute
state changes on the device as required to match the recorded state.

<<queries-order, Query commands>>, <<drawing-primitive-order, the order of
primitives passing through the graphics pipeline>> and
<<synchronization-image-barrier-layout-transition-order, image layout
transitions as part of an image memory barrier>> provide additional
guarantees based on submission order.

Execution of <<synchronization-pipeline-stages-order, pipeline stages>>
within a given command also has a loose ordering, dependent only on a single
command.


[[synchronization-fences]]
== 栅栏

// refBegin VkFence Opaque handle to a fence object

栅栏是同步原语，可以用来在CPU端队列上插入一个依赖。栅栏由两个状态：激发的、未激发的。一个栅栏可以被当作<<devsandqueues-submission, 队列提交 >> 命令
执行的一部分从而被激发。
栅栏可以在CPU端被  flink:vkResetFences 设置为 未激发状态。
栅栏可以在CPU端让 flink:vkWaitForFences 命令等待，且当前的状态可以通过 flink:vkGetFenceStatus 查询。 

栅栏 可以使用如下  sname:VkFence  handle表示：

include::../api/handles/VkFence.txt[]

// refEnd VkFence

// refBegin vkCreateFence Create a new fence object

To create a fence, call:

include::../api/protos/vkCreateFence.txt[]

  * pname:device 是创建栅栏的逻辑设备。
  * pname:pCreateInfo 是一个指针，指向一个  sname:VkFenceCreateInfo 数据结构的实例，它包含如何创建栅栏的信息。
  * pname:pAllocator 控制CPU端内存分配，如  <<memory-allocation, 内存分配>> 一章详述。
  * pname:pFence 指向一个handle，它包含被创建并返回的栅栏对象。

include::../validity/protos/vkCreateFence.txt[]

// refBegin VkFenceCreateInfo Structure specifying parameters of a newly created fence

sname:VkFenceCreateInfo 类型数据结构定义如下：

include::../api/structs/VkFenceCreateInfo.txt[]

  * pname:sType 是数据结构的类型。
  * pname:pNext 是 `NULL` 或者一个指向拓展特定的数据结构的指针。
  * pname:flags defines the initial state and behavior of the fence.
    Bits which can: be set include:
+
--
// refBegin VkFenceCreateFlagBits Bitmask specifying initial state and behavior of a fence
include::../api/enums/VkFenceCreateFlagBits.txt[]
--
+
If pname:flags contains ename:VK_FENCE_CREATE_SIGNALED_BIT then the fence
object is created in the signaled state; otherwise it is created in the
unsignaled state.

include::../validity/structs/VkFenceCreateInfo.txt[]

// refBegin vkDestroyFence Destroy a fence object

可调用如下命令来销毁fence：

include::../api/protos/vkDestroyFence.txt[]

  * pname:device 是销毁栅栏对象的逻辑设备。
  * pname:fence 是需要被销毁的栅栏的handle。
  * pname:pAllocator 控制CPU端内存分配，如 <<memory-allocation, 内存分配>> 一章详述。

.正确使用
****
  * 所有指向 pname:fence的 <<devsandqueues-submission, 队列提交 >> 命令 必须已经完成执行力。
  * 若 sname:VkAllocationCallbacks 在创建栅栏是被提供，那么在此时需要提供一套兼容的回调函数。
  * 若在创建栅栏时没有提供 sname:VkAllocationCallbacks，那么这个 pname:pAllocator 必须: 是 `NULL`
****

include::../validity/protos/vkDestroyFence.txt[]

// refBegin vkGetFenceStatus Return the status of a fence

可调用如下命令来查询CPU端栅栏的状态：

include::../api/protos/vkGetFenceStatus.txt[]

  * pname:device is the logical device that owns the fence.
  * pname:fence is the handle of the fence to query.

Upon success, fname:vkGetFenceStatus returns the status of the fence object,
with the following return codes:

.Fence Object Status Codes
[width="80%",options="header"]
|====
| Status | Meaning
| ename:VK_SUCCESS | The fence specified by pname:fence is signaled.
| ename:VK_NOT_READY | The fence specified by pname:fence is unsignaled.
|====

若一个 <<devsandqueues-submission, 队列提交 >> 命令被暂停执行，那么这个命令的返回值可能会立即过期。

include::../validity/protos/vkGetFenceStatus.txt[]

[[synchronization-fences-unsignaling]]
// refBegin vkResetFences Resets one or more fence objects

可调用如下命令，在CPU端设置栅栏的状态为非激发：

include::../api/protos/vkResetFences.txt[]

  * pname:device 是拥有栅栏的逻辑设备。
  * pname:fenceCount 是需要被重置的栅栏数量。
  * pname:pFences 是一个指针，指向一个需要被重置的栅栏的数组。 

当 flink:vkResetFences 在CPU端被执行，它为每一个栅栏定义了一个 _fence unsignal operation_，它把栅栏设置为非激发状态。

若在flink:vkResetFences执行时，pname:pFences数组中任何一个已经处于非激发状态，那么flink:vkResetFences 将对于该栅栏没有效果。

.正确使用
****
  * pname:pFences数组中任何元素当前都不能和任何在队列上未执行完成的队列命令关联。
****

include::../validity/protos/vkResetFences.txt[]

[[synchronization-fences-signaling]]
当一个栅栏被当作 <<devsandqueues-submission, 队列提交>> 命令的一部分，提交到队列时，它在被当作该命令的一部分的批量任务上定义了一个内存依赖，
且定义了一个 _fence signal operation_，该operation设置栅栏为激发状态。

第一个<<synchronization-dependencies-scopes, 同步范围>>包含同一个 <<devsandqueues-submission, queue
submission>> 内提交的批量任务。
通过 flink:vkQueueSubmit 定义的栅栏激发操作此外还包含在第一个同步范围内 通过flink:vkQueueSubmit提交到同一个队列的之前的队列提交。

第二个<<synchronization-dependencies-scopes, 同步范围>>只包含栅栏激发操作。

第一个<<synchronization-dependencies-access-scopes,  访问范围>>包含此设备操纵的所有内存访问。

第二个 <<synchronization-dependencies-access-scopes, 访问范围>> 是空的。

// refBegin vkWaitForFences Wait for one or more fences to become signaled

在CPU端，可调用如下命令来等待一个或者多个栅栏来进入激发状态：

include::../api/protos/vkWaitForFences.txt[]

  * pname:device 是拥有栅栏的逻辑设备。
  * pname:fenceCount 是需要等待的栅栏的数量。
  * pname:pFences 是指针，指向 pname:fenceCount 个栅栏的handle的数组。    
  * pname:waitAll 是接触等待必须要满足的条件。
	 若pname:waitAll 是 ename:VK_TRUE，那么条件就是pname:pFences中所有的栅栏都是激发状态的。
	 否则，条件就是pname:pFences中至少一个栅栏是激发状态的。
  * pname:timeout 是过期时间，单位为纳秒。pname:timeout 被调整为Vulkan实现所允许的精确度下最接近的值，故可能比一纳秒也大很多，
     所以，真实过期时间比给定的时间要长。  

若调用 fname:vkWaitForFences时，条件都满足了，那么fname:vkWaitForFences 直接立刻返回。
若调用 fname:vkWaitForFences时，条件没有被满足，那么fname:vkWaitForFences 将阻塞，并且等待pname:timeout 纳秒，以检测条件是否被满足。


若 pname:timeout 为0，那么 fname:vkWaitForFences 不等待，但是将返回栅栏当前的状态。
若条件不满足，将返回ename:VK_TIMEOUT，即使实际上并没有执行等待。

若条件被满足之前指定的timeout 时间过期，fname:vkWaitForFences 将返回 ename:VK_TIMEOUT。
若在 pname:timeout纳秒过期之前条件已经满足，fname:vkWaitForFences 将返回 ename:VK_SUCCESS。

include::../validity/protos/vkWaitForFences.txt[]

[[synchronization-fences-waiting]]
An execution dependency is defined by waiting for a fence to become
signaled, either via flink:vkWaitForFences or by polling on
flink:vkGetFenceStatus.

The first <<synchronization-dependencies-scopes, synchronization scope>>
includes only the fence signal operation.

The second <<synchronization-dependencies-scopes, synchronization scope>>
includes the host operations of flink:vkWaitForFences or
flink:vkGetFenceStatus indicating that the fence has become signaled.

.注意
[NOTE]
====
Signaling a fence and waiting on the host does not guarantee that the
results of memory accesses will be visible to the host.
To provide that guarantee, the application must: insert a memory barrier
between the device writes and the end of the submission that will signal the
fence, with pname:dstAccessMask having the ename:VK_ACCESS_HOST_READ_BIT bit
set, with pname:dstStageMask having the ename:VK_PIPELINE_STAGE_HOST_BIT bit
set, and with the appropriate pname:srcStageMask and pname:srcAccessMask
members set to guarantee completion of the writes.
If the memory was allocated without the
ename:VK_MEMORY_PROPERTY_HOST_COHERENT_BIT set, then
fname:vkInvalidateMappedMemoryRanges must: be called after the fence is
signaled in order to ensure the writes are visible to the host, as described
in <<memory-device-hostaccess,Host Access to Device Memory Objects>>.
====

ifdef::VK_EXT_display_control[]
include::VK_EXT_display_control/fence_events.txt[]
endif::VK_EXT_display_control[]

[[synchronization-semaphores]]
== 信号量

// refBegin VkSemaphore Opaque handle to a semaphore object

信号量是同步原语，可用来在提交到队列的批量任务之间插入依赖。
信号量有两种状态：激发的、未激发的。
当批量命令执行完成后，信号量可以被激发。
批量任务在真正执行前，可以等待信号量被激发，且信号量在批量任务开始执行时是未激发的。

信号量可以使用 sname:VkSemaphore handle表示:

include::../api/handles/VkSemaphore.txt[]

// refEnd VkSemaphore

// refBegin vkCreateSemaphore Create a new queue semaphore object

To create a semaphore, call:

include::../api/protos/vkCreateSemaphore.txt[]

  * pname:device 是创建信号量的逻辑设备。
  * pname:pCreateInfo 是一个指针，指向一个 sname:VkSemaphoreCreateInfo 数据结构实例，它包含如何创建信号量的信息。    
  * pname:pAllocator 控制CPU端内存分配，如 <<memory-allocation, 内存分配 >> 一章详述。
  * pname:pSemaphore 指向被返回的信号量对象的handle。

当创建好后，信号量处于未激发状态。

include::../validity/protos/vkCreateSemaphore.txt[]

// refBegin VkSemaphoreCreateInfo Structure specifying parameters of a newly created semaphore

sname:VkSemaphoreCreateInfo 类型数据结构定义如下：

include::../api/structs/VkSemaphoreCreateInfo.txt[]

  * pname:sType 是数据结构的类型。
  * pname:pNext 是 `NULL` 或者一个指向拓展特定的数据结构的指针。
  * pname:flags 被保留。

include::../validity/structs/VkSemaphoreCreateInfo.txt[]

// refBegin vkDestroySemaphore Destroy a semaphore object

可调用如下命令来销毁信号量：

include::../api/protos/vkDestroySemaphore.txt[]

  * pname:device 是销毁信号量的逻辑设备。
  * pname:semaphore 是需要被销毁的信号量的handle。
  * pname:pAllocator 控制CPU端内存分配，如 <<memory-allocation, 内存分配 >> 一章详述。

.正确使用
****
  * All submitted batches that refer to pname:semaphore must: have completed
    execution
  * If sname:VkAllocationCallbacks were provided when pname:semaphore was
    created, a compatible set of callbacks must: be provided here
  * If no sname:VkAllocationCallbacks were provided when pname:semaphore was
    created, pname:pAllocator must: be `NULL`
****

include::../validity/protos/vkDestroySemaphore.txt[]


[[synchronization-semaphores-signaling]]
=== 激发信号量

When a batch is submitted to a queue via a <<devsandqueues-submission, queue
submission>>, and it includes semaphores to be signaled, it defines a memory
dependency on the batch, and defines _semaphore signal operations_ which set
the semaphores to the signaled state.

The first <<synchronization-dependencies-scopes, synchronization scope>>
includes every command submitted in the same batch.
Semaphore signal operations that are defined by flink:vkQueueSubmit
additionally include all batches previously submitted to the same queue via
flink:vkQueueSubmit, including batches that are submitted in the same
<<devsandqueues-submission, queue submission>> command, but at a lower index
within the array of batches.

The second <<synchronization-dependencies-scopes, synchronization scope>>
includes only the semaphore signal operation.

The first <<synchronization-dependencies-access-scopes, access scope>>
includes all memory access performed by the device.

The second <<synchronization-dependencies-access-scopes, access scope>> is
empty.


[[synchronization-semaphores-waiting]]
=== 等待信号量 & 取消激发

When a batch is submitted to a queue via a <<devsandqueues-submission, queue
submission>>, and it includes semaphores to be waited on, it defines a
memory dependency between prior semaphore signal operations and the batch,
and defines _semaphore unsignal operations_ which set the semaphores to the
unsignaled state.

The first synchronization scope includes all semaphore signal operations
that operate on semaphores waited on in the same batch, and that
happen-before the wait completes.

The second <<synchronization-dependencies-scopes, synchronization scope>>
includes every command submitted in the same batch.
In the case of flink:vkQueueSubmit, the second synchronization scope is
limited to operations on the pipeline stages determined by the
<<synchronization-pipeline-stages-masks, destination stage mask>> specified
by the corresponding element of pname:pWaitDstStageMask.
Also, in the case of flink:vkQueueSubmit, the second synchronization scope
additionally includes all batches subsequently submitted to the same queue
via flink:vkQueueSubmit, including batches that are submitted in the same
<<devsandqueues-submission, queue submission>> command, but at a higher
index within the array of batches.

The first <<synchronization-dependencies-access-scopes, access scope>> is
empty.

The second <<synchronization-dependencies-access-scopes, access scope>>
includes all memory access performed by the device.

The semaphore unsignal operation happens-after the first set of operations
in the execution dependency, and happens-before the second set of operations
in the execution dependency.

.注意
[NOTE]
====
Unlike fences or events, the act of waiting for a semaphore also unsignals
that semaphore.
If two operations are separately specified to wait for the same semaphore,
and there are no other execution dependencies between those operations,
behaviour is undefined.
An execution dependency must: be present that guarantees that the semaphore
unsignal operation for the first of those waits, happens-before the
semaphore is signalled again, and before the second unsignal operation.
Semaphore waits and signals should thus occur in discrete 1:1 pairs.
====

ifdef::VK_KHR_swapchain[]
.注意
[NOTE]
====
A common scenario for using pname:pWaitDstStageMask with values other than
ename:VK_PIPELINE_STAGE_ALL_COMMANDS_BIT is when synchronizing a window
system presentation operation against subsequent command buffers which
render the next frame.
In this case, a presentation image must: not be overwritten until the
presentation operation completes, but other pipeline stages can: execute
without waiting.
A mask of ename:VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT prevents
subsequent color attachment writes from executing until the semaphore
signals.
Some implementations may: be able to execute transfer operations and/or
vertex processing work before the semaphore is signaled.

If an image layout transition needs to be performed on a presentable image
before it is used in a framebuffer, that can: be performed as the first
operation submitted to the queue after acquiring the image, and should: not
prevent other work from overlapping with the presentation operation.
For example, a sname:VkImageMemoryBarrier could use:

  * pname:srcStageMask = ename:VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT
  * pname:srcAccessMask = 0
  * pname:dstStageMask = ename:VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT
  * pname:dstAccessMask = ename:VK_ACCESS_COLOR_ATTACHMENT_READ_BIT |
    ename:VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT.
  * pname:oldLayout = etext:VK_IMAGE_LAYOUT_PRESENT_SRC_KHR
  * pname:newLayout = ename:VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL

Alternatively, pname:oldLayout can: be ename:VK_IMAGE_LAYOUT_UNDEFINED, if
the image's contents need not be preserved.

This barrier accomplishes a dependency chain between previous presentation
operations and subsequent color attachment output operations, with the
layout transition performed in between, and does not introduce a dependency
between previous work and any vertex processing stages.
More precisely, the semaphore signals after the presentation operation
completes, the semaphore wait stalls the
ename:VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT stage, and there is a
dependency from that same stage to itself with the layout transition
performed in between.
====
endif::VK_KHR_swapchain[]


[[synchronization-events]]
== 事件

// refBegin VkEvent Opaque handle to a event object

事件是它同步原语， 可用于在提交到同一个队列的不同命令之间，或者在CPU端与队列之间，插入高度优化的依赖。
事件有两种状态：激发的、未激发的。
应用程序可以在CPU端或者设备端激发一个事件，或者取消激发状态。
设备可在进一步执行其他操作之前等待事件直至其变为激发被激发。
在CPU端没有命令等待事件变被激发，事件的当前状态也是可以被查询。

使用sname:VkEvent handle表示事件:

include::../api/handles/VkEvent.txt[]

// refEnd VkEvent

// refBegin vkCreateEvent Create a new event object

To create an event, call:

include::../api/protos/vkCreateEvent.txt[]

  * pname:device 是创建事件的逻辑设备。
  * pname:pCreateInfo 是一个指针，指向一个 sname:VkEventCreateInfo 数据结构实例，它包含了创建事件所需的信息。
  * pname:pAllocator 控制CPU端内存分配，如 <<memory-allocation, 内存分配 >> 一章详述。
  * pname:pEvent 指向被创建的事件对象的handle。

创建完成后，事件对象处于未激发状态。

include::../validity/protos/vkCreateEvent.txt[]

// refBegin VkEventCreateInfo Structure specifying parameters of a newly created event

sname:VkEventCreateInfo 类型数据结构定义如下：

include::../api/structs/VkEventCreateInfo.txt[]

  * pname:sType 是数据结构的类型。
  * pname:pNext 是 `NULL` 或者一个指向拓展特定的数据结构的指针。
  * pname:flags 被保留。

include::../validity/structs/VkEventCreateInfo.txt[]

// refBegin vkDestroyEvent Destroy an event object

调用如下命令来销毁事件：

include::../api/protos/vkDestroyEvent.txt[]

  * pname:device 是销毁事件的逻辑设备。
  * pname:event 是需要被销毁的事件。
  * pname:pAllocator 控制CPU端内存分配，如 <<memory-allocation, 内存分配 >> 一章详述。

.正确使用
****
  * All submitted commands that refer to pname:event must: have completed
    execution
  * If sname:VkAllocationCallbacks were provided when pname:event was
    created, a compatible set of callbacks must: be provided here
  * If no sname:VkAllocationCallbacks were provided when pname:event was
    created, pname:pAllocator must: be `NULL`
****

include::../validity/protos/vkDestroyEvent.txt[]

// refBegin vkGetEventStatus Retrieve the status of an event object

可在CU端使用如下命令来查询事件的状态：

include::../api/protos/vkGetEventStatus.txt[]

  * pname:device 是拥有该事件的逻辑设备。
  * pname:event 是需要被查询的事件handle。

Upon success, fname:vkGetEventStatus returns the state of the event object
with the following return codes:

.Event Object Status Codes
[width="80%",options="header"]
|====
| Status | Meaning
| ename:VK_EVENT_SET | The event specified by pname:event is signaled.
| ename:VK_EVENT_RESET | The event specified by pname:event is unsignaled.
|====

If a fname:vkCmdSetEvent or fname:vkCmdResetEvent command is pending
execution, then the value returned by this command may: immediately be out
of date.

The state of an event can: be updated by the host.
The state of the event is immediately changed, and subsequent calls to
fname:vkGetEventStatus will return the new state.
If an event is already in the requested state, then updating it to the same
state has no effect.

include::../validity/protos/vkGetEventStatus.txt[]

[[synchronization-events-signaling-host]]
// refBegin vkSetEvent Set an event to signaled state

可通过如下命令，在CPU端来设置事件的状态为 激发状态：

include::../api/protos/vkSetEvent.txt[]

  * pname:device 是拥有该事件的逻辑设备。
  * pname:event 是需要被设置的事件。

当 flink:vkSetEvent 在CPU端执行是，它定义了一个  _event signal operation_ ，此操作设置事件为已激发状态。

 在 flink:vkSetEvent 被执行时，若 pname:event 已经处于激发状态，那么 flink:vkSetEvent 没有任何效果，不会导致事件激发操作。

include::../validity/protos/vkSetEvent.txt[]

[[synchronization-events-unsignaling-host]]
// refBegin vkResetEvent Reset an event to non-signaled state

可通过如下命令，在CPU端来设置事件的状态为 未激发状态：

include::../api/protos/vkResetEvent.txt[]

  * pname:device 是拥有该事件的逻辑设备。
  * pname:event 是需要被重置的事件。

当在CPU端执行 flink:vkResetEvent 时，它定义了一个 _event unsignal operation_ ，它会把事件重置为非激发状态。
若在执行 flink:vkResetEvent时，pname:event 已经处于非激发状态，那么 flink:vkResetEvent没有任何效果，不会导致事件取消激发操作。


.正确使用
****
  * pname:event must: not be waited on by a fname:vkCmdWaitEvents command
    that is currently executing
****

include::../validity/protos/vkResetEvent.txt[]

在GPU端，也可通过如下的被插入到命令缓冲区的命令，来设置事件的状态:

[[synchronization-events-signaling-device]]
// refBegin vkCmdSetEvent Set an event object to signaled state

可使用如下命令在GPU端 来激发事件：

include::../api/protos/vkCmdSetEvent.txt[]

  * pname:commandBuffer 是命令被记录所在的命令缓冲区。
  * pname:event 是将被激发的事件。
  * pname:stageMask 指定了 用来决定何时激发 pname:event 的 <<synchronization-pipeline-stages,源阶段掩码>>。

当flink:vkCmdSetEvent 被提交到队列，它在被提交到队列的命令上 定义了一个执行依赖， 且定义了一个时间激发操作，将设置时间为已激发状态。

The first <<synchronization-dependencies-scopes, synchronization scope>>
includes every command previously submitted to the same queue, including
those in the same command buffer and batch.
The synchronization scope is limited to operations on the pipeline stages
determined by the <<synchronization-pipeline-stages-masks, source stage
mask>> specified by pname:stageMask.

The second <<synchronization-dependencies-scopes, synchronization scope>>
includes only the event signal operation.

若在GPU执行 flink:vkCmdSetEvent 时， pname:event 已经处于激发状态，那么flink:vkCmdSetEvent 没有任何作用，将不会导致任何事件激发操作，
不会生成执行依赖。

.正确使用
****
  * pname:stageMask must: not include ename:VK_PIPELINE_STAGE_HOST_BIT
  * If the <<features-features-geometryShader, 几何着色器>> feature is
    not enabled, pname:stageMask must: not contain
    ename:VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT
  * If the <<features-features-tessellationShader, 细分着色器>>
    feature is not enabled, pname:stageMask must: not contain
    ename:VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT or
    ename:VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT
****

include::../validity/protos/vkCmdSetEvent.txt[]

[[synchronization-events-unsignaling-device]]
// refBegin vkCmdResetEvent Reset an event object to non-signaled state


可使用如下命令在GPU端 设置事件为未激发状态：

include::../api/protos/vkCmdResetEvent.txt[]

  * pname:commandBuffer 是命令被记录所在的命令缓冲区。
  * pname:event 是需被被设置为为激发状态的事件。
  * pname:stageMask 指定了 用来决定何时取消激发 pname:event 的 <<synchronization-pipeline-stages,源阶段掩码>>。

When flink:vkCmdResetEvent is submitted to a queue, it defines an execution
dependency on commands that were submitted before it, and defines an event
unsignal operation which resets the event to the unsignaled state.

The first <<synchronization-dependencies-scopes, synchronization scope>>
includes every command previously submitted to the same queue, including
those in the same command buffer and batch.
The synchronization scope is limited to operations on the pipeline stages
determined by the <<synchronization-pipeline-stages-masks, source stage
mask>> specified by pname:stageMask.

The second <<synchronization-dependencies-scopes, synchronization scope>>
includes only the event unsignal operation.

If pname:event is already in the unsignaled state when flink:vkCmdResetEvent
is executed on the device, then flink:vkCmdResetEvent has no effect, no
event unsignal operation occurs, and no execution dependency is generated.

.正确使用
****
  * pname:stageMask must: not include ename:VK_PIPELINE_STAGE_HOST_BIT
  * If the <<features-features-geometryShader, 几何着色器>> feature is
    not enabled, pname:stageMask must: not contain
    ename:VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT
  * If the <<features-features-tessellationShader, 细分着色器>>
    feature is not enabled, pname:stageMask must: not contain
    ename:VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT or
    ename:VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT
  * When this command executes, pname:event must: not be waited on by a
    fname:vkCmdWaitEvents command that is currently executing
****

include::../validity/protos/vkCmdResetEvent.txt[]

// refBegin vkCmdWaitEvents Wait for one or more events and insert a set of memory

可调用如下命令来在一个设备上等待一个或者多个事件进入激发状态：

[[synchronization-events-waiting-device]]
include::../api/protos/vkCmdWaitEvents.txt[]

  * pname:commandBuffer是命令被记录所在的命令缓冲区。
  * pname:eventCount 是数组pname:pEvents array的长度。
  * pname:pEvents 是需要被等待的事件对象handle的数组。
  * pname:srcStageMask is the <<synchronization-pipeline-stages, source
    stage mask>>
  * pname:dstStageMask is the <<synchronization-pipeline-stages, destination
    stage mask>>.
  * pname:memoryBarrierCount is the length of the pname:pMemoryBarriers
    array.
  * pname:pMemoryBarriers is a pointer to an array of slink:VkMemoryBarrier
    structures.
  * pname:bufferMemoryBarrierCount is the length of the
    pname:pBufferMemoryBarriers array.
  * pname:pBufferMemoryBarriers is a pointer to an array of
    slink:VkBufferMemoryBarrier structures.
  * pname:imageMemoryBarrierCount is the length of the
    pname:pImageMemoryBarriers array.
  * pname:pImageMemoryBarriers is a pointer to an array of
    slink:VkImageMemoryBarrier structures.

当 fname:vkCmdWaitEvents 被提交到队列，它在之前的事件激发操作与稍后的命令之间 定义了一个内存依赖。 

The first synchronization scope only includes event signal operations that
operate on members of pname:pEvents, and the operations that happened-before
the event signal operations.
Event signal operations performed by flink:vkCmdSetEvent that were
previously submitted to the same queue are included in the first
synchronization scope, if the <<synchronization-pipeline-stages-order,
logically latest>> pipeline stage in their pname:stageMask parameter is
<<synchronization-pipeline-stages-order, logically earlier>> than or equal
to the <<synchronization-pipeline-stages-order, logically latest>> pipeline
stage in pname:srcStageMask.
Event signal operations performed by flink:vkSetEvent are only included in
the first synchronization scope if ename:VK_PIPELINE_STAGE_HOST_BIT is
included in pname:srcStageMask.

The second <<synchronization-dependencies-scopes, synchronization scope>>
includes commands subsequently submitted to the same queue, including those
in the same command buffer and batch.
The second synchronization scope is limited to operations on the pipeline
stages determined by the <<synchronization-pipeline-stages-masks,
destination stage mask>> specified by pname:dstStageMask.

The first <<synchronization-dependencies-access-scopes, access scope>> is
limited to access in the pipeline stages determined by the
<<synchronization-pipeline-stages-masks, source stage mask>> specified by
pname:srcStageMask.
Within that, the first access scope only includes the first access scopes
defined by elements of the pname:pMemoryBarriers,
pname:pBufferMemoryBarriers and pname:pImageMemoryBarriers arrays, which
each define a set of <<synchronization-memory-barriers, memory barriers>>.
If no memory barriers are specified, then the first access scope includes no
accesses.

The second <<synchronization-dependencies-access-scopes, access scope>> is
limited to access in the pipeline stages determined by the
<<synchronization-pipeline-stages-masks, destination stage mask>> specified
by pname:dstStageMask.
Within that, the second access scope only includes the second access scopes
defined by elements of the pname:pMemoryBarriers,
pname:pBufferMemoryBarriers and pname:pImageMemoryBarriers arrays, which
each define a set of <<synchronization-memory-barriers, memory barriers>>.
If no memory barriers are specified, then the second access scope includes
no accesses.

[NOTE]
.注意
====
flink:vkCmdWaitEvents is used with flink:vkCmdSetEvent to define a memory
dependency between two sets of action commands, roughly in the same way as
pipeline barriers, but split into two commands such that work between the
two may: execute unhindered.
====

[NOTE]
.注意
====
Applications should: be careful to avoid race conditions when using events.
There is no direct ordering guarantee between a flink:vkCmdResetEvent
command and a flink:vkCmdWaitEvents command submitted after it, so some
other execution dependency must: be included between these commands (e.g. a
semaphore).
====

.正确使用
****
  * pname:srcStageMask must: be the bitwise OR of the pname:stageMask
    parameter used in previous calls to fname:vkCmdSetEvent with any of the
    members of pname:pEvents and ename:VK_PIPELINE_STAGE_HOST_BIT if any of
    the members of pname:pEvents was set using fname:vkSetEvent
  * If the <<features-features-geometryShader, 几何着色器>> feature is
    not enabled, pname:srcStageMask must: not contain
    ename:VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT
  * If the <<features-features-geometryShader, 几何着色器>> feature is
    not enabled, pname:dstStageMask must: not contain
    ename:VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT
  * If the <<features-features-tessellationShader,  细分着色器>>
    feature is not enabled, pname:srcStageMask must: not contain
    ename:VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT or
    ename:VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT
  * If the <<features-features-tessellationShader, 细分着色器>>
    feature is not enabled, pname:dstStageMask must: not contain
    ename:VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT or
    ename:VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT
  * If pname:pEvents includes one or more events that will be signaled by
    fname:vkSetEvent after pname:commandBuffer has been submitted to a
    queue, then fname:vkCmdWaitEvents must: not be called inside a render
    pass instance
  * Any pipeline stage included in pname:srcStageMask or pname:dstStageMask
    must: be supported by the capabilities of the queue family specified by
    the pname:queueFamilyIndex member of the slink:VkCommandPoolCreateInfo
    structure that was used to create the sname:VkCommandPool that
    pname:commandBuffer was allocated from, as specified in the
    <<synchronization-pipeline-stages-supported, table of supported pipeline
    stages>>.
  * Any given element of pname:pMemoryBarriers, pname:pBufferMemoryBarriers
    or pname:pImageMemoryBarriers must: not have any access flag included in
    its pname:srcAccessMask member if that bit is not supported by any of
    the pipeline stages in pname:srcStageMask, as specified in the
    <<synchronization-access-types-supported, table of supported access
    types>>.
  * Any given element of pname:pMemoryBarriers, pname:pBufferMemoryBarriers
    or pname:pImageMemoryBarriers must: not have any access flag included in
    its pname:dstAccessMask member if that bit is not supported by any of
    the pipeline stages in pname:dstStageMask, as specified in the
    <<synchronization-access-types-supported, table of supported access
    types>>.
****

include::../validity/protos/vkCmdWaitEvents.txt[]


[[synchronization-pipeline-barriers]]
== 管线屏障

flink:vkCmdPipelineBarrier 是一个同步命令，它在提交到同一个队列的不同命令之间插入一个依赖，或者在同一个subpass内的不同命令之间插入一个依赖。

// refBegin vkCmdPipelineBarrier Insert a memory dependency

可调用如下命令来记录一个管线屏障：

include::../api/protos/vkCmdPipelineBarrier.txt[]

  * pname:commandBuffer 是命令被记录所在的命令缓冲区。
  * pname:srcStageMask 定义了一个 <<synchronization-pipeline-stages-masks, 源阶段掩码>>。
  * pname:dstStageMask 定义了一个 <<synchronization-pipeline-stages-masks, 目标阶段掩码>>。
  * pname:dependencyFlags is a bitmask of elink:VkDependencyFlagBits.
    The bits that can: be included in pname:dependencyFlags are:
+
--
// refBegin VkDependencyFlagBits Bitmask specifying how execution and memory dependencies are formed
include::../api/enums/VkDependencyFlagBits.txt[]
--
  ** ename:VK_DEPENDENCY_BY_REGION_BIT signifies that dependencies will be
     <<synchronization-framebuffer-regions, framebuffer-local>>.

  * pname:memoryBarrierCount 是数组 pname:pMemoryBarriers的长度。
  * pname:pMemoryBarriers 是一个指针，指向一个slink:VkMemoryBarrier 数据类型的数组。
  * pname:bufferMemoryBarrierCount 是数组 pname:pBufferMemoryBarriers 的长度。
  * pname:pBufferMemoryBarriers 是一个指针，指向一个 slink:VkBufferMemoryBarrier 数据类型的数组。
  * pname:imageMemoryBarrierCount 是数组 pname:pImageMemoryBarriers 的长度。
  * pname:pImageMemoryBarriers 是一个指针，指向一个slink:VkImageMemoryBarrier 数据类型的数组。

当 flink:vkCmdPipelineBarrier 被提交到队列，它在命令被提交到队列之前与之后的命令之间 定义了一个内存依赖。

If flink:vkCmdPipelineBarrier was recorded outside a render pass instance,
the first <<synchronization-dependencies-scopes, synchronization scope>>
includes every command submitted to the same queue before it, including
those in the same command buffer and batch.
If flink:vkCmdPipelineBarrier was recorded inside a render pass instance,
the first synchronization scope includes only commands submitted before it
within the same subpass.
In either case, the first synchronization scope is limited to operations on
the pipeline stages determined by the
<<synchronization-pipeline-stages-masks, source stage mask>> specified by
pname:srcStageMask.

If flink:vkCmdPipelineBarrier was recorded outside a render pass instance,
the second <<synchronization-dependencies-scopes, synchronization scope>>
includes every command submitted to the same queue after it, including those
in the same command buffer and batch.
If flink:vkCmdPipelineBarrier was recorded inside a render pass instance,
the second synchronization scope includes only commands submitted after it
within the same subpass.
In either case, the second synchronization scope is limited to operations on
the pipeline stages determined by the
<<synchronization-pipeline-stages-masks, destination stage mask>> specified
by pname:dstStageMask.

The first <<synchronization-dependencies-access-scopes, access scope>> is
limited to access in the pipeline stages determined by the
<<synchronization-pipeline-stages-masks, source stage mask>> specified by
pname:srcStageMask.
Within that, the first access scope only includes the first access scopes
defined by elements of the pname:pMemoryBarriers,
pname:pBufferMemoryBarriers and pname:pImageMemoryBarriers arrays, which
each define a set of <<synchronization-memory-barriers, memory barriers>>.
If no memory barriers are specified, then the first access scope includes no
accesses.

The second <<synchronization-dependencies-access-scopes, access scope>> is
limited to access in the pipeline stages determined by the
<<synchronization-pipeline-stages-masks, destination stage mask>> specified
by pname:dstStageMask.
Within that, the second access scope only includes the second access scopes
defined by elements of the pname:pMemoryBarriers,
pname:pBufferMemoryBarriers and pname:pImageMemoryBarriers arrays, which
each define a set of <<synchronization-memory-barriers, memory barriers>>.
If no memory barriers are specified, then the second access scope includes
no accesses.

If pname:dependencyFlags includes ename:VK_DEPENDENCY_BY_REGION_BIT, then
any dependency between <<synchronization-framebuffer-regions,
framebuffer-space>> pipeline stages is
<<synchronization-framebuffer-regions, framebuffer-local>> - otherwise it is
<<synchronization-framebuffer-regions, framebuffer-global>>.

.正确使用
****
  * 若  <<features-features-geometryShader, 几何着色器>> 特性没有被启用，pname:srcStageMask 必须: 不能包含 ename:VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT
  * 若 <<features-features-geometryShader,几何着色器>> 特性没有被启用， pname:dstStageMask 必须: 不能包含 ename:VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT
  * 若 <<features-features-tessellationShader,  细分着色器>> 特性没有被启用，pname:srcStageMask必须: 不能包含 ename:VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT或者
    ename:VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT
  * 若 <<features-features-tessellationShader,  细分着色器>>特性没有被启用，pname:dstStageMask 必须: 不能包含 ename:VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT 或者
    ename:VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT
  * 若 fname:vkCmdPipelineBarrier 在一个render pass实例内被调用， 此 render pass 在创建时必须: 与当前subpass自身存在一个 sname:VkSubpassDependency 
    另外:
  ** pname:srcStageMask must: contain a subset of the bit values in the
     pname:srcStageMask member of that instance of sname:VkSubpassDependency
  ** pname:dstStageMask must: contain a subset of the bit values in the
     pname:dstStageMask member of that instance of sname:VkSubpassDependency
  ** The pname:srcAccessMask of any element of pname:pMemoryBarriers or
     pname:pImageMemoryBarriers must: contain a subset of the bit values the
     pname:srcAccessMask member of that instance of
     sname:VkSubpassDependency
  ** The pname:dstAccessMask of any element of pname:pMemoryBarriers or
     pname:pImageMemoryBarriers must: contain a subset of the bit values the
     pname:dstAccessMask member of that instance of
     sname:VkSubpassDependency
  ** pname:dependencyFlags must: be equal to the pname:dependencyFlags
     member of that instance of sname:VkSubpassDependency
  * If fname:vkCmdPipelineBarrier is called within a render pass instance,
    pname:bufferMemoryBarrierCount must: be `0`
  * If fname:vkCmdPipelineBarrier is called within a render pass instance,
    the pname:image member of any element of pname:pImageMemoryBarriers
    must: be equal to one of the elements of pname:pAttachments that the
    current pname:framebuffer was created with, that is also referred to by
    one of the elements of the pname:pColorAttachments,
    pname:pResolveAttachments or pname:pDepthStencilAttachment members of
    the sname:VkSubpassDescription instance that the current subpass was
    created with
  * If fname:vkCmdPipelineBarrier is called within a render pass instance,
    the pname:oldLayout and pname:newLayout members of any element of
    pname:pImageMemoryBarriers must: be equal to the pname:layout member of
    an element of the pname:pColorAttachments, pname:pResolveAttachments or
    pname:pDepthStencilAttachment members of the sname:VkSubpassDescription
    instance that the current subpass was created with, that refers to the
    same pname:image
  * If fname:vkCmdPipelineBarrier is called within a render pass instance,
    the pname:oldLayout and pname:newLayout members of an element of
    pname:pImageMemoryBarriers must: be equal
  * If fname:vkCmdPipelineBarrier is called within a render pass instance,
    the pname:srcQueueFamilyIndex and pname:dstQueueFamilyIndex members of
    any element of pname:pImageMemoryBarriers must: be
    ename:VK_QUEUE_FAMILY_IGNORED
  * Any pipeline stage included in pname:srcStageMask or pname:dstStageMask
    must: be supported by the capabilities of the queue family specified by
    the pname:queueFamilyIndex member of the slink:VkCommandPoolCreateInfo
    structure that was used to create the sname:VkCommandPool that
    pname:commandBuffer was allocated from, as specified in the
    <<synchronization-pipeline-stages-supported, table of supported pipeline
    stages>>.
  * Any given element of pname:pMemoryBarriers, pname:pBufferMemoryBarriers
    or pname:pImageMemoryBarriers must: not have any access flag included in
    its pname:srcAccessMask member if that bit is not supported by any of
    the pipeline stages in pname:srcStageMask, as specified in the
    <<synchronization-access-types-supported, table of supported access
    types>>.
  * Any given element of pname:pMemoryBarriers, pname:pBufferMemoryBarriers
    or pname:pImageMemoryBarriers must: not have any access flag included in
    its pname:dstAccessMask member if that bit is not supported by any of
    the pipeline stages in pname:dstStageMask, as specified in the
    <<synchronization-access-types-supported, table of supported access
    types>>.
****

include::../validity/protos/vkCmdPipelineBarrier.txt[]


[[synchronization-pipeline-barriers-subpass-self-dependencies]]
=== Subpass Self-dependency

If fname:vkCmdPipelineBarrier is called inside a render pass instance, the
following restrictions apply.
For a given subpass to allow a pipeline barrier, the render pass must:
declare a _self-dependency_ from that subpass to itself.
That is, there must: exist a sname:VkSubpassDependency in the subpass
dependency list for the render pass with pname:srcSubpass and
pname:dstSubpass equal to that subpass index.
More than one self-dependency can: be declared for each subpass.
Self-dependencies must: only include pipeline stage bits that are graphics
stages.
Self-dependencies must: not have any earlier pipeline stages depend on any
later pipeline stages.
More precisely, this means that whatever is the last pipeline stage in
pname:srcStageMask must: be no later than whatever is the first pipeline
stage in pname:dstStageMask (the latest source stage can: be equal to the
earliest destination stage).
If the source and destination stage masks both include framebuffer-space
stages, then pname:dependencyFlags must: include
ename:VK_DEPENDENCY_BY_REGION_BIT.

A fname:vkCmdPipelineBarrier command inside a render pass instance must: be
a _subset_ of one of the self-dependencies of the subpass it is used in,
meaning that the stage masks and 访问掩码 must: each include only a
subset of the bits of the corresponding mask in that self-dependency.
If the self-dependency has ename:VK_DEPENDENCY_BY_REGION_BIT set, then so
must: the pipeline barrier.
Pipeline barriers within a render pass instance can: only be types
sname:VkMemoryBarrier or sname:VkImageMemoryBarrier.
If a sname:VkImageMemoryBarrier is used, the image and image subresource
range specified in the barrier must: be a subset of one of the image views
used by the framebuffer in the current subpass.
Additionally, pname:oldLayout must: be equal to pname:newLayout, and both
the pname:srcQueueFamilyIndex and pname:dstQueueFamilyIndex must: be
ename:VK_QUEUE_FAMILY_IGNORED.


[[synchronization-memory-barriers]]
== 内存屏障

_Memory barriers_ are used to explicitly control access to buffer and image
subresource ranges.
Memory barriers are used to <<synchronization-queue-transfers, transfer
ownership between queue families>>,
<<synchronization-image-layout-transitions, change image layouts>>, and
define <<synchronization-dependencies-available-and-visible, availability
and visibility operations>>.
They explicitly define the <<synchronization-access-types, access types>>
and buffer and image subresource ranges that are included in the
<<synchronization-dependencies-access-scopes, access scopes>> of a memory
dependency that is created by a synchronization command that includes them.

[[synchronization-global-memory-barriers]]
=== Global Memory Barriers

Global memory barriers apply to memory accesses involving all memory objects
that exist at the time of its execution.

// refBegin VkMemoryBarrier Structure specifying a global memory barrier

sname:VkMemoryBarrier 类型数据结构定义如下：

include::../api/structs/VkMemoryBarrier.txt[]

  * pname:sType 是数据结构的类型。
  * pname:pNext 是 `NULL` 或者一个指向拓展特定的数据结构的指针。
  * pname:srcAccessMask 定义了一个 <<synchronization-access-masks, 源访问掩码>>.
  * pname:dstAccessMask 定义了一个<<synchronization-access-masks, 目标访问掩码>>.

The first <<synchronization-dependencies-access-scopes, access scope>> is
limited to access types in the <<synchronization-access-masks, source access
mask>> specified by pname:srcAccessMask.

The second <<synchronization-dependencies-access-scopes, access scope>> is
limited to access types in the <<synchronization-access-masks, 目标访问掩码>> specified by pname:dstAccessMask.

include::../validity/structs/VkMemoryBarrier.txt[]



[[synchronization-buffer-memory-barriers]]
=== 缓冲区内存屏障

Buffer memory barriers only apply to memory accesses involving a specific
buffer range.
That is, a memory dependency formed from an buffer memory barrier is
<<synchronization-dependencies-access-scopes, scoped>> to access via the
specified buffer range.
Buffer memory barriers can: also be used to define a
<<synchronization-queue-transfers, queue family ownership transfer>> for the
specified buffer range.

// refBegin VkBufferMemoryBarrier Structure specifying a buffer memory barrier

sname:VkBufferMemoryBarrier 类型数据结构定义如下：

include::../api/structs/VkBufferMemoryBarrier.txt[]

  * pname:sType 是数据结构的类型。
  * pname:pNext 是 `NULL` 或者一个指向拓展特定的数据结构的指针。
  * pname:srcAccessMask 定义了一个 <<synchronization-access-masks, 源访问掩码>>.
  * pname:dstAccessMask 定义了一个<<synchronization-access-masks, 目标访问掩码>>.
  * pname:srcQueueFamilyIndex is the source queue family for a
    <<synchronization-queue-transfers, queue family ownership transfer>>.
  * pname:dstQueueFamilyIndex is the destination queue family for a
    <<synchronization-queue-transfers, queue family ownership transfer>>.
  * pname:buffer is a handle to the buffer whose backing memory is affected
    by the barrier.
  * pname:offset is an offset in bytes into the backing memory for
    pname:buffer; this is relative to the base offset as bound to the buffer
    (see flink:vkBindBufferMemory).
  * pname:size is a size in bytes of the affected area of backing memory for
    pname:buffer, or ename:VK_WHOLE_SIZE to use the range from pname:offset
    to the end of the buffer.

The first <<synchronization-dependencies-access-scopes, access scope>> is
limited to access to memory through the specified buffer range, via access
types in the <<synchronization-access-masks, 源访问掩码>> specified
by pname:srcAccessMask.
If pname:srcAccessMask includes ename:VK_ACCESS_HOST_WRITE_BIT, memory
writes performed by that access type are also made visible, as that access
type is not performed through a resource.

The second <<synchronization-dependencies-access-scopes, access scope>> is
limited to access to memory through the specified buffer range, via access
types in the <<synchronization-access-masks, 目标访问掩码>>
specified by pname:dstAccessMask.
If pname:dstAccessMask includes ename:VK_ACCESS_HOST_WRITE_BIT or
ename:VK_ACCESS_HOST_READ_BIT, available memory writes are also made visible
to accesses of those types, as those access types are not performed through
a resource.

If pname:srcQueueFamilyIndex is not equal to pname:dstQueueFamilyIndex, and
pname:srcQueueFamilyIndex is equal to the current queue family, then the
memory barrier defines a <<synchronization-queue-transfers-release, queue
family release operation>> for the specified buffer range, and the second
access scope includes no access, as if pname:dstAccessMask was `0`.

If pname:dstQueueFamilyIndex is not equal to pname:srcQueueFamilyIndex, and
pname:dstQueueFamilyIndex is equal to the current queue family, then the
memory barrier defines a <<synchronization-queue-transfers-acquire, queue
family acquire operation>> for the specified buffer range, and the first
access scope includes no access, as if pname:srcAccessMask was `0`.

.正确使用
****
  * pname:offset must: be less than the size of pname:buffer
  * If pname:size is not equal to ename:VK_WHOLE_SIZE, pname:size must: be
    greater than `0`
  * If pname:size is not equal to ename:VK_WHOLE_SIZE, pname:size must: be
    less than or equal to than the size of pname:buffer minus pname:offset
  * If pname:buffer was created with a sharing mode of
    ename:VK_SHARING_MODE_CONCURRENT, pname:srcQueueFamilyIndex and
    pname:dstQueueFamilyIndex must: both be ename:VK_QUEUE_FAMILY_IGNORED
  * If pname:buffer was created with a sharing mode of
    ename:VK_SHARING_MODE_EXCLUSIVE, pname:srcQueueFamilyIndex and
    pname:dstQueueFamilyIndex must: either both be
    ename:VK_QUEUE_FAMILY_IGNORED, or both be a valid queue family (see
    <<devsandqueues-queueprops>>)
  * If pname:buffer was created with a sharing mode of
    ename:VK_SHARING_MODE_EXCLUSIVE, and pname:srcQueueFamilyIndex and
    pname:dstQueueFamilyIndex are valid queue families, at least one of them
    must: be the same as the family of the queue that will execute this
    barrier
****

include::../validity/structs/VkBufferMemoryBarrier.txt[]


[[synchronization-image-memory-barriers]]
=== 图像内存屏障

Image memory barriers only apply to memory accesses involving a specific
image subresource range.
That is, a memory dependency formed from an image memory barrier is
<<synchronization-dependencies-access-scopes, scoped>> to access via the
specified image subresource range.
Image memory barriers can: also be used to define
<<synchronization-image-layout-transitions, image layout transitions>> or a
<<synchronization-queue-transfers, queue family ownership transfer>> for the
specified image subresource range.

// refBegin VkImageMemoryBarrier Structure specifying the parameters of an image memory barrier

sname:VkImageMemoryBarrier 类型数据结构定义如下：

include::../api/structs/VkImageMemoryBarrier.txt[]

  * pname:sType 是数据结构的类型。
  * pname:pNext 是 `NULL` 或者一个指向拓展特定的数据结构的指针。
  * pname:srcAccessMask  定义了一个 <<synchronization-access-masks, 源访问掩码>>.
  * pname:dstAccessMask  定义了一个<<synchronization-access-masks, 目标访问掩码>>.
  * pname:oldLayout is the old layout in an
    <<synchronization-image-layout-transitions, image layout transition>>.
  * pname:newLayout is the new layout in an
    <<synchronization-image-layout-transitions, image layout transition>>.
  * pname:srcQueueFamilyIndex is the source queue family for a
    <<synchronization-queue-transfers, queue family ownership transfer>>.
  * pname:dstQueueFamilyIndex is the destination queue family for a
    <<synchronization-queue-transfers, queue family ownership transfer>>.
  * pname:image is a handle to the image affected by this barrier.
  * pname:subresourceRange describes the <<resources-image-views, image
    subresource range>> within pname:image that is affected by this barrier.

The first <<synchronization-dependencies-access-scopes, access scope>> is
limited to access to memory through the specified image subresource range,
via access types in the <<synchronization-access-masks, 源访问掩码>>
specified by pname:srcAccessMask.
If pname:srcAccessMask includes ename:VK_ACCESS_HOST_WRITE_BIT, memory
writes performed by that access type are also made visible, as that access
type is not performed through a resource.

The second <<synchronization-dependencies-access-scopes, access scope>> is
limited to access to memory through the specified image subresource range,
via access types in the <<synchronization-access-masks, destination access
mask>> specified by pname:dstAccessMask.
If pname:dstAccessMask includes ename:VK_ACCESS_HOST_WRITE_BIT or
ename:VK_ACCESS_HOST_READ_BIT, available memory writes are also made visible
to accesses of those types, as those access types are not performed through
a resource.

If pname:srcQueueFamilyIndex is not equal to pname:dstQueueFamilyIndex, and
pname:srcQueueFamilyIndex is equal to the current queue family, then the
memory barrier defines a <<synchronization-queue-transfers-release, queue
family release operation>> for the specified image subresource range, and
the second access scope includes no access, as if pname:dstAccessMask was
`0`.

If pname:dstQueueFamilyIndex is not equal to pname:srcQueueFamilyIndex, and
pname:dstQueueFamilyIndex is equal to the current queue family, then the
memory barrier defines a <<synchronization-queue-transfers-acquire, queue
family acquire operation>> for the specified image subresource range, and
the first access scope includes no access, as if pname:srcAccessMask was
`0`.

If pname:oldLayout is not equal to pname:newLayout, then the memory barrier
defines an <<synchronization-image-layout-transitions, image layout
transition>> for the specified image subresource range.

[[synchronization-image-barrier-layout-transition-order]]
Layout transitions that are performed via image memory barriers execute in
their entirety in <<synchronization-submission-order, submission order>>,
relative to other image layout transitions submitted to the same queue,
including those performed by <<renderpass, render passes>>.
In effect there is an implicit execution dependency from each such layout
transition to all layout transitions previously submitted to the same queue.

.正确使用
****
  * pname:oldLayout must: be ename:VK_IMAGE_LAYOUT_UNDEFINED or the current
    layout of the image subresources affected by the barrier
  * pname:newLayout must: not be ename:VK_IMAGE_LAYOUT_UNDEFINED or
    ename:VK_IMAGE_LAYOUT_PREINITIALIZED
  * If pname:image was created with a sharing mode of
    ename:VK_SHARING_MODE_CONCURRENT, pname:srcQueueFamilyIndex and
    pname:dstQueueFamilyIndex must: both be ename:VK_QUEUE_FAMILY_IGNORED
  * If pname:image was created with a sharing mode of
    ename:VK_SHARING_MODE_EXCLUSIVE, pname:srcQueueFamilyIndex and
    pname:dstQueueFamilyIndex must: either both be
    ename:VK_QUEUE_FAMILY_IGNORED, or both be a valid queue family (see
    <<devsandqueues-queueprops>>)
  * If pname:image was created with a sharing mode of
    ename:VK_SHARING_MODE_EXCLUSIVE, and pname:srcQueueFamilyIndex and
    pname:dstQueueFamilyIndex are valid queue families, at least one of them
    must: be the same as the family of the queue that will execute this
    barrier
  * pname:subresourceRange must: be a valid image subresource range for the
    image (see <<resources-image-views>>)
  * If pname:image has a depth/stencil format with both depth and stencil
    components, then pname:aspectMask member of pname:subresourceRange must:
    include both ename:VK_IMAGE_ASPECT_DEPTH_BIT and
    ename:VK_IMAGE_ASPECT_STENCIL_BIT
  * If either pname:oldLayout or pname:newLayout is
    ename:VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL then pname:image must:
    have been created with ename:VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT set
  * If either pname:oldLayout or pname:newLayout is
    ename:VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL then pname:image
    must: have been created with
    ename:VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT set
  * If either pname:oldLayout or pname:newLayout is
    ename:VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL then pname:image
    must: have been created with
    ename:VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT set
  * If either pname:oldLayout or pname:newLayout is
    ename:VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL then pname:image must:
    have been created with ename:VK_IMAGE_USAGE_SAMPLED_BIT or
    ename:VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT set
  * If either pname:oldLayout or pname:newLayout is
    ename:VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL then pname:image must: have
    been created with ename:VK_IMAGE_USAGE_TRANSFER_SRC_BIT set
  * If either pname:oldLayout or pname:newLayout is
    ename:VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL then pname:image must: have
    been created with ename:VK_IMAGE_USAGE_TRANSFER_DST_BIT set
****

include::../validity/structs/VkImageMemoryBarrier.txt[]


[[synchronization-queue-transfers]]
=== 队列族主权转移

Resources created with a elink:VkSharingMode of
ename:VK_SHARING_MODE_EXCLUSIVE must: have their ownership explicitly
transferred from one queue family to another in order to access their
content in a well-defined manner on a queue in a different queue family.
If memory dependencies are correctly expressed between uses of such a
resource between two queues in different families, but no ownership transfer
is defined, the contents of that resource are undefined for any read
accesses performed by the second queue family.

.注意
[NOTE]
====
If an application does not need the contents of a resource to remain valid
when transferring from one queue family to another, then the ownership
transfer should: be skipped.
====

A queue family ownership transfer consists of two distinct parts:

  . Release exclusive ownership from the source queue family
  . Acquire exclusive ownership for the destination queue family

An application must: ensure that these operations occur in the correct order
by defining an execution dependency between them, e.g. using a semaphore.

[[synchronization-queue-transfers-release]] A _release operation_ is used to
release exclusive ownership of a range of a buffer or image subresource
range.
A release operation is defined by executing a
<<synchronization-buffer-memory-barriers, buffer memory barrier>> (for a
buffer range) or an <<synchronization-image-memory-barriers, image memory
barrier>> (for an image subresource range), on a queue from the source queue
family.
The pname:srcQueueFamilyIndex parameter of the barrier must: be set to the
source queue family index, and the pname:dstQueueFamilyIndex parameter to
the destination queue family index.
pname:dstStageMask is ignored for such a barrier, such that no visibility
operation is executed - the value of this mask does not affect the validity
of the barrier.
The release operation happens-after the availability operation.

[[synchronization-queue-transfers-acquire]] An _acquire operation_ is used
to acquire exclusive ownership of a range of a buffer or image subresource
range.
An acquire operation is defined by executing a
<<synchronization-buffer-memory-barriers, buffer memory barrier>> (for a
buffer range) or an <<synchronization-image-memory-barriers, image memory
barrier>> (for an image subresource range), on a queue from the destination
queue family.
The pname:srcQueueFamilyIndex parameter of the barrier must: be set to the
source queue family index, and the pname:dstQueueFamilyIndex parameter to
the destination queue family index.
pname:srcStageMask is ignored for such a barrier, such that no availability
operation is executed - the value of this mask does not affect the validity
of the barrier.
The acquire operation happens-before the visibility operation.

.注意
[NOTE]
====
Whilst it is not invalid to provide destination or 源访问掩码 for
memory barriers used for release or acquire operations, respectively, they
have no practical effect.
Access after a release operation has undefined results, and so visibility
for those accesses has no practical effect.
Similarly, write access before an acquire operation will produce undefined
results for future access, so availability of those writes has no practical
use.
In an earlier version of the specification, these were required to match on
both sides - but this was subsequently relaxed.
It is now recommended that these masks are simply set to 0.
====

If the transfer is via an image memory barrier, and an
<<synchronization-image-layout-transitions, image layout transition>> is
desired, then the values of pname:oldLayout and pname:newLayout in the
release memory barrier must: be equal to values of pname:oldLayout and
pname:newLayout in the acquire memory barrier.
Although the image layout transition is submitted twice, it will only be
executed once.
A layout transition specified in this way happens-after the release
operation and happens-before the acquire operation.

If the values of pname:srcQueueFamilyIndex and pname:dstQueueFamilyIndex are
equal, no ownership transfer is performed, and the barrier operates as if
they were both set to ename:VK_QUEUE_FAMILY_IGNORED.

Queue family ownership transfers may: perform read and write accesses on all
memory bound to the image subresource or buffer range, so applications must:
ensure that all memory writes have been made
<<synchronization-dependencies-available-and-visible, available>> before a
queue family ownership transfer is executed.
Available memory is automatically made visible to queue family release and
acquire operations, and writes performed by those operations are
automatically made available.

Once a queue family has acquired ownership of a buffer range or image
subresource range of an ename:VK_SHARING_MODE_EXCLUSIVE resource, its
contents are undefined to other queue families unless ownership is
transferred.
The contents of any portion of another resource which aliases memory that is
bound to the transferred buffer or image subresource range are undefined
after a release or acquire operation.


[[synchronization-wait-idle]]
== 等待空闲操作

// refBegin vkQueueWaitIdle Wait for a queue to become idle

To wait on the host for the completion of outstanding queue operations for a
given queue, call:

include::../api/protos/vkQueueWaitIdle.txt[]

  * pname:queue 是等待行为所在的队列。

fname:vkQueueWaitIdle is equivalent to submitting a fence to a queue and
waiting with an infinite timeout for that fence to signal.

include::../validity/protos/vkQueueWaitIdle.txt[]

// refBegin vkDeviceWaitIdle Wait for a device to become idle

To wait on the host for the completion of outstanding queue operations for
all queues on a given logical device, call:

include::../api/protos/vkDeviceWaitIdle.txt[]

  * pname:device 是需要闲置的逻辑设备。

fname:vkDeviceWaitIdle is equivalent to calling fname:vkQueueWaitIdle for
all queues owned by pname:device.

include::../validity/protos/vkDeviceWaitIdle.txt[]


[[synchronization-submission-host-writes]]
== CPU端写入顺序保证

When batches of command buffers are submitted to a queue via
flink:vkQueueSubmit, it defines a memory dependency with prior host
operations, and execution of command buffers submitted to the queue.

The first <<synchronization-dependencies-scopes, synchronization scope>> is
defined by the host execution model, but includes execution of
flink:vkQueueSubmit on the host and anything that happened-before it.

The second <<synchronization-dependencies-scopes, synchronization scope>>
includes every command submitted in the same <<devsandqueues-submission,
queue submission>> command, and all future submissions to the same queue.

The first <<synchronization-dependencies-access-scopes, access scope>>
includes all host writes to mappable device memory that are either coherent,
or have been flushed with flink:vkFlushMappedMemoryRanges.

The second <<synchronization-dependencies-access-scopes, access scope>>
includes all memory access performed by the device.
