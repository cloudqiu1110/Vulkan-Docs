// Copyright (c) 2015-2017 The Khronos Group Inc.
// Copyright notice at https://www.khronos.org/registry/speccopyright.html

[[memory]]
= 内存分配

Vulkan 内存分为两类： _主机内存_ 和 _设备内存_ 。


[[memory-host]]
== 主机内存
主机内存是Vulkan实现需要的、设备不可见的内存。
这些内存可以用来存储软件内部数据。

[[memory-allocation]]
Vulkan给应用程序提供了代表Vulkan实现来操作主机内存分配的机会。
如果这个特征没有被使用，Vulkan实现将使用自己的内存分配函数。
因为大多数内存分配都不是在要求高性能代码区域的，这就不是一个提升性能的特征了。
相反，在一些嵌入式的平台上，这还是非常有用的，如为了调试（e.g. putting a guard page after all host allocations），
或者记录内存分配。

// refBegin VkAllocationCallbacks Structure containing callback function pointers for memory allocation

内存分配器是应用程序通过一个指向sname:VkAllocationCallbacks类型数据的指针来提供的。

include::../api/structs/VkAllocationCallbacks.txt[]

  * pname:pUserData 是由回调自行解释的值。当sname:VkAllocationCallbacks之中任何回调函数被调用，Vulkan实现将把这个值作为第一个参数传递给回调函数。
	每一次被传递到命令中，这个值都可以改变，甚至在多个命令中同一个对象带有的内存分配器。
  * pname:pfnAllocation 是一个指向应用程序定义的内存分配函数的指针，类型为tlink:PFN_vkAllocationFunction。
  * pname:pfnReallocation 是一个指向应用程序定义的内存重分配函数的指针，类型为tlink:PFN_vkReallocationFunction。
  * pname:pfnFree 是一个指向应用程序定义的内存释放函数，类型为tlink:PFN_vkFreeFunction。
  * pname:pfnInternalAllocation 是一个指向应用程序定义的函数的指针，当被Vulkan实现调用时，就进行内部内存分配，类型为  tlink:PFN_vkInternalAllocationNotification。
  * pname:pfnInternalFree 是一个指向应用程序定义的函数的指针，当被Vulkan实现调用时，就释放内部内存，类型为tlink:PFN_vkInternalFreeNotification。

.正确使用
****
  * pname:pfnAllocation 必须: 是一个有效的用户自定义的tlink:PFN_vkAllocationFunction 类型的函数指针。
  * pname:pfnReallocation 必须: 是一个指向有效的用户自定义的 tlink:PFN_vkReallocationFunction类型的函数指针。
  * pname:pfnFree 必须: 是一个指向有效的用户自定义的tlink:PFN_vkFreeFunction类型指针。 
  * 如果 pname:pfnInternalAllocation 或者 pname:pfnInternalFree 不为 `NULL`，那么两个都必须: 是有效的回调函数。
****

include::../validity/structs/VkAllocationCallbacks.txt[]

// refBegin PFN_vkAllocationFunction Application-defined memory allocation function

pname:pfnAllocation定义如下：

include::../api/funcpointers/PFN_vkAllocationFunction.txt[]

  * pname:pUserData 是由应用程序指定的内存分配器的slink:VkAllocationCallbacks::pname:pUserData 指定的。
  * pname:size 是要求分配的内存字节大小。
  * pname:alignment 是内存分配器要求的内存对齐的大小，以字节为单位，必须是2的幂。   
  * pname:allocationScope 是一个 elink:VkSystemAllocationScope 类型的值，指定了内存分配的生命周期，如  <<memory-host-allocation-scope, 这里>>所述。

[[vkAllocationFunction_return_rules]]
如果pname:pfnAllocation无法分配要求的内存，它必须返回 `NULL`。
如果分配成功，它必须返回包含至少 pname:size 字节内存的指针，且指针的数值必须是 pname:alignment的倍数。

[NOTE]
.注意
====
如果应用程序不遵守以下规则，就不能假定Vulkan会做正确的操作。

例如， pname:pfnAllocation（或者pname:pfnReallocation）在遇到
一次为了直接或者间接调试目的的内存分配失败时，能导致正在运行的Vulkan实例终止。
在这些情形下，不能假设受影响的VkInstance对象的任何部分将正常工作（甚至是flink:vkDestroyInstance），且应用程序
必须保证通过其他途径适当的做好清扫工作（比如进程终止）。
====

如果pname:pfnAllocation 返回`NULL`，且如果Vulkan实现因为没有获取要求的内存而不能正确的继续处理当前命令时，
Vulkan实现必须把这个当作是运行时错误，在合适的时候给发生这个状况的命令产生一个ename:VK_ERROR_OUT_OF_HOST_MEMORY错误，
如<<fundamentals-errorcodes, Return Codes>>中所描述。

如果Vulkan实现在没有获取到要求分配的内存时能够继续正确的处理当前命令，那么它不能
因这次内存分配失败而产生ename:VK_ERROR_OUT_OF_HOST_MEMORY。

// refEnd PFN_vkAllocationFunction VkAllocationCallbacks

// refBegin PFN_vkReallocationFunction Application-defined memory reallocation function

pname:pfnReallocation类型如下：

include::../api/funcpointers/PFN_vkReallocationFunction.txt[]

  * pname:pUserData 是由应用程序指定的内存分配器的slink:VkAllocationCallbacks::pname:pUserData 指定的。
  * pname:pOriginal 必须: 是 `NULL` 或者是 同一个内存分配器的pname:pfnReallocation 或者 pname:pfnAllocation 返回的指针。
  * pname:size 是要求分配的内存字节大小。
  * pname:alignment 是内存分配器要求的内存对齐的大小，以字节为单位，必须是2的幂。   
  * pname:allocationScope 是一个 elink:VkSystemAllocationScope 类型的值，指定了内存分配的生命周期，如  <<memory-host-allocation-scope, 这里>>所述。

pname:pfnReallocation必须: 返回pname:size 字节的内存，原内存的内容从zero 到 [eq]#min(original size, new size) - 1# 必须: 被保留在新分配的内存中。
如果 pname:size比原来的内存要大, 附加部分内存的内容是未定义的。
如果满足这些创建新内存的条件，那么原来分配的内存应被释放掉了。

若 pname:pOriginal 是 `NULL`, 那么 pname:pfnReallocation 必须: 表现的和以相同参数（除了pname:pOriginal）调用tlink:PFN_vkAllocationFunction 表现完全相同。

若 pname:size 为0, 那么 pname:pfnReallocation 必须: 表现的和以相同参数pname:pUserData，pname:pMemory 等同于pname:pOriginal来调用 tlink:PFN_vkFreeFunction 完全相同。 

若 pname:pOriginal 是 non-`NULL`, Vulkan实现必须 必须: 保证 pname:alignment 等于 分配pname:pOriginal时所用到的pname:alignment。

若这个函数调用失败，pname:pOriginal 是 non-`NULL`，应用程序不能: 释放掉原来的内存。

pname:pfnReallocation 必须: 符合<<vkAllocationFunction_return_rules, tname:PFN_vkAllocationFunction返回值的规则>>。

// refEnd PFN_vkReallocationFunction VkAllocationCallbacks

// refBegin PFN_vkFreeFunction Application-defined memory free function

pname:pfnFree 类型定义如下：

include::../api/funcpointers/PFN_vkFreeFunction.txt[]

  * pname:pUserData 是由应用程序指定的内存分配器的slink:VkAllocationCallbacks::pname:pUserData 指定的。
  * pname:pMemory 是需要被释放的内存。

pname:pMemory 可能: 是 `NULL`, 此时回调函数 必须: 谨慎的处理。
若 pname:pMemory 是 non-`NULL`, 它必须: 是一个指针，指向 pname:pfnAllocation 或 pname:pfnReallocation之前分配的内存。
应用程序 应该: 释放此内存。

// refEnd PFN_vkFreeFunction VkAllocationCallbacks

// refBegin PFN_vkInternalAllocationNotification Application-defined memory allocation notification function

pname:pfnInternalAllocation 类型定义如下:

include::../api/funcpointers/PFN_vkInternalAllocationNotification.txt[]

  * pname:pUserData 是由应用程序指定的内存分配器的slink:VkAllocationCallbacks::pname:pUserData 指定的。
  * pname:size 是要求分配的内存字节大小。
  * pname:allocationType 是要求的内存分配的类型。
  * pname:allocationScope 是一个 elink:VkSystemAllocationScope 类型的值，指定了内存分配的生命周期，如  <<memory-host-allocation-scope, 这里>>所述。

这是一个纯粹的查看信息的回调函数。

// refEnd PFN_vkInternalAllocationNotification VkAllocationCallbacks

// refBegin PFN_vkInternalFreeNotification Application-defined memory free notification function

pname:pfnInternalFree定义如下:

include::../api/funcpointers/PFN_vkInternalFreeNotification.txt[]

  * pname:pUserData 是由应用程序指定的内存分配器的slink:VkAllocationCallbacks::pname:pUserData 指定的。
  * pname:size 是要求分配的内存字节大小。
  * pname:allocationType 是要求的内存分配的类型。
  * pname:allocationScope 是一个 elink:VkSystemAllocationScope 类型的值，指定了内存分配的生命周期，如  <<memory-host-allocation-scope, 这里>>所述。

// refEnd PFN_vkInternalFreeNotification VkAllocationCallbacks

// refBegin VkSystemAllocationScope Allocation scope

[[memory-host-allocation-scope]]
每一份分配的内存都有 _分配存活期_ ，定义了它自己的生命周期和所关联对象。
内存存活期是通过传递给slink:VkAllocationCallbacks中定义的回调函数的pname:allocationScope 参数提供的。
elink:VkSystemAllocationScope 定义的可选的值如下:

include::../api/enums/VkSystemAllocationScope.txt[]

  * ename:VK_SYSTEM_ALLOCATION_SCOPE_COMMAND - The allocation is scoped to
    the duration of the Vulkan command.
  * ename:VK_SYSTEM_ALLOCATION_SCOPE_OBJECT - The allocation is scoped to
    the lifetime of the Vulkan object that is being created or used.
  * ename:VK_SYSTEM_ALLOCATION_SCOPE_CACHE - The allocation is scoped to the
    lifetime of a sname:VkPipelineCache object.
  * ename:VK_SYSTEM_ALLOCATION_SCOPE_DEVICE - The allocation is scoped to
    the lifetime of the Vulkan device.
  * ename:VK_SYSTEM_ALLOCATION_SCOPE_INSTANCE - The allocation is scoped to
    the lifetime of the Vulkan instance.

大多数Vulkan命令操作单个对象，或者创建、操控单一对象。当一份分配的内存使用 ename:VK_SYSTEM_ALLOCATION_SCOPE_OBJECT 或
ename:VK_SYSTEM_ALLOCATION_SCOPE_CACHE时，内存的存活范围就是被创建或操控的对象。

当Vulkan实现获取主机端内存时，它将回调应用程序提供的回调函数来使用特定的内存分配器和内存存活范围：

  * 若分配的内存生存周期限定于一个命令之内，内存分配器将使用  ename:VK_SYSTEM_ALLOCATION_SCOPE_COMMAND。
   若创建的、或者被操控的对象有对应的内存分配器，那么将使用该特定的内存分配器，否则若 父 sname:VkDevice 有内存分配器，便使用此内存分配器，否则便使用父 sname:VkInstance 拥有的内存分配器。
  * 若分配的内存与一个sname:VkPipelineCache 类型对象关联，内存分配器将使用 ename:VK_SYSTEM_ALLOCATION_SCOPE_CACHE 分配周期。
	最明确的内存分配器将会被使用（管线缓存、设备、实例）。否则，    
  * 若被分配的内存的生命周期跟随一个对象，该对象被该命令所创建或者操纵，对象类型不是 sname:VkDevice、sname:VkInstance，
	内存分配器将使用 ename:VK_SYSTEM_ALLOCATION_SCOPE_OBJECT 分配周期。
	最明确的内存分配器将会被使用（对象、设备、实例）。否则，   
  * 若被分配的内存的生命周期跟随一个设备的生命周期，内存分配器将使用 ename:VK_SYSTEM_ALLOCATION_SCOPE_DEVICE。
	最明确的内存分配器将会被使用（设备、实例）。否则，    
  * 若被分配的内存的生命周期跟随一个实例的生命周期，且这个实例有一个内存分配器，那么他的内存分配器将使用
	ename:VK_SYSTEM_ALLOCATION_SCOPE_INSTANCE 分配周期。
  * 否则，Vulkan事项将 使用未指定的一种替代策略来分配内存。

// refEnd VkSystemAllocationScope VkAllocationCallbacks

从缓存池中分配出来的对象并没有指定它们对应的内存分配器。
当Vulkan实现为此对象获取主机端内存时，内存是由父缓存池的内存分配器获取的。

不应期待应用程序会负责主机端执行代码时处理内存分配活动，因为多平台上Vulkan实现的负责的安全性问题。
Vulkan实现将在内部分配内存，当这些内存分配或释放时，调用通知性的回调函数告诉应用程序。
当分配这些可执行的内存时，pname:pfnInternalAllocation 将会被调用。
当释放这些可执行的内存时，pname:pfnInternalFree 将被调用。
当分配或释放这些可执行的内存时，Vulkan实现将只调用通知性的回调函数。

// refBegin VkInternalAllocationType Allocation type

传递给 pname:pfnInternalAllocation 和pname:pfnInternalFree 函数的pname:allocationType 参数 可能: 是如下值:

include::../api/enums/VkInternalAllocationType.txt[]

  * ename:VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE - 分配的内存是计划给CPU端使用的。

// refEnd VkInternalAllocationType PFN_vkInternalAllocationNotification PFN_vkInternalFreeNotification

Vulkan实现在API命令执行期间，只能调用应用程序在当前线程提供的分配函数。
Vulkan实现不应该同时调用这些回调函数。如果需要保持同步，回调函数应该自己实现。提供信息这一类的回调函数也和内存分配函数一样遵从此限制。

若Vulkan实现倾向于在ftext:vkCreate*命令返回和对应的 ftext:vkDestroy*命令开始之间通过sname:VkAllocationCallbacks 数据结构来进行函数调用，该Vulkan实现必须在ftext:vkCreate*返回之前保存一份内存分配器的copy。
它们依赖的回掉函数和任何数据结构都必须在与之关联的对象生命周期内都保持有效。

若给ftext:vkCreate*提供一个内存分配器，则必须要给对应的ftext:vkDestroy*命令提供一个兼容匹配的内存分配器。
若用pname:pfnAllocation or pname:pfnReallocation分配而来的内存都可以被pname:pfnReallocation or pname:pfnFree释放掉，
那么两个sname:VkAllocationCallbacks 数据结构必须兼容。
若没有给  ftext:vkCreate* 命令提供内存分配器，那么就不能给对应的 ftext:vkDestroy* 命令提供一个内存分配器。

若一个 非空 分配器被使用了，那么 pname:pfnAllocation，pname:pfnReallocation 和 pname:pfnFree 成员必须也是非空，
且指向一个有效的Vulkan实现规定的callback函数。
应用程序可以选择 设置 pname:pfnInternalAllocation 和 pname:pfnInternalFree为 `NULL` 而不提供callback函数。
pname:pfnInternalAllocation 和 pname:pfnInternalFree 必须俱为 `NULL` 或者俱为 non-`NULL`。

若pname:pfnAllocation 或者 pname:pfnReallocation 失败，Vulkan实现可能创建对象失败，产生一个
ename:VK_ERROR_OUT_OF_HOST_MEMORY 错误.

内存分配回调函数不能调用任何Vulkan命令。

如下规则集合定义了Vulkan实现何时被允许调用内存分配器回掉函数。

pname:pfnAllocation 或者 pname:pfnReallocation 可能在一下情形中被调用：

  * Allocations scoped to a sname:VkDevice or sname:VkInstance may: be
    allocated from any API command.
  * Allocations scoped to a command may: be allocated from any API command.
  * Allocations scoped to a sname:VkPipelineCache may: only be allocated
    from:
  ** fname:vkCreatePipelineCache
  ** fname:vkMergePipelineCaches for pname:dstCache
  ** fname:vkCreateGraphicsPipelines for pname:pPipelineCache
  ** fname:vkCreateComputePipelines for pname:pPipelineCache
  * Allocations scoped to a sname:VkDescriptorPool may: only be allocated
    from:
  ** any command that takes the pool as a direct argument
  ** fname:vkAllocateDescriptorSets for the pname:descriptorPool member of
    its pname:pAllocateInfo parameter
  ** fname:vkCreateDescriptorPool
  * Allocations scoped to a sname:VkCommandPool may: only be allocated from:
  ** any command that takes the pool as a direct argument
  ** fname:vkCreateCommandPool
  ** fname:vkAllocateCommandBuffers for the pname:commandPool member of its
     pname:pAllocateInfo parameter
  ** any ftext:vkCmd* command whose pname:commandBuffer was allocated from
     that sname:VkCommandPool
  * Allocations scoped to any other object may: only be allocated in that
    object's ftext:vkCreate* command.

pname:pfnFree  可能在一下情形中被调用：

  * Allocations scoped to a sname:VkDevice or sname:VkInstance may: be freed
    from any API command.
  * Allocations scoped to a command must: be freed by any API command which
    allocates such memory.
  * Allocations scoped to a sname:VkPipelineCache may: be freed from
    fname:vkDestroyPipelineCache.
  * Allocations scoped to a sname:VkDescriptorPool may: be freed from
  ** any command that takes the pool as a direct argument
  * Allocations scoped to a sname:VkCommandPool may: be freed from:
  ** any command that takes the pool as a direct argument
  ** fname:vkResetCommandBuffer whose pname:commandBuffer was allocated from
     that sname:VkCommandPool
  * Allocations scoped to any other object may: be freed in that object's
    ftext:vkDestroy* command.
  * Any command that allocates host memory may: also free host memory of the
    same scope.


[[memory-device]]
== 设备内存

设备内存是设备可见的内存，例如可以被设备原生访问的不透明图片的内容，或者常驻设备内存的统一缓冲区对象。

物理设备的内存属性描述了内存堆和可用的内存类型。

// refBegin vkGetPhysicalDeviceMemoryProperties Reports memory information for the specified physical device

可调用如下命令来查询内存属性：

include::../api/protos/vkGetPhysicalDeviceMemoryProperties.txt[]

  * pname:physicalDevice 是被查询内存所在的设备的handle。
  * pname:pMemoryProperties 指向sname:VkPhysicalDeviceMemoryProperties 类型的数据结构，属性信息由此返回。

include::../validity/protos/vkGetPhysicalDeviceMemoryProperties.txt[]

// refBegin VkPhysicalDeviceMemoryProperties Structure specifying physical device memory properties

sname:VkPhysicalDeviceMemoryProperties数据类型定义如下：

include::../api/structs/VkPhysicalDeviceMemoryProperties.txt[]

  * pname:memoryTypeCount 是pname:memoryTypes 数组中有效元素的个数。
  * pname:memoryTypes 是一个 slink:VkMemoryType 类型的数组，描述了 可以用来访问pname:memoryHeaps从堆上分配出来的内存的 _内存类型_。
  * pname:memoryHeapCount 是 pname:memoryHeaps 数组中有效元素的个数。
  * pname:memoryHeaps 是一个 slink:VkMemoryHeap 数组，描述了 _memory heaps_ ，可以从它分配内存。

sname:VkPhysicalDeviceMemoryProperties 类型数据结构描述了多个 _memory heaps_ 和一系列 _memory types_ ，用这些type参数可以访问到从堆分配出来的内存。
每一个堆描述了特定大小的内存资源，每一个内存类型描述了内存的属性（例如，主机端缓存 vs 未缓存），属性需应用到内存堆上。
用特定内存类型分配内存将从 内存类型的堆索引表示的堆 中消耗资源。
多个内存类型可能共享一个内存对，堆和内存类型提供了一种机制，来通知物理内存资源的准确大小，且允许内存被用作各种用途。

内存堆的个数由 pname:memoryHeapCount 给出，比ename:VK_MAX_MEMORY_HEAPS 要小。
每一个堆通过pname:memoryHeaps 数组中的一个元素（sname:VkMemoryHeap类型）来描述。
各个内存堆中可用的可用类型的个数由pname:memoryTypeCount 给出，不大于ename:VK_MAX_MEMORY_TYPES。
每一个内存类型通过pname:memoryTypes数组的一个元素（ sname:VkMemoryType 类型）来描述。

至少一个堆 必须：在slink:VkMemoryHeap::pname:flags 里包含ename:VK_MEMORY_HEAP_DEVICE_LOCAL_BIT 标志位。
若有多个堆拥有类似的性能特点，它们可能都包含ename:VK_MEMORY_HEAP_DEVICE_LOCAL_BIT。

在统一内存架构（UMA）系统中，经常只有单块儿内存堆，它被主机端和设备端都认为是"`local`" 的，这种情况下Vulkan实现必须要把内存堆声明为 device-local。

通过flink:vkGetPhysicalDeviceMemoryProperties 返回的每一个内存类型必须带有如下的标志位之一：

  * 0
  * ename:VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT |
    ename:VK_MEMORY_PROPERTY_HOST_COHERENT_BIT
  * ename:VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT |
    ename:VK_MEMORY_PROPERTY_HOST_CACHED_BIT
  * ename:VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT |
    ename:VK_MEMORY_PROPERTY_HOST_CACHED_BIT |
    ename:VK_MEMORY_PROPERTY_HOST_COHERENT_BIT
  * ename:VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT
  * ename:VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT |
    ename:VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT |
    ename:VK_MEMORY_PROPERTY_HOST_COHERENT_BIT
  * ename:VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT |
    ename:VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT |
    ename:VK_MEMORY_PROPERTY_HOST_CACHED_BIT
  * ename:VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT |
    ename:VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT |
    ename:VK_MEMORY_PROPERTY_HOST_CACHED_BIT |
    ename:VK_MEMORY_PROPERTY_HOST_COHERENT_BIT
  * ename:VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT |
    ename:VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT

一定存在至少一种内存类型，ename:VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT 和
ename:VK_MEMORY_PROPERTY_HOST_COHERENT_BIT 标志位都在 pname:propertyFlags中。
一定存在至少一种内存类型，ename:VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT 标志位在 pname:propertyFlags中。

内存类型根据预定义的顺序被排序了，预定义的顺序有助于更容易选择合适的内存类型。
假设被给定两种内存类型 X与Y，若满足如下，预定义的顺序是  [eq]#X {leq} Y# :

  * X的内存属性标志位必须严格是 Y 的内存属性标志位的子集。或者，    
  * X的内存属性标志位和Y 的内存属性标志位完全相同，且X 使用的内存堆大于等于Y的性能。（取决于Vulkan实现特定的方式）。  

内存类型被排序，若按照前序， [eq]#(X {leq} Y) {land} {lnot} (Y {leq} X)#，  X的pname:memoryTypeIndex 小于等于 Y。
注意，上述的 允许的内存属性标志位结合方式的列表满足此前序，但是，其他顺序也是可以的。
此排序的目的是让应用程序使用一种简单的方式来遍历合适的内存类型，形式类似于如下：

[source,c++]
---------------------------------------------------
// Find a memory type in "memoryTypeBits" that includes all of "properties"
int32_t FindProperties(uint32_t memoryTypeBits, VkMemoryPropertyFlags properties)
{
    for (int32_t i = 0; i < memoryTypeCount; ++i)
    {
        if ((memoryTypeBits & (1 << i)) &&
            ((memoryTypes[i].propertyFlags & properties) == properties))
            return i;
    }
    return -1;
}

// Try to find an optimal memory type, or if it does not exist
// find any compatible memory type
VkMemoryRequirements memoryRequirements;
vkGetImageMemoryRequirements(device, image, &memoryRequirements);
int32_t memoryType = FindProperties(memoryRequirements.memoryTypeBits, optimalProperties);
if (memoryType == -1)
    memoryType = FindProperties(memoryRequirements.memoryTypeBits, requiredProperties);
---------------------------------------------------

此循环将会找到被支持的内存类型，它符合 code:properties 中所有的标志位。
若不存在匹配，将寻找最接近匹配（即，内存类型其他的标志位最少），它有其他的标志位，但是并不能决定 code:properties
要求的行为方式。
应用程序可首先寻找最优的属性，如内存类型是device-local或者支持缓存一致性，尽量接近目标使用方式，若此种内存类型
无法找到，将退而求其次的寻找次优解，但仍保证诸如  "0" 或者  "host-visible and coherent"的属性。

include::../validity/structs/VkPhysicalDeviceMemoryProperties.txt[]

ifdef::VK_KHR_get_physical_device_properties2[]

// refBegin vkGetPhysicalDeviceMemoryProperties2KHR Reports memory information for the specified physical device

可调用如下命令来查询内存属性：

include::../api/protos/vkGetPhysicalDeviceMemoryProperties2KHR.txt[]

  * pname:physicalDevice i是需要被查询的设备的handle。
  * pname:pMemoryProperties 指向一个 sname:VkPhysicalDeviceMemoryProperties2KHR 数据结构实例，接收返回的属性。

fname:vkGetPhysicalDeviceMemoryProperties2KHR 和flink:vkGetPhysicalDeviceMemoryProperties表现类似，都能够把拓展的信息通过链式数据结构返回。

include::../validity/protos/vkGetPhysicalDeviceMemoryProperties2KHR.txt[]

// refBegin VkPhysicalDeviceMemoryProperties2KHR Structure specifying physical device memory properties

sname:VkPhysicalDeviceMemoryProperties2KHR 数据结构定义如下：

include::../api/structs/VkPhysicalDeviceMemoryProperties2KHR.txt[]

  * pname:sType 是数据结构的类型。
  * pname:pNext 是 `NULL` 或者指向一个指向拓展特定的数据结构的指针。
  * pname:memoryProperties 是一个 slink:VkPhysicalDeviceMemoryProperties类型数据，它和 被flink:vkGetPhysicalDeviceMemoryProperties填充的数据相同。

include::../validity/structs/VkPhysicalDeviceMemoryProperties2KHR.txt[]

endif::VK_KHR_get_physical_device_properties2[]

// refBegin VkMemoryHeap Structure specifying a memory heap

sname:VkMemoryHeap 类型数据结构定义如下：

include::../api/structs/VkMemoryHeap.txt[]

  * pname:size 是堆中总内存的大小，以字节为单位。
  * pname:flags 是描述堆的属性标志位的掩码。可用bit 如下：    
+
--
// refBegin VkMemoryHeapFlagBits Bitmask specifying attribute flags for a heap
include::../api/enums/VkMemoryHeapFlagBits.txt[]
--
  ** 若pname:flags 包含 ename:VK_MEMORY_HEAP_DEVICE_LOCAL_BIT，它意味着堆内存对应着 device local 内存。
     Device local 内存可能与  host local 内存的性能特征有所不同，且支持不同的内存属性标志位。     

include::../validity/structs/VkMemoryHeap.txt[]

// refBegin VkMemoryType Structure specifying memory type

sname:VkMemoryType 类型数据结构定义如下：

include::../api/structs/VkMemoryType.txt[]

  * pname:heapIndex describes which memory heap this memory type corresponds
    to, and must: be less than pname:memoryHeapCount from the
    sname:VkPhysicalDeviceMemoryProperties structure.
  * pname:propertyFlags is a bitmask of properties for this memory type.
    The bits specified in pname:propertyFlags are:
+
--
// refBegin VkMemoryPropertyFlagBits Bitmask specifying properties for a memory type
include::../api/enums/VkMemoryPropertyFlagBits.txt[]
--
  ** if pname:propertyFlags has the
     ename:VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT bit set, memory allocated
     with this type is the most efficient for device access.
     This property will only be set for memory types belonging to heaps with
     the ename:VK_MEMORY_HEAP_DEVICE_LOCAL_BIT set.
  ** if pname:propertyFlags has the
     ename:VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT bit set, memory allocated
     with this type can: be mapped for host access using flink:vkMapMemory.
  ** if pname:propertyFlags has the
     ename:VK_MEMORY_PROPERTY_HOST_COHERENT_BIT bit set, host cache
     management commands fname:vkFlushMappedMemoryRanges and
     fname:vkInvalidateMappedMemoryRanges are not needed to make host writes
     visible to the device or device writes visible to the host,
     respectively.
  ** if pname:propertyFlags has the ename:VK_MEMORY_PROPERTY_HOST_CACHED_BIT
     bit set, memory allocated with this type is cached on the host.
     Host memory accesses to uncached memory are slower than to cached
     memory, however uncached memory is always host coherent.
  ** if pname:propertyFlags has the
     ename:VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT bit set, the memory type
     only allows device access to the memory.
     Memory types must: not have both
     ename:VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT and
     ename:VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT set.
     Additionally, the object's backing memory may: be provided by the
     implementation lazily as specified in <<memory-device-lazy_allocation,
     Lazily Allocated Memory>>.

include::../validity/structs/VkMemoryType.txt[]

// refBegin VkDeviceMemory Opaque handle to a device memory object

一个Vulkan设备通过内存对象操作设备内存上的数据，内存对象由API 的sname:VkDeviceMemory handle表示。

内存对象通过sname:VkDeviceMemory handle表示：

include::../api/handles/VkDeviceMemory.txt[]

// refEnd VkDeviceMemory

// refBegin vkAllocateMemory Allocate GPU memory

可调用如下命令来分配内存对象：

include::../api/protos/vkAllocateMemory.txt[]

  * pname:device 是拥有内存的逻辑设备。
  * pname:pAllocateInfo 是一个指向slink:VkMemoryAllocateInfo 类型对象的指针，描述了分配行为的参数。一次成功的内存分配必须要使用要求的参数，
	不允许Vulkan实现替换任何参数。
  * pname:pAllocator 控制了主机端内存分配，如 <<memory-allocation, 内存分配>> 一章所描述的。
  * pname:pMemory 是一个指向sname:VkDeviceMemory 类型handle的指针，通过它返回内存分配相关的信息。
  
fname:vkAllocateMemory返回的分配的内存被Vulkan实现保证按照要求对齐。
例如，应用程序要求对图像进行128 byte对齐，对缓冲区进行64 byte对齐，通过这种机制被返回的设备内存将按照128 byte对齐。
这保证应用程序能正确的在同一个内存对象中对不同的子类型进行内存分配（按照不同的内存对齐要求）。

当内存分配好了，它的内容是未定义的。

在单个设备上同时进行内存分配的最大次数是有限制的，依赖于Vulkan实现。
这是由sname:VkPhysicalDeviceLimits 的<<features-limits-maxMemoryAllocationCount,pname:maxMemoryAllocationCount>>
成员决定的。
若超过了pname:maxMemoryAllocationCount ，fname:vkAllocateMemory 将返回ename:VK_ERROR_TOO_MANY_OBJECTS。

[NOTE]
.注意
====
一些平台也许堆但此内存分配有大小限制。例如，某些系统将不能分配大于等于4GB的内存。
这个限制依赖于Vulkan实现，如果出现了此类错误，应该返回ename:VK_ERROR_OUT_OF_DEVICE_MEMORY 。
====

.正确使用
****
  * The number of currently valid memory objects, allocated from
    pname:device, must: be less than
    sname:VkPhysicalDeviceLimits::pname:maxMemoryAllocationCount
****

include::../validity/protos/vkAllocateMemory.txt[]

// refBegin VkMemoryAllocateInfo Structure containing parameters of a memory allocation

sname:VkMemoryAllocateInfo 类型数据结构定义如下：

include::../api/structs/VkMemoryAllocateInfo.txt[]

  * pname:sType 是数据结构的类型。
  * pname:pNext 是 `NULL` 或者一个指向拓展特定的数据结构的指针。
  * pname:allocationSize 是分配的内存大小，以字节为单位。
  * pname:memoryTypeIndex 是内存类型的索引，它选择了将分配的内存的属性和从哪个堆分配内存的属性。 

.正确使用
****
  * pname:allocationSize 必须 小于等于   pname:memoryTypeIndex 和调用命令的sname:VkDevice 指定的sname:VkMemoryHeap 的 可用内存总量，
  * pname:allocationSize 必须大于  `0`
****

include::../validity/structs/VkMemoryAllocateInfo.txt[]

ifdef::VK_NV_dedicated_allocation[]

// refBegin VkDedicatedAllocationMemoryAllocateInfoNV Specify a dedicated memory allocation resource

若 pname:pNext 列表包含一个 sname:VkDedicatedAllocationMemoryAllocateInfoNV 数据结构，那么该数据结构包含一个
内存可绑定的 单buffer或图像资源 的 handle。

sname:VkDedicatedAllocationMemoryAllocateInfoNV 类型数据结构定义如下：

include::../api/structs/VkDedicatedAllocationMemoryAllocateInfoNV.txt[]

  * pname:sType 是数据结构的类型。
  * pname:pNext 是 `NULL` 或者一个指向拓展特定的数据结构的指针。
  * pname:image 是 sname:VK_NULL_HANDLE 或者一个图像的handle，此内存绑定的对象。
  * pname:buffer 是 sname:VK_NULL_HANDLE 或者一个缓冲区的handle，此内存绑定的对象。

.正确使用
****
  *至少一个pname:image 和 pname:buffer 必须是 sname:VK_NULL_HANDLE
  * If pname:image is not sname:VK_NULL_HANDLE, the image must: have been
    created with
    sname:VkDedicatedAllocationImageCreateInfoNV::pname:dedicatedAllocation
    equal to ename:VK_TRUE
  * If pname:buffer is not sname:VK_NULL_HANDLE, the buffer must: have been
    created with
    sname:VkDedicatedAllocationBufferCreateInfoNV::pname:dedicatedAllocation
    equal to ename:VK_TRUE
  * If pname:image is not sname:VK_NULL_HANDLE,
    sname:VkMemoryAllocateInfo::pname:allocationSize must: equal the
    sname:VkMemoryRequirements::pname:size of the image
  * If pname:buffer is not sname:VK_NULL_HANDLE,
    sname:VkMemoryAllocateInfo::pname:allocationSize must: equal the
    sname:VkMemoryRequirements::pname:size of the buffer
****

include::../validity/structs/VkDedicatedAllocationMemoryAllocateInfoNV.txt[]

endif::VK_NV_dedicated_allocation[]

ifdef::VK_NV_external_memory[]
include::VK_NV_external_memory/allocate_memory.txt[]
endif::VK_NV_external_memory[]

ifdef::VK_NV_external_memory_win32[]

include::VK_NV_external_memory_win32/handle_permissions.txt[]

include::VK_NV_external_memory_win32/import_memory_win32.txt[]

include::VK_NV_external_memory_win32/get_handle_win32.txt[]

endif::VK_NV_external_memory_win32[]

// refBegin vkFreeMemory Free GPU memory

可调用如下命令来释放内存对象：

include::../api/protos/vkFreeMemory.txt[]

  * pname:device 是拥有内存对象的逻辑设备。
  * pname:memory 是需要被释放的sname:VkDeviceMemory 对象。
  * pname:pAllocator 控制了CPU端内存分配，如 <<memory-allocation, Memory Allocation>> 一章所述。

在释放内存对象之前，应用程序必须确保内存对象不再被设备使用（如被命令缓冲区排队执行）。
在内存对象被释放时，内存仍绑定在图像或者缓冲区上，但是（在CPU或者设备端）进一步使用它们将造成这些对象被破坏，
导致未知结果。
若仍存在绑定的图像或者缓冲区，内存将不会被Vulkan实现立即释放，但是，在绑定的图像或者缓冲区被销毁时，
内存会被立即释放。
一旦内存被释放，它将被送还给heap，

关于内存对象如何绑定到图像、缓冲区，在<<resources-association, Resource Memory Association>> 一节中有详细描述。.

若内存对象在释放时仍处于映射状态，那么它被隐式的解除了映射。

.正确使用
****
  * All submitted commands that refer to pname:memory (via images or
    buffers) must: have completed execution
****

include::../validity/protos/vkFreeMemory.txt[]


[[memory-device-hostaccess]]
=== CPU访问设备内存对象

通过fname:vkAllocateMemory创建的内存对象不能被CPU端直接访问。

创建时带有ename:VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT属性的内存对象被认为是 _可映射的_ 。
内存对象必须是可映射的，才能被映射到CPU端。


// refBegin vkMapMemory Map a memory object into application address space

可调用如下命令可以获取指向映射到可映射内存对象的指针：

include::../api/protos/vkMapMemory.txt[]

  * pname:device 是拥有内存对象的逻辑设备。
  * pname:memory 是将要被映射的sname:VkDeviceMemory 对象。
  * pname:offset 是一个从内存对象的起始的 从0开始的字节offset。
  * pname:size 是需要映射的内存区间的大小，或者值为 ename:VK_WHOLE_SIZE时表示 从  pname:offset 到分配的内存结尾的全部映射。
  * pname:flags 被保留。
  * pname:ppData 指向一个指针，指向 to a pointer in which is returned a host-accessible
    pointer to the beginning of the mapped range.
    This pointer minus pname:offset must: be aligned to at least
    sname:VkPhysicalDeviceLimits::pname:minMemoryMapAlignment.

若调用  fname:vkMapMemory对已映射过的内存对象再次映射，则是应用程序的错误。

[NOTE]
.注意
====
fname:vkMapMemory will fail if the implementation is unable to allocate an
appropriately sized contiguous virtual address range, e.g. due to virtual
address space fragmentation or platform limits.
In such cases, fname:vkMapMemory must: return VK_ERROR_MEMORY_MAP_FAILED.
The application can: improve the likelihood of success by reducing the size
of the mapped range and/or removing unneeded mappings using
fname:VkUnmapMemory.
====

[[memory-device-hostaccess-hazards]]
fname:vkMapMemory 并不在返回一个host端可访问的指针之前检查设备内存当前是否正在使用中。
应用程序必须保证之前提交的任何命令（会向该区间写入的命令）已经在host端读取或者写入完成，且任何之前被提交的命令（从该区间读取内容的命令）
在host端写入之前已经完成。 (参看 <<synchronization-submission-host-writes, 这里>> 获取更详细的信息).
若分配设备内存时未带有 ename:VK_MEMORY_PROPERTY_HOST_COHERENT_BIT 标志位，必须提供这些保证，应用程序必须从
区间的起始到最邻近的多个 sname:VkPhysicalDeviceLimits::pname:nonCoherentAtomSize聚集在一起，保证从区间的尾部到最邻近的多个
sname:VkPhysicalDeviceLimits::pname:nonCoherentAtomSize 聚集在一起。

While a range of device memory is mapped for host access, the application is
responsible for synchronizing both device and host access to that memory
range.

[NOTE]
.注意
====
It is important for the application developer to become meticulously
familiar with all of the mechanisms described in the chapter on
<<synchronization, Synchronization and Cache Control>> as they are crucial
to maintaining memory access ordering.
====

.正确使用
****
  * pname:memory 必须未被映射过
  * pname:offset 必须要被 pname:memory 的大小要小
  * 若 pname:size 不等于  ename:VK_WHOLE_SIZE， pname:size 必须大于 `0`
  * 若 pname:size 不等于 ename:VK_WHOLE_SIZE，pname:size 必须小于等于  pname:memory 减去 pname:offset的结果的大小
  * pname:memory 必须在创建时带有 内存类型 ename:VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT
****

include::../validity/protos/vkMapMemory.txt[]

Two commands are provided to enable applications to work with non-coherent
memory allocations: fname:vkFlushMappedMemoryRanges and
fname:vkInvalidateMappedMemoryRanges.

[NOTE]
.注意
====
若创建内存对象时带有ename:VK_MEMORY_PROPERTY_HOST_COHERENT_BIT 参数，
fname:vkFlushMappedMemoryRanges 和 fname:vkInvalidateMappedMemoryRanges 是没有必要的，且可能会有性能损失。
unnecessary and may: have performance cost.
====

// refBegin vkFlushMappedMemoryRanges Flush mapped memory ranges

可调用如下命令来把CPU缓存刷新到非一致的内存区域中：

include::../api/protos/vkFlushMappedMemoryRanges.txt[]

  * pname:device 是拥有内存对象的逻辑设备。
  * pname:memoryRangeCount 是 pname:pMemoryRanges 数组的长度。
  * pname:pMemoryRanges 是一个指向 slink:VkMappedMemoryRange 类型数组的指针，描述了需要刷新的内存区域。

fname:vkFlushMappedMemoryRanges must: be used to guarantee that host writes
to non-coherent memory are visible to the device.
It must: be called after the host writes to non-coherent memory have
completed and before command buffers that will read or write any of those
memory locations are submitted to a queue.

[NOTE]
.注意
====
Unmapping non-coherent memory does not implicitly flush the mapped memory,
and host writes that have not been flushed may: not ever be visible to the
device.
====

include::../validity/protos/vkFlushMappedMemoryRanges.txt[]

// refBegin vkInvalidateMappedMemoryRanges Invalidate ranges of mapped memory objects

To invalidate ranges of non-coherent memory from the host caches, call:

include::../api/protos/vkInvalidateMappedMemoryRanges.txt[]

  * pname:device 是拥有内存范围的逻辑设备。 
  * pname:memoryRangeCount 是 pname:pMemoryRanges 数组的长度。
  * pname:pMemoryRanges is a pointer to an array of
    slink:VkMappedMemoryRange structures describing the memory ranges to
    invalidate.

fname:vkInvalidateMappedMemoryRanges must: be used to guarantee that device
writes to non-coherent memory are visible to the host.
It must: be called after command buffers that execute and flush (via memory
barriers) the device writes have completed, and before the host will read or
write any of those locations.
If a range of non-coherent memory is written by the host and then
invalidated without first being flushed, its contents are undefined.

[NOTE]
.注意
====
Mapping non-coherent memory does not implicitly invalidate the mapped
memory, and device writes that have not been invalidated must: be made
visible before the host reads or overwrites them.
====

include::../validity/protos/vkInvalidateMappedMemoryRanges.txt[]

// refBegin VkMappedMemoryRange Structure specifying a mapped memory range

sname:VkMappedMemoryRange 类型数据结构定义如下：

include::../api/structs/VkMappedMemoryRange.txt[]

  * pname:sType 是数据结构的类型。
  * pname:pNext 是 `NULL` 或者一个指向拓展特定的数据结构的指针。
  * pname:memory is the memory object to which this range belongs.
  * pname:offset 是 the zero-based byte offset from the beginning of the memory object.
  * pname:size is either the size of range, or ename:VK_WHOLE_SIZE to affect
    the range from pname:offset to the end of the current mapping of the
    allocation.

.正确使用
****
  * pname:memory 当前必须已经被映射了
  * 若 pname:size 和   ename:VK_WHOLE_SIZE  不相等，pname:offset 和 pname:size 必须: 指定已经映射的内存  pname:memory 之中的一段区间。
  * 若 pname:size 和 ename:VK_WHOLE_SIZE 相等， pname:offset 必须: 和已经映射的内存的区间完全相同。
  * pname:offset 必须: 是 sname:VkPhysicalDeviceLimits::pname:nonCoherentAtomSize 的倍数
  * 若 pname:size和 ename:VK_WHOLE_SIZE 不相等，pname:size 必须: 是 sname:VkPhysicalDeviceLimits::pname:nonCoherentAtomSize 的倍数。
****

include::../validity/structs/VkMappedMemoryRange.txt[]

ifdef::editing-notes[]
[NOTE]
.editing-note
====
TODO (Tobias) - There's a circular section reference between this next
section and the <<synchronization-fences-waiting,synchronization section>>.
The information is all covered by both places, but it seems a bit weird to
have them reference each other.
Not sure how to resolve it.
====
endif::editing-notes[]

Host-visible memory types that advertise the
ename:VK_MEMORY_PROPERTY_HOST_COHERENT_BIT property still require
<<synchronization-pipeline-barriers,memory barriers>> between host and
device in order to be coherent, but do not require additional cache
management operations to achieve coherency.
For host writes to be seen by subsequent command buffer operations, a
pipeline barrier from a source of ename:VK_ACCESS_HOST_WRITE_BIT and
ename:VK_PIPELINE_STAGE_HOST_BIT to a destination of the relevant device
<<synchronization-pipeline-stages, pipeline stages>> and
<<synchronization-access-types, access types>> must: be performed.
Note that such a barrier is performed
<<synchronization-submission-host-writes,implicitly>> upon each command
buffer submission, so an explicit barrier is only rarely needed (e.g. if a
command buffer waits upon an event signaled by the host, where the host
wrote some data after submission).
A pipeline barrier is required: to make writes visible to subsequent reads
on the host.

// refBegin vkUnmapMemory Unmap a previously mapped memory object

To unmap a memory object once host access to it is no longer needed by the
application, call:

include::../api/protos/vkUnmapMemory.txt[]

  * pname:device 是拥有内存的逻辑设备。
  * pname:memory is the memory object to be unmapped.

.正确使用
****
  * pname:memory 在当前必须被映射过
****

include::../validity/protos/vkUnmapMemory.txt[]


[[memory-device-lazy_allocation]]
=== 延迟内存分配
若从堆中分配的内存带有ename:VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT 标志位，
这个对象对应的内存可能被Vulkan实现延迟分配。
内存真实的提交大小初始的时候可能最小为0（也可能可要求的一样大），当更多的内存被使用时不断的增长。


A memory type with this flag set is only allowed to be bound to a
sname:VkImage whose usage flags include
ename:VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT.

[NOTE]
.注意
====
Using lazily allocated memory objects for framebuffer attachments that are
not needed once a render pass instance has completed may: allow some
implementations to never allocate memory for such attachments.
====

// refBegin vkGetDeviceMemoryCommitment Query the current commitment for a VkDeviceMemory

To determine the amount of lazily-allocated memory that is currently
committed for a memory object, call:

include::../api/protos/vkGetDeviceMemoryCommitment.txt[]

  * pname:device 是拥有内存的逻辑设备。
  * pname:memory 是被查询的内存对象。
  * pname:pCommittedMemoryInBytes is a pointer to a basetype:VkDeviceSize
    value in which the number of bytes currently committed is returned, on
    success.

Vulkan实现也许会在任何时刻更新提交的内存，所以这个查询返回的值可能是过期的。

The implementation guarantees to allocate any committed memory from the
heapIndex indicated by the memory type that the memory object was created
with.

.正确使用
****
  * pname:memory must: have been created with a memory type that reports
    ename:VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT
****

include::../validity/protos/vkGetDeviceMemoryCommitment.txt[]

