// Copyright (c) 2015-2017 The Khronos Group Inc.
// Copyright notice at https://www.khronos.org/registry/speccopyright.html

[[textures]]
= 图像操作

== 图像操作总揽

图像操作是SPIR-V图像指令进行的步骤，这些指令把  code:OpTypeImage ( 一个sname:VkImageView) 或
code:OpTypeSampledImage (一个(sname:VkImageView, sname:VkSampler) pair) 和纹素坐标当作操作对象，且返回图像中一个基于1或者更多临近纹素 (_texels_)。

[NOTE]
.注意
==================
 纹素是一个术语，是由单词texture和element组成的。早期交互式计算机图形卡支持在贴图上进行贴图操作，
 在图像上的图像操作其中一小部分在如下文档有所描述。
 对离散采样的描述一直维持一致，所以，我们仍使用历史术语texel来指代它们。
==================

SPIR-V 图像指令包含如下功能：

  * code:OpImageSample* 和 code:OpImageSparseSample* 读取图像内一个或者多个相邻的texel，且根据采样器的状态对纹素值进行<<textures-texel-filtering,filter>>。    
  ** 名字中带有 code:ImplicitLod 的指令 基于寻找临近片元的坐标
     <<textures-level-of-detail-operation,  决定>> 了采样操作中使用的细节级别。
  ** 名字中带有 code:ExplicitLod 的指令 基于额外坐标
     <<textures-level-of-detail-operation,  决定>> 了采样操作中使用的细节级别。
  ** 名字中带有 code:Proj 的指令，对坐标应用齐次 
     <<textures-projection, 投影>> 。
  * code:OpImageFetch 和 code:OpImageSparseFetch 返回图像的单个纹素。不使用采样器。    
  * code:OpImage*code:Gather 和 code:OpImageSparse*code:Gather 读取临近纹素，且
     <<textures-gather, 且返回各自的单个组件 >>。
  * code:OpImageRead (和 code:OpImageSparseRead) 和 code:OpImageWrite 各自对图像的纹素进行读取、写入。不使用采样器。
  * 名字中带有 code:Dref 的指令对纹素值进行
    <<textures-depth-compare-operation, 深度比较 >> 。
  * 名字中带有 code:Sparse 的指令额外返回一个 
    <<textures-sparse-residency, 稀疏驻留>> 代码。


=== Texel Coordinate Systems

通过 _texel coordinates_ 对图像寻址。
有三种 _texel coordinate systems_:

  * 归一化的纹素坐标 [eq]#[0.0, 1.0]#
  * 非归一化的纹素坐标 [eq]#[0.0, width / height / depth)#
  * 整型纹素坐标 [eq]#[0, width / height / depth)#

SPIR-V code:OpImageFetch, code:OpImageSparseFetch, code:OpImageRead,
code:OpImageSparseRead, 和 code:OpImageWrite 指令使用整型纹素坐标。
其他图像指令可使用归一化或者非归一化的纹素坐标
 (由指令中使用的采样器的 the pname:unnormalizedCoordinates 状态 选择的)，但是对支持的操作、图像状态、采样器状态会有
<<samplers-unnormalizedCoordinates, 限制>> 。
归一化的坐标在图像操作时逻辑上被转换为非归一化，且
image operations,和<<textures-normalized-operations, 某些步骤>> 只在归一化坐标上进行操作。
array layer坐标总是被当作是非归一化的，即使其他坐标是归一化的。

归一化的纹素坐标指 [eq]#(s,t,r,q,a)#，这些坐标有如下含义：

  * [eq]#s#: 一个图像的第一个维度的坐标。
  * [eq]#t#: 一个图像的第二个维度的坐标。
  * [eq]#r#: 一个图像的第三个维度的坐标。
  ** [eq]#(s,t,r)# 被解释为立体贴图的方向向量。
  * [eq]#q#: 第四个坐标，齐次（投影）坐标系下的坐标。
  * [eq]#a#: array layer的坐标。

基于图像变量的维度和指令的类型从SPIR-V 操作数中提取坐标。

对于code:Proj 指令，其组成的顺序为 (s, [t,] [r,] q)，基于图像的code:Dim t 和 r 条件性的出现。
对于 non-code:Proj 指令，其组成的顺序为  (s [,t] [,r] [,a])，基于图像的code:Dim，t 和 r 条件性的出现，基于图像的code:Arrayed 属性，a条件性的出现。
投影图像指令不支持code:Arrayed 图像。

非归一化纹素坐标指 [eq]#(u,v,w,a)#，坐标的含义如下：

  * [eq]#u#: 图像的第一个维度。
  * [eq]#v#: 图像的第二个维度。
  * [eq]#w#: 图像的第三个维度。
  * [eq]#a#: array layer的坐标。

只有 [eq]#u# 和 [eq]#v# 坐标是直接从 SPIR-V 操作数中提取出来的，因为只有 1D和2D (非-code:Arrayed) 维度支持非归一化坐标。

组成的顺序为 [eq]#(u [,v])#，当维度为2D时 [eq]#v# 条件性的出现。
当归一化坐标被转化为非归一化坐标，所有的四个坐标都被使用。
整型纹素坐标指 [eq]#(i,j,k,l,n)#，且该顺序中第四个成员和非归一化坐标有相同含义。

它们按照顺序 [eq]#(i, [,j], [,k]从 SPIR-V 中被提取出来，以便基于图像的code:Dim，
[,l])#,  [eq]#j#和[eq]#k# 条件性出现，基于图像的code:Arrayed 属性，l 条件性出现。
n 是采样索引，且是从code:Sample图像操作数中提取出来的。

对于所有坐标类型，未使用的坐标被指定为0.

[[textures-texel-coordinate-systems-diagrams]]
image::images/vulkantexture0.png[align="center",title="Texel Coordinate Systems",{fullimagewidth}]
The Texel Coordinate Systems - For the example shown of an 8x4 texel two
dimensional image.

  * Normalized texel coordinates:
  ** The [eq]#s# coordinate goes from 0.0 to 1.0, left to right.
  ** The [eq]#t# coordinate goes from 0.0 to 1.0, top to bottom.
  * Unnormalized texel coordinates:
  ** The [eq]#u# coordinate goes from -1.0 to 9.0, left to right.
     The [eq]#u# coordinate within the range 0.0 to 8.0 is within the image,
     otherwise it is within the border.
  ** The [eq]#v# coordinate goes from -1.0 to 5.0, top to bottom.
     The [eq]#v# coordinate within the range 0.0 to 4.0 is within the image,
     otherwise it is within the border.
  * Integer texel coordinates:
  ** The [eq]#i# coordinate goes from -1 to 8, left to right.
     The [eq]#i# coordinate within the range 0 to 7 addresses texels within
     the image, otherwise it addresses a border texel.
  ** The [eq]#j# coordinate goes from -1 to 5, top to bottom.
     The [eq]#j# coordinate within the range 0 to 3 addresses texels within
     the image, otherwise it addresses a border texel.
  * Also shown for linear filtering:
  ** Given the unnormalized coordinates [eq]#(u,v)#, the four texels
     selected are [eq]#i~0~j~0~#, [eq]#i~1~j~0~#, [eq]#i~0~j~1~#, and
     [eq]#i~1~j~1~#.
  ** The weights [eq]#{alpha}#和[eq]#{beta}#.
  ** Given the offset [eq]#{DeltaUpper}~i~#和[eq]#{DeltaUpper}~j~#, the
     four texels selected by the offset are [eq]#i~0~j'~0~#,
     [eq]#i~1~j'~0~#, [eq]#i~0~j'~1~#,和[eq]#i~1~j'~1~#.

image::images/vulkantexture1.png[align="center",title="Texel Coordinate Systems",{fullimagewidth}]

The Texel Coordinate Systems - For the example shown of an 8x4 texel two
dimensional image.

  * Texel coordinates as above.
    Also shown for nearest filtering:
  ** Given the unnormalized coordinates [eq]#(u,v)#, the texel selected is
     [eq]#ij#.
  ** Given the offset [eq]#{DeltaUpper}~i~#和[eq]#{DeltaUpper}~j~#, the
     texel selected by the offset is [eq]#ij'#.


== Conversion Formulas

ifdef::editing-notes[]
[NOTE]
.editing-note
==================
(Bill) These Conversion Formulas will likely move to Section 2.7 Fixed-Point
Data Conversions (RGB to sRGB和sRGB to RGB)和section 2.6 Numeric
Representation和Computation (RGB to Shared Exponent和Shared Exponent
to RGB)
==================
endif::editing-notes[]


[[textures-RGB-sexp]]
=== RGB to Shared Exponent Conversion

An RGB color [eq]#(red, green, blue)# is transformed to a shared exponent
color [eq]#(red~shared~, green~shared~, blue~shared~, exp~shared~)# as
follows:

First, the components [eq]#(red, green, blue)# are clamped to
[eq]#(red~clamped~, green~clamped~, blue~clamped~)# as:

  :: [eq]#red~clamped~ = max(0, min(sharedexp~max~, red))#
  :: [eq]#green~clamped~ = max(0, min(sharedexp~max~, green))#
  :: [eq]#blue~clamped~ = max(0, min(sharedexp~max~, blue))#

Where:

[latexmath]
+++++++++++++++++++
\begin{aligned}
N               & = 9  & \text{number of mantissa bits per component} \\
B               & = 15 & \text{exponent bias} \\
E_{max}         & = 31 & \text{maximum possible biased exponent value} \\
sharedexp_{max} & = \frac{(2^N-1)}{2^N} \times 2^{(E_{max}-B)}
\end{aligned}
+++++++++++++++++++

[NOTE]
.注意
==================
[eq]#NaN#, if supported, is handled as in <<ieee-754,IEEE 754-2008>>
`minNum()`和`maxNum()`.
That is the result is a [eq]#NaN# is mapped to zero.
==================

The largest clamped component, [eq]#max~clamped~# is determined:

  :: [eq]#max~clamped~ = max(red~clamped~, green~clamped~, blue~clamped~)#

A preliminary shared exponent [eq]#exp'# is computed:
[latexmath]
+++++++++++++++++++
\begin{aligned}
exp' =
  \begin{cases}
    \left \lfloor \log_2(max_{clamped}) \right \rfloor + (B+1)
      & \text{for}\  max_{clamped} > 2^{-(B+1)} \\
    0
      & \text{for}\  max_{clamped} \leq 2^{-(B+1)}
  \end{cases}
\end{aligned}
+++++++++++++++++++

The shared exponent [eq]#exp~shared~# is computed:

[latexmath]
+++++++++++++++++++
\begin{aligned}
max_{shared} =
    \left \lfloor
        { \frac{max_{clamped}}{2^{(exp'-B-N)}} + \frac{1}{2} }
    \right \rfloor
\end{aligned}
+++++++++++++++++++

[latexmath]
+++++++++++++++++++
\begin{aligned}
exp_{shared} =
  \begin{cases}
    exp'   & \text{for}\  0 \leq max_{shared} < 2^N \\
    exp'+1 & \text{for}\  max_{shared} = 2^N
  \end{cases}
\end{aligned}
+++++++++++++++++++

Finally, three integer values in the range [eq]#0# to [eq]#2^N^# are
computed:

[latexmath]
+++++++++++++++++++
\begin{aligned}
red_{shared} & =
    \left \lfloor
        { \frac{red_{clamped}}{2^{(exp_{shared}-B-N)}}+ \frac{1}{2} }
    \right \rfloor \\
green_{shared} & =
    \left \lfloor
        { \frac{green_{clamped}}{2^{(exp_{shared}-B-N)}}+ \frac{1}{2} }
    \right \rfloor \\
blue_{shared} & =
    \left \lfloor
        { \frac{blue_{clamped}}{2^{(exp_{shared}-B-N)}}+ \frac{1}{2} }
    \right \rfloor
\end{aligned}
+++++++++++++++++++


[[textures-sexp-RGB]]
=== Shared Exponent to RGB

A shared exponent color [eq]#(red~shared~, green~shared~, blue~shared~,
exp~shared~)# is transformed to an RGB color [eq]#(red, green, blue)# as
follows:

  :: latexmath:[red = red_{shared} \times {2^{(exp_{shared}-B-N)}}]
  :: latexmath:[green = green_{shared} \times {2^{(exp_{shared}-B-N)}}]
  :: latexmath:[blue = blue_{shared} \times {2^{(exp_{shared}-B-N)}}]

Where:

  :: [eq]#N = 9# (number of mantissa bits per component)
  :: [eq]#B = 15# (exponent bias)


== 纹素输入操作

_Texel input instructions_ 是 SPIR-V 图像指令， 从一张图像中读取数据。
_Texel input operations_ 是处理一个纹素输入指令时一系列的步骤的集合，操作状态、坐标和纹素值，
对于一些或者所有的纹素输入指令来说都类似。
它们包含如下步骤，按照列表顺序执行：

  * <<textures-input-validation,Validation operations>>
  ** <<textures-operation-validation,Instruction/Sampler/Image validation>>
  ** <<textures-integer-coordinate-validation,Coordinate validation>>
  ** <<textures-sparse-validation,Sparse validation>>
  * <<textures-format-conversion,Format conversion>>
  * <<textures-texel-replacement,Texel replacement>>
  * <<textures-depth-compare-operation,Depth comparison>>
  * <<textures-conversion-to-rgba,Conversion to RGBA>>
  * <<textures-component-swizzle,Component swizzle>>

For texel input instructions involving multiple texels (for sampling or
gathering), these steps are applied for each texel that is used in the
instruction.
Depending on the type of image instruction, other steps are conditionally
performed between these steps or involving multiple coordinate or texel
values.


[[textures-input-validation]]
=== 纹素输入验证操作

_Texel input validation operations_ 检查指令/图像/采样器的状态或者坐标，且在某些情形下会导致纹素值被替换或者变为未定义。
纹素要经历的验证有多种。


[[textures-operation-validation]]
==== 指令/采样器/图像验证

SPIR-V 指令与采样器或图像，或二者同时不匹配的情形会出现多种。
采样器与图像不匹配的情形也会有多种。
此种情形下，纹素的值是未定义的。

这些情形包括：

  * The sampler pname:borderColor is an integer type和the image
    pname:format is not one of the elink:VkFormat integer types or a stencil
    component of a depth/stencil format.
  * The sampler pname:borderColor is a float type和the image pname:format
    is not one of the elink:VkFormat float types or a depth component of a
    depth/stencil format.
  * The sampler pname:borderColor is one of the opaque black colors
    (ename:VK_BORDER_COLOR_FLOAT_OPAQUE_BLACK or
    ename:VK_BORDER_COLOR_INT_OPAQUE_BLACK)和the image
    elink:VkComponentSwizzle for any of the slink:VkComponentMapping
    components is not ename:VK_COMPONENT_SWIZZLE_IDENTITY.
  * If the instruction is code:OpImageRead or code:OpImageSparseRead和the
    pname:shaderStorageImageReadWithoutFormat feature is not enabled, or the
    instruction is code:OpImageWrite和the
    pname:shaderStorageImageWriteWithoutFormat feature is not enabled, then
    the SPIR-V Image Format must: be <<spirvenv-image-formats,compatible>>
    with the image view's pname:format.
  * The sampler pname:unnormalizedCoordinates is ename:VK_TRUE和any of
    the <<samplers-unnormalizedCoordinates,limitations of unnormalized
    coordinates>> are violated.
  * The SPIR-V instruction is one of the code:OpImage*code:Dref*
    instructions和the sampler pname:compareEnable is ename:VK_FALSE
  * The SPIR-V instruction is not one of the code:OpImage*code:Dref*
    instructions和the sampler pname:compareEnable is ename:VK_TRUE
  * The SPIR-V instruction is one of the code:OpImage*code:Dref*
    instructions和the image pname:format is not one of the depth/stencil
    formats with a depth component, or the image aspect is not
    ename:VK_IMAGE_ASPECT_DEPTH_BIT.
  * The SPIR-V instruction's image variable's properties are not compatible
    with the image view:
  ** Rules for pname:viewType:
  *** ename:VK_IMAGE_VIEW_TYPE_1D must: have code:Dim = 1D, code:Arrayed =
      0, code:MS = 0.
  *** ename:VK_IMAGE_VIEW_TYPE_2D must: have code:Dim = 2D, code:Arrayed =
      0.
  *** ename:VK_IMAGE_VIEW_TYPE_3D must: have code:Dim = 3D, code:Arrayed =
      0, code:MS = 0.
  *** ename:VK_IMAGE_VIEW_TYPE_CUBE must: have code:Dim = Cube, code:Arrayed
      = 0, code:MS = 0.
  *** ename:VK_IMAGE_VIEW_TYPE_1D_ARRAY must: have code:Dim = 1D,
      code:Arrayed = 1, code:MS = 0.
  *** ename:VK_IMAGE_VIEW_TYPE_2D_ARRAY must: have code:Dim = 2D,
      code:Arrayed = 1.
  *** ename:VK_IMAGE_VIEW_TYPE_CUBE_ARRAY must: have code:Dim = Cube,
      code:Arrayed = 1, code:MS = 0.
  ** If the image was created with slink:VkImageCreateInfo::pname:samples
     equal to ename:VK_SAMPLE_COUNT_1_BIT, the instruction must: have
     code:MS = 0.
  ** If the image was created with slink:VkImageCreateInfo::pname:samples
     not equal to ename:VK_SAMPLE_COUNT_1_BIT, the instruction must: have
     code:MS = 1.


[[textures-integer-coordinate-validation]]
==== 整型纹素坐标验证

整型纹素坐标的验证针对 image level的大小和layer的数量、图像的采样数。
对于 使用整型纹素坐标的SPIR-V 指令，验证直接操作于整型坐标。
对于使用归一化或者非归一化纹素坐标的指令，验证直接操作于纹素坐标
<<textures-unnormalized-to-integer, 转换>> 到整型纹素坐标结果之上。 

若整型纹素坐标不满足如下所有情形

  :: [eq]#0 {leq} i < w~s~#
  :: [eq]#0 {leq} j < h~s~#
  :: [eq]#0 {leq} k < d~s~#
  :: [eq]#0 {leq} l < layers#
  :: [eq]#0 {leq} n < samples#

where:

  :: [eq]#w~s~ =# width of the image level
  :: [eq]#h~s~ =# height of the image level
  :: [eq]#d~s~ =# depth of the image level
  :: [eq]#layers =# number of layers in the image
  :: [eq]#samples =# number of samples per texel in the image

那么转换为整型纹素坐标的验证就会失败。

有四种情形需要考虑：

  . Valid Texel Coordinates
+
--
  * If the texel coordinates pass validation (that is, the coordinates lie
     within the image),

then the texel value comes from the value in image memory.
--

  . Border Texel
+
--
  * If the texel coordinates fail validation, and
  * If the read is the result of an image sample instruction or image gather
     instruction, and
  * If the image is not a cube image,

then the texel is a border texel和<<textures-texel-replacement,texel
replacement>> is performed.
--

  . Invalid Texel
+
--
  * If the texel coordinates fail validation, and
  * If the read is the result of an image fetch instruction, image read
    instruction, or atomic instruction,

then the texel is an invalid texel和<<textures-texel-replacement,texel
replacement>> is performed.
--

  . Cube Map Edge or Corner
+
--
Otherwise the texel coordinates lie on the borders along the edges and
corners of a cube map image,和<<textures-cubemapedge, Cube map edge
handling>> is performed.
--


[[textures-cubemapedge]]
==== Cube Map Edge Handling

If the texel coordinates lie on the borders along the edges和corners of a
cube map image, the following steps are performed.
Note that this only occurs when using ename:VK_FILTER_LINEAR filtering
within a mip level, since ename:VK_FILTER_NEAREST is treated as using
ename:VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE.

  * Cube Map Edge Texel
+
--
  * If the texel lies along the border in either only [eq]#i# or only
    [eq]#j#

then the texel lies along an edge, so the coordinates [eq]#(i,j)#和the
array layer [eq]#l# are transformed to select the adjacent texel from the
appropriate neighboring face.
--

  * Cube Map Corner Texel
+
--
  * If the texel lies along the border in both [eq]#i#和[eq]#j#

then the texel lies at a corner和there is no unique neighboring face from
which to read that texel.
The texel should: be replaced by the average of the three values of the
adjacent texels in each incident face.
However, implementations may: replace the cube map corner texel by other
methods, subject to the constraint that if the three available samples have
the same value, the replacement texel also has that value.
--


[[textures-sparse-validation]]
==== Sparse Validation

If the texel reads from an unbound region of a sparse image, the texel is a
_sparse unbound texel_,和processing continues with
<<textures-texel-replacement,texel replacement>>.


[[textures-format-conversion]]
=== 格式转换

Texels undergo a format conversion from the elink:VkFormat of the image view
to a vector of either floating point or signed or unsigned integer
components, with the number of components based on the number of components
present in the format.

  * Color formats have one, two, three, or four components, according to the
    format.
  * Depth/stencil formats are one component.
    The depth or stencil component is selected by the pname:aspectMask of
    the image view.

Each component is converted based on its type和size (as defined in the
<<features-formats-definition,Format Definition>> section for each
elink:VkFormat), using the appropriate equations in
<<fundamentals-fp16,16-Bit Floating-Point Numbers>>,
<<fundamentals-fp11,Unsigned 11-Bit Floating-Point Numbers>>,
<<fundamentals-fp10,Unsigned 10-Bit Floating-Point Numbers>>,
<<fundamentals-fixedconv,Fixed-Point Data Conversion>>, and
<<textures-sexp-RGB,Shared Exponent to RGB>>.
Signed integer components smaller than 32 bits are sign-extended.

If the image format is sRGB, the color components are first converted as if
they are UNORM,和then sRGB to linear conversion is applied to the R, G,
and B components as described in the "`KHR_DF_TRANSFER_SRGB`" section of the
<<data-format,Khronos Data Format Specification>>.
The A component, if present, is unchanged.

If the image view format is block-compressed, then the texel value is first
decoded, then converted based on the type和number of components defined
by the compressed format.


[[textures-texel-replacement]]
=== 纹素替换

A texel is replaced if it is one (and only one) of:

  * a border texel,
  * an invalid texel, or
  * a sparse unbound texel.

Border texels are replaced with a value based on the image format和the
pname:borderColor of the sampler.
The border color is:

[[textures-border-replacement-color]]
.Border Color [eq]#B#
[options="header",cols="60%,40%"]
|====
| Sampler pname:borderColor                     | Corresponding Border Color
| ename:VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK | [eq]#B = (0.0, 0.0, 0.0, 0.0)#
| ename:VK_BORDER_COLOR_FLOAT_OPAQUE_BLACK      | [eq]#B = (0.0, 0.0, 0.0, 1.0)#
| ename:VK_BORDER_COLOR_FLOAT_OPAQUE_WHITE      | [eq]#B = (1.0, 1.0, 1.0, 1.0)#
| ename:VK_BORDER_COLOR_INT_TRANSPARENT_BLACK   | [eq]#B = (0, 0, 0, 0)#
| ename:VK_BORDER_COLOR_INT_OPAQUE_BLACK        | [eq]#B = (0, 0, 0, 1)#
| ename:VK_BORDER_COLOR_INT_OPAQUE_WHITE        | [eq]#B = (1, 1, 1, 1)#
|====

[NOTE]
.注意
====
The names etext:VK_BORDER_COLOR_*\_TRANSPARENT_BLACK,
etext:VK_BORDER_COLOR_*\_OPAQUE_BLACK, and
etext:VK_BORDER_COLOR_*_OPAQUE_WHITE are meant to describe which components
are zeros和ones in the vocabulary of compositing,和are not meant to
imply that the numerical value of etext:VK_BORDER_COLOR_INT_OPAQUE_WHITE is
a saturating value for integers.
====

This is substituted for the texel value by replacing the number of
components in the image format

[[textures-border-replacement-table]]
.Border Texel Components After Replacement
[width="80%",options="header"]
|====
| Texel Aspect or Format      | Component Assignment
| Depth aspect                | [eq]#D       = B~r~#
| Stencil aspect              | [eq]#S       = B~r~#
| One component color format  | [eq]#C~r~    = B~r~#
| Two component color format  | [eq]#C~rg~   = (B~r~,B~g~)#
| Three component color format| [eq]#C~rgb~  = (B~r~,B~g~,B~b~)#
| Four component color format | [eq]#C~rgba~ = (B~r~,B~g~,B~b~,B~a~)#
|====

If the read operation is from a buffer resource,和the
pname:robustBufferAccess feature is enabled, an invalid texel is replaced as
described <<features-features-robustBufferAccess,here>>.

If the pname:robustBufferAccess feature is not enabled, the value of an
invalid texel is undefined.

ifdef::editing-notes[]
[NOTE]
.editing-note
==================
(Bill) This is not currently catching this significant case.

For opImageFetch, which fetches from an *image* not a buffer, the result is
defined if pname:robustBufferAccess is enabled.
==================
endif::editing-notes[]

If the sname:VkPhysicalDeviceSparseProperties property
pname:residencyNonResidentStrict is true, a sparse unbound texel is replaced
with 0 or 0.0 values for integer和floating-point components of the image
format, respectively.

If pname:residencyNonResidentStrict is false, the read must: be safe, but
the value of the sparse unbound texel is undefined.


[[textures-depth-compare-operation]]
=== 深度比较操作

If the image view has a depth/stencil format, the depth component is
selected by the pname:aspectMask,和the operation is a code:Dref
instruction, a depth comparison is performed.
The value of the result [eq]#D# is [eq]#1.0# if the result of the compare
operation is [eq]#true#,和[eq]#0.0# otherwise.
The compare operation is selected by the pname:compareOp member of the
sampler.

[latexmath]
+++++++++++++++++++
\begin{aligned}
D & = 1.0 &
  \begin{cases}
    D_{ref} \leq D & \text{for LEQUAL}   \\
    D_{ref} \geq D & \text{for GEQUAL}   \\
    D_{ref} < D    & \text{for LESS}     \\
    D_{ref} > D    & \text{for GREATER}  \\
    D_{ref} = D    & \text{for EQUAL}    \\
    D_{ref} \neq D & \text{for NOTEQUAL} \\
    true           & \text{for ALWAYS}   \\
    false          & \text{for NEVER}
  \end{cases} \\
D & = 0.0 & \text{otherwise}
\end{aligned}
+++++++++++++++++++

where, in the depth comparison:

  :: [eq]#D~ref~ = shaderOp.D~ref~# (from optional SPIR-V operand)
  :: [eq]#D# (texel depth value)


[[textures-conversion-to-rgba]]
=== 转换到 RGBA

The texel is expanded from one, two, or three to four components based on
the image base color:

[[textures-texel-color-rgba-conversion-table]]
.Texel Color After Conversion To RGBA
[options="header"]
|====
| Texel Aspect or Format      | RGBA Color
| Depth aspect                | [eq]#C~rgba~ = (D,0,0,one)#
| Stencil aspect              | [eq]#C~rgba~ = (S,0,0,one)#
| One component color format  | [eq]#C~rgba~ = (C~r~,0,0,one)#
| Two component color format  | [eq]#C~rgba~ = (C~rg~,0,one)#
| Three component color format| [eq]#C~rgba~ = (C~rgb~,one)#
| Four component color format | [eq]#C~rgba~ = C~rgba~#
|====

where [eq]#one = 1.0f# for floating-point formats和depth aspects, and
[eq]#one = 1# for integer formats和stencil aspects.


[[textures-component-swizzle]]
=== Component Swizzle

All texel input instructions apply a _swizzle_ based on the
elink:VkComponentSwizzle enums in the pname:components member of the
slink:VkImageViewCreateInfo structure for the image being read.
The swizzle can: rearrange the components of the texel, or substitute zero
and one for any components.
It is defined as follows for the R component,和operates similarly for the
other components.


[latexmath]
+++++++++++++++++++
\begin{aligned}
C'_{rgba}[R] & =
  \begin{cases}
    C_{rgba}[R] & \text{for RED swizzle}   \\
    C_{rgba}[G] & \text{for GREEN swizzle} \\
    C_{rgba}[B] & \text{for BLUE swizzle}  \\
    C_{rgba}[A] & \text{for ALPHA swizzle} \\
    0           & \text{for ZERO swizzle}  \\
    one         & \text{for ONE swizzle} \\
    C_{rgba}[R] & \text{for IDENTITY swizzle}
  \end{cases}
\end{aligned}
+++++++++++++++++++

where:

[latexmath]
+++++++++++++++++++
\begin{aligned}
C_{rgba}[R] & \text{is the RED component} \\
C_{rgba}[G] & \text{is the GREEN component} \\
C_{rgba}[B] & \text{is the BLUE component} \\
C_{rgba}[A] & \text{is the ALPHA component} \\
one         & = 1.0\text{f}  & \text{for floating point components} \\
one         & = 1              & \text{for integer components}
\end{aligned}
+++++++++++++++++++

For each component this is applied to, the
ename:VK_COMPONENT_SWIZZLE_IDENTITY swizzle selects the corresponding
component from [eq]#C~rgba~#.

If the border color is one of the etext:VK_BORDER_COLOR_*_OPAQUE_BLACK enums
and the elink:VkComponentSwizzle is not ename:VK_COMPONENT_SWIZZLE_IDENTITY
for all components (or the
<<resources-image-views-identity-mappings,equivalent identity mapping>>),
the value of the texel after swizzle is undefined.


[[textures-sparse-residency]]
=== Sparse Residency

code:OpImageSparse* instructions return a structure which includes a
_residency code_ indicating whether any texels accessed by the instruction
are sparse unbound texels.
This code can: be interpreted by the code:OpImageSparseTexelsResident
instruction which converts the residency code to a boolean value.


== 纹素输出操作

_Texel output instructions_ are SPIR-V image instructions that write to an
image.
_Texel output operations_ are a set of steps that are performed on state,
coordinates,和texel values while processing a texel output instruction,
and which are common to some or all texel output instructions.
They include the following steps, which are performed in the listed order:

  * <<textures-output-validation,Validation operations>>
  ** <<textures-format-validation,Format validation>>
  ** <<textures-output-coordinate-validation,Coordinate validation>>
  ** <<textures-output-sparse-validation,Sparse validation>>
  * <<textures-output-format-conversion,Texel output format conversion>>


[[textures-output-validation]]
=== 纹素输出验证操作

_Texel output validation operations_ inspect instruction/image state or
coordinates,和in certain circumstances cause the write to have no effect.
There are a series of validations that the texel undergoes.


[[textures-format-validation]]
==== 纹素格式验证

若code:OpTypeImage的图像格式不与
sname:VkImageView's pname:format兼容，图像视图内存的写入将会导致未定义行为，但是写入操作不会访问图像视图以外的内存。


[[textures-output-coordinate-validation]]
=== 整型纹素坐标验证

整型纹素坐标的验证，可 integer texel coordinates are validated according to the same rules as
for texel input <<textures-integer-coordinate-validation,coordinate
validation>>.

If the texel fails integer texel coordinate validation, then the write has
no effect.


[[textures-output-sparse-validation]]
=== 稀疏纹素操作

If the texel attempts to write to an unbound region of a sparse image, the
texel is a sparse unbound texel.
In such a case, if the sname:VkPhysicalDeviceSparseProperties property
pname:residencyNonResidentStrict is ename:VK_TRUE, the sparse unbound texel
write has no effect.
If pname:residencyNonResidentStrict is ename:VK_FALSE, the effect of the
write is undefined but must: be safe.
In addition, the write may: have a side effect that is visible to other
image instructions, but must: not be written to any device memory
allocation.


[[textures-output-format-conversion]]
=== Texel Output Format Conversion

Texels undergo a format conversion from the floating point, signed, or
unsigned integer type of the texel data to the elink:VkFormat of the image
view.
Any unused components are ignored.

Each component is converted based on its type和size (as defined in the
<<features-formats-definition,Format Definition>> section for each
elink:VkFormat), using the appropriate equations in
<<fundamentals-fp16,16-Bit Floating-Point Numbers>> and
<<fundamentals-fixedconv,Fixed-Point Data Conversion>>.


== 求导操作

SPIR-V 求导指令包括 code:OpDPdx, code:OpDPdy,
code:OpDPdxFine, code:OpDPdyFine, code:OpDPdxCoarse,和code:OpDPdyCoarse.
求导指令只在片元着色器中可被使用。 

image::images/vulkantexture2.png[align="center",title="Implicit Derivatives",{fullimagewidth}]

若对于一个片元着色调用而言，存在一个2x2 邻接的片元区域，那么就会进行求导计算。
这些临近片元被用于计算导数时，其前提条件是临近区的P的值是分段线性的。
更大的前提条件是临近区的P的值是局部连续的，一次在非均匀控制流中导数是未定义的。 

[latexmath]
+++++++++++++++++++
\begin{aligned}
dPdx_{i_1,j_0} & = dPdx_{i_0,j_0} & = P_{i_1,j_0} - P_{i_0,j_0}  \\
dPdx_{i_1,j_1} & = dPdx_{i_0,j_1} & = P_{i_1,j_1} - P_{i_0,j_1}  \\
\\
dPdy_{i_0,j_1} & = dPdy_{i_0,j_0} & = P_{i_0,j_1} - P_{i_0,j_0}  \\
dPdy_{i_1,j_1} & = dPdy_{i_1,j_0} & = P_{i_1,j_1} - P_{i_1,j_0}
\end{aligned}
+++++++++++++++++++

The code:Fine derivative instructions must: return the values above, for a
group of fragments in a 2x2 neighborhood.
Coarse derivatives may: return only two values.
In this case, the values should: be:

[latexmath]
+++++++++++++++++++
\begin{aligned}
dPdx & =
  \begin{cases}
    dPdx_{i_0,j_0} & \text{preferred}\\
    dPdx_{i_0,j_1}
  \end{cases} \\
dPdy & =
  \begin{cases}
    dPdy_{i_0,j_0} & \text{preferred}\\
    dPdy_{i_1,j_0}
  \end{cases}
\end{aligned}
+++++++++++++++++++

code:OpDPdx和code:OpDPdy must: return the same result as either
code:OpDPdxFine or code:OpDPdxCoarse和either code:OpDPdyFine or
code:OpDPdyCoarse, respectively.
Implementations must: make the same choice of either coarse or fine for both
code:OpDPdx和code:OpDPdy,和implementations should: make the choice
that is more efficient to compute.


[[textures-normalized-operations]]
== 归一化坐标操作

若图像采样器指令提供了归一化的纹素坐标，就会执行如下操作中的一部分。


[[textures-projection]]
=== 投影操作

对于一些 code:Proj 图像操作，归一化的纹素坐标
[eq]#(s,t,r,q,a)#和(若有的话) [eq]#D~ref~# 坐标会按照如下形式转换：

[latexmath]
+++++++++++++++++++
\begin{aligned}
s       & = \frac{s}{q},       & \text{for 1D, 2D, or 3D image} \\
\\
t       & = \frac{t}{q},       & \text{for 2D or 3D image} \\
\\
r       & = \frac{r}{q},       & \text{for 3D image} \\
\\
D_{ref} & = \frac{D_{ref}}{q}, & \text{if provided}
\end{aligned}
+++++++++++++++++++


=== 图像操作求导

求导被用于 level-of-detail 选择。
这些导数要么是隐式的  ( 片元着色器内code:ImplicitLod 图像指令
instruction in a fragment shader)，要么是显式的  (provided explicitly by shader
to the image instruction in any shader).

For implicit derivatives image instructions, the derivatives of texel
coordinates are calculated in the same manner as derivative operations
above.
That is:

[latexmath]
+++++++++++++++++++
\begin{aligned}
\partial{s}/\partial{x} & = dPdx(s), & \partial{s}/\partial{y} & = dPdy(s), & \text{for 1D, 2D, Cube, or 3D image} \\
\partial{t}/\partial{x} & = dPdx(t), & \partial{t}/\partial{y} & = dPdy(t), & \text{for 2D, Cube, or 3D image} \\
\partial{u}/\partial{x} & = dPdx(u), & \partial{u}/\partial{y} & = dPdy(u), & \text{for Cube or 3D image}
\end{aligned}
+++++++++++++++++++

Partial derivatives not defined above for certain image dimensionalities are
set to zero.

For explicit level-of-detail image instructions, if the optional: SPIR-V
operand [eq]#Grad# is provided, then the operand values are used for the
derivatives.
The number of components present in each derivative for a given image
dimensionality matches the number of partial derivatives computed above.

If the optional: SPIR-V operand [eq]#Lod# is provided, then derivatives are
set to zero, the cube map derivative transformation is skipped,和the
scale factor operation is skipped.
Instead, the floating point scalar coordinate is directly assigned to
[eq]#{lambda}~base~# as described in
<<textures-level-of-detail-operation,Level-of-Detail Operation>>.


=== Cube Map Face Selection和Transformations

For cube map image instructions, the [eq]#(s,t,r)# coordinates are treated
as a direction vector [eq]#(r~x~,r~y~,r~z~)#.
The direction vector is used to select a cube map face.
The direction vector is transformed to a per-face texel coordinate system
[eq]#(s~face~,t~face~)#, The direction vector is also used to transform the
derivatives to per-face derivatives.


=== Cube Map Face Selection

The direction vector selects one of the cube map's faces based on the
largest magnitude coordinate direction (the major axis direction).
Since two or more coordinates can: have identical magnitude, the
implementation must: have rules to disambiguate this situation.

The rules should: have as the first rule that [eq]#r~z~# wins over
[eq]#r~y~#和[eq]#r~x~#,和the second rule that [eq]#r~y~# wins over
[eq]#r~x~#.
An implementation may: choose other rules, but the rules must: be
deterministic和depend only on [eq]#(r~x~,r~y~,r~z~)#.

The layer number (corresponding to a cube map face), the coordinate
selections for [eq]#s~c~#, [eq]#t~c~#, [eq]#r~c~#,和the selection of
derivatives, are determined by the major axis direction as specified in the
following two tables.

.Cube map face和coordinate selection
[width="75%",frame="all",options="header"]
|====
| Major Axis Direction | Layer Number | Cube Map Face | [eq]#s~c~#  | [eq]#t~c~#  | [eq]#r~c~#
| [eq]#+r~x~#          | [eq]#0#      | Positive X    | [eq]#-r~z~# | [eq]#-r~y~# | [eq]#r~x~#
| [eq]#-r~x~#          | [eq]#1#      | Negative X    | [eq]#+r~z~# | [eq]#-r~y~# | [eq]#r~x~#
| [eq]#+r~y~#          | [eq]#2#      | Positive Y    | [eq]#+r~x~# | [eq]#+r~z~# | [eq]#r~y~#
| [eq]#-r~y~#          | [eq]#3#      | Negative Y    | [eq]#+r~x~# | [eq]#-r~z~# | [eq]#r~y~#
| [eq]#+r~z~#          | [eq]#4#      | Positive Z    | [eq]#+r~x~# | [eq]#-r~y~# | [eq]#r~z~#
| [eq]#-r~z~#          | [eq]#5#      | Negative Z    | [eq]#-r~x~# | [eq]#-r~y~# | [eq]#r~z~#
|====


.Cube map derivative selection
[width="75%",frame="all",options="header"]
|====
| Major Axis Direction | [eq]#{partial}s~c~ / {partial}x# | [eq]#{partial}s~c~ / {partial}y# | [eq]#{partial}t~c~ / {partial}x# | [eq]#{partial}t~c~ / {partial}y# | [eq]#{partial}r~c~ / {partial}x# | [eq]#{partial}r~c~ / {partial}y#

| [eq]#+r~x~#
| [eq]#-{partial}r~z~ / {partial}x# | [eq]#-{partial}r~z~ / {partial}y#
| [eq]#-{partial}r~y~ / {partial}x# | [eq]#-{partial}r~y~ / {partial}y#
| [eq]#+{partial}r~x~ / {partial}x# | [eq]#+{partial}r~x~ / {partial}y#

| [eq]#-r~x~#
| [eq]#+{partial}r~z~ / {partial}x# | [eq]#+{partial}r~z~ / {partial}y#
| [eq]#-{partial}r~y~ / {partial}x# | [eq]#-{partial}r~y~ / {partial}y#
| [eq]#-{partial}r~x~ / {partial}x# | [eq]#-{partial}r~x~ / {partial}y#

| [eq]#+r~y~#
| [eq]#+{partial}r~x~ / {partial}x# | [eq]#+{partial}r~x~ / {partial}y#
| [eq]#+{partial}r~z~ / {partial}x# | [eq]#+{partial}r~z~ / {partial}y#
| [eq]#+{partial}r~y~ / {partial}x# | [eq]#+{partial}r~y~ / {partial}y#

| [eq]#-r~y~#
| [eq]#+{partial}r~x~ / {partial}x# | [eq]#+{partial}r~x~ / {partial}y#
| [eq]#-{partial}r~z~ / {partial}x# | [eq]#-{partial}r~z~ / {partial}y#
| [eq]#-{partial}r~y~ / {partial}x# | [eq]#-{partial}r~y~ / {partial}y#

| [eq]#+r~z~#
| [eq]#+{partial}r~x~ / {partial}x# | [eq]#+{partial}r~x~ / {partial}y#
| [eq]#-{partial}r~y~ / {partial}x# | [eq]#-{partial}r~y~ / {partial}y#
| [eq]#+{partial}r~z~ / {partial}x# | [eq]#+{partial}r~z~ / {partial}y#

| [eq]#-r~z~#
| [eq]#-{partial}r~x~ / {partial}x# | [eq]#-{partial}r~x~ / {partial}y#
| [eq]#-{partial}r~y~ / {partial}x# | [eq]#-{partial}r~y~ / {partial}y#
| [eq]#-{partial}r~z~ / {partial}x# | [eq]#-{partial}r~z~ / {partial}y#
|====


=== Cube Map Coordinate Transformation

[latexmath]
++++++++++++++++++++++++
\begin{aligned}
s_{face} & =
    \frac{1}{2} \times \frac{s_c}{|r_c|} + \frac{1}{2} \\
t_{face} & =
    \frac{1}{2} \times \frac{t_c}{|r_c|} + \frac{1}{2} \\
\end{aligned}
++++++++++++++++++++++++


=== Cube Map Derivative Transformation

[latexmath]
++++++++++++++++++++++++
\begin{aligned}
\frac{\partial{s_{face}}}{\partial{x}} &=
    \frac{\partial}{\partial{x}} \left ( \frac{1}{2} \times \frac{s_{c}}{|r_{c}|}
    + \frac{1}{2}\right ) \\
\frac{\partial{s_{face}}}{\partial{x}} &=
    \frac{1}{2} \times \frac{\partial}{\partial{x}}
    \left ( \frac{s_{c}}{|r_{c}|}  \right ) \\
\frac{\partial{s_{face}}}{\partial{x}} &=
    \frac{1}{2} \times
    \left (
    \frac{
      |r_{c}| \times \partial{s_c}/\partial{x}
      -s_c \times {\partial{r_{c}}}/{\partial{x}}}
    {\left ( r_{c} \right )^2}
    \right )
\end{aligned}
++++++++++++++++++++++++

[latexmath]
++++++++++++++++++++++++
\begin{aligned}
\frac{\partial{s_{face}}}{\partial{y}} &=
    \frac{1}{2} \times
    \left (
    \frac{
      |r_{c}| \times \partial{s_c}/\partial{y}
      -s_c \times {\partial{r_{c}}}/{\partial{y}}}
    {\left ( r_{c} \right )^2}
    \right )\\
\frac{\partial{t_{face}}}{\partial{x}} &=
    \frac{1}{2} \times
    \left (
    \frac{
      |r_{c}| \times \partial{t_c}/\partial{x}
      -t_c \times {\partial{r_{c}}}/{\partial{x}}}
    {\left ( r_{c} \right )^2}
    \right ) \\
\frac{\partial{t_{face}}}{\partial{y}} &=
    \frac{1}{2} \times
    \left (
    \frac{
       |r_{c}| \times \partial{t_c}/\partial{y}
      -t_c \times {\partial{r_{c}}}/{\partial{y}}}
    {\left ( r_{c} \right )^2}
    \right )
\end{aligned}
++++++++++++++++++++++++

ifdef::editing-notes[]
[NOTE]
.editing-note
==================
(Bill) Note that we never revisited ARB_texture_cubemap after we introduced
dependent texture fetches (ARB_fragment_program和ARB_fragment_shader).

The derivatives of [eq]#s~face~#和[eq]#t~face~# are only valid for
non-dependent texture fetches (pre OpenGL 2.0).
==================
endif::editing-notes[]


=== Scale Factor Operation, Level-of-Detail Operation和Image Level(s) Selection

Level-of-detail selection can: be either explicit (provided explicitly by
the image instruction) or implicit (determined from a scale factor
calculated from the derivatives).


[[textures-scale-factor]]
==== 缩放因子操作

The magnitude of the derivatives are calculated by:

  :: [eq]#m~ux~ = {vert}{partial}s/{partial}x{vert} {times} w~base~#
  :: [eq]#m~vx~ = {vert}{partial}t/{partial}x{vert} {times} h~base~#
  :: [eq]#m~wx~ = {vert}{partial}r/{partial}x{vert} {times} d~base~#

  :: [eq]#m~uy~ = {vert}{partial}s/{partial}y{vert} {times} w~base~#
  :: [eq]#m~vy~ = {vert}{partial}t/{partial}y{vert} {times} h~base~#
  :: [eq]#m~wy~ = {vert}{partial}r/{partial}y{vert} {times} d~base~#


where:

  :: [eq]#{partial}t/{partial}x = {partial}t/{partial}y = 0# (for 1D images)
  :: [eq]#{partial}r/{partial}x = {partial}r/{partial}y = 0# (for 1D, 2D or
     Cube images)

and

  :: [eq]#w~base~ = image.w#
  :: [eq]#h~base~ = image.h#
  :: [eq]#d~base~ = image.d#

(for the pname:baseMipLevel, from the image descriptor).


A point sampled in screen space has an elliptical footprint in texture
space.
The minimum和maximum scale factors [eq]#({rho}~min~, {rho}~max~)# should:
be the minor和major axes of this ellipse.

The _scale factors_ [eq]#{rho}~x~#和[eq]#{rho}~y~#, calculated from the
magnitude of the derivatives in x和y, are used to compute the minimum and
maximum scale factors.

[eq]#{rho}~x~#和[eq]#{rho}~y~# may: be approximated with functions
[eq]#f~x~#和[eq]#f~y~#, subject to the following constraints:

[latexmath]
++++++++++++++++++++++++
\begin{aligned}
& f_x \text{\ is\ continuous\ and\ monotonically\ increasing\ in\ each\ of\ }
    m_{ux},
    m_{vx}, \text{\ and\ }
    m_{wx} \\
& f_y \text{\ is\ continuous\ and\ monotonically\ increasing\ in\ each\ of\ }
    m_{uy},
    m_{vy}, \text{\ and\ }
    m_{wy}
\end{aligned}
++++++++++++++++++++++++

[latexmath]
++++++++++++++++++++++++
\begin{aligned}
\max(|m_{ux}|, |m_{vx}|, |m_{wx}|) \leq f_{x}
\leq \sqrt{2} (|m_{ux}| + |m_{vx}| + |m_{wx}|) \\
\max(|m_{uy}|, |m_{vy}|, |m_{wy}|) \leq f_{y}
\leq \sqrt{2} (|m_{uy}| + |m_{vy}| + |m_{wy}|)
\end{aligned}
++++++++++++++++++++++++


ifdef::editing-notes[]
[NOTE]
.editing-note
==================
(Bill) For reviewers only - anticipating questions.

We only support implicit derivatives for normalized texel coordinates.

So we are documenting the derivatives in s,t,r (normalized texel
coordinates) rather than u,v,w (unnormalized texel coordinates) as in OpenGL
and OpenGL ES specifications.
(I know, u,v,w is the way it has been documented since OpenGL V1.0.)

Also there is no reason to have conditional application of [eq]#w~base~,
h~base~, d~base~# for rectangle textures either, since they do not support
implicit derivatives.
==================
endif::editing-notes[]


The minimum和maximum scale factors [eq]#({rho}~min~,{rho}~max~)# are
determined by:

  :: [eq]#{rho}~max~ = max({rho}~x~, {rho}~y~)#
  :: [eq]#{rho}~min~ = min({rho}~x~, {rho}~y~)#

采样率由如下决定：

[latexmath]
++++++++++++++++++++++++
\begin{aligned}
N & = \min \left (\left \lceil \frac{\rho_{max}}{\rho_{min}}  \right \rceil ,max_{Aniso} \right )
\end{aligned}
++++++++++++++++++++++++

where:

  :: [eq]#sampler.max~Aniso~ = pname:maxAnisotropy# (from sampler
     descriptor)
  :: [eq]#limits.max~Aniso~ = pname:maxSamplerAnisotropy# (from physical
     device limits)
  :: [eq]#max~Aniso~ = min(sampler.max~Aniso~, limits.max~Aniso~)#

If [eq]#{rho}~max~ = {rho}~min~ = 0#, then all the partial derivatives are
zero, the fragment's footprint in texel space is a point,和[eq]#N#
should: be treated as 1.
If [eq]#{rho}~max~ {neq} 0#和[eq]#{rho}~min~ = 0# then all partial
derivatives along one axis are zero, the fragment's footprint in texel space
is a line segment,和[eq]#N# should: be treated as [eq]#max~Aniso~#.
However, anytime the footprint is small in texel space the implementation
may: use a smaller value of [eq]#N#, even when [eq]#{rho}~min~# is zero or
close to zero.

An implementation may: round [eq]#N# up to the nearest supported sampling
rate.

If [eq]#N = 1#, sampling is isotropic.
If [eq]#N > 1#, sampling is anisotropic.


[[textures-level-of-detail-operation]]
==== Level-of-Detail Operation

The _level-of-detail_ parameter [eq]#{lambda}# is computed as follows:

[latexmath]
++++++++++++++++++++++++
\begin{aligned}
\lambda_{base}(x,y) & =
  \begin{cases}
    shaderOp.Lod                                 & \text{(from optional SPIR-V operand)} \\
    \log_2 \left ( \frac{\rho_{max}}{N} \right ) & \text{otherwise}
  \end{cases} \\
\lambda'(x,y)       & = \lambda_{base} + \mathbin{clamp}(sampler.bias + shaderOp.bias,-maxSamplerLodBias,maxSamplerLodBias) \\
\lambda             & =
  \begin{cases}
    lod_{max}, & \lambda' > lod_{max} \\
    \lambda',  & lod_{min} \leq \lambda' \leq lod_{max} \\
    lod_{min}, & \lambda' < lod_{min} \\
    undefined, & lod_{min} > lod_{max} \\
  \end{cases}
\end{aligned}
++++++++++++++++++++++++

where:

[latexmath]
++++++++++++++++++++++++
\begin{aligned}
sampler.bias       & = mipLodBias & \text{(from sampler descriptor)} \\
shaderOp.bias      & =
  \begin{cases}
    Bias & \text{(from optional SPIR-V operand)} \\
    0    & \text{otherwise}
  \end{cases} \\
sampler.lod_{min}  & = minLod & \text{(from sampler descriptor)} \\
shaderOp.lod_{min} & =
  \begin{cases}
    MinLod & \text{(from optional SPIR-V operand)} \\
    0      & \text{otherwise}
  \end{cases} \\
\\
lod_{min}          & = \max(sampler.lod_{min}, shaderOp.lod_{min}) \\
lod_{max}          & = maxLod & \text{(from sampler descriptor)}
\end{aligned}
++++++++++++++++++++++++

and [eq]#maxSamplerLodBias# is the value of the slink:VkPhysicalDeviceLimits
feature <<features-limits-maxSamplerLodBias,pname:maxSamplerLodBias>>.


[[textures-image-level-selection]]
==== Image Level(s) Selection

The image level(s) [eq]#d#, [eq]#d~hi~#,和[eq]#d~lo~# which texels are
read from are selected based on the level-of-detail parameter, as follows.
If the sampler's pname:mipmapMode is ename:VK_SAMPLER_MIPMAP_MODE_NEAREST,
then level d is used:

// The [.5em] extra spacing works around KaTeX github issue #603
[latexmath]
++++++++++++++++++++++++
\begin{aligned}
d =
  \begin{cases}
    level_{base},     & \lambda \leq 0 \\[.5em]
    nearest(\lambda), & \lambda > 0,
                        level_{base} + \lambda \leq
                        q + \frac{1}{2} \\[.5em]
    q,                & \lambda > 0,
                        level_{base} + \lambda > q + \frac{1}{2}
  \end{cases}
\end{aligned}
++++++++++++++++++++++++

where:

[latexmath]
++++++++++++++++++++++++
\begin{aligned}
nearest(\lambda) & =
  \begin{cases}
    \left \lceil level_{base}+\lambda + \frac{1}{2}\right \rceil - 1, &
        \text{preferred} \\
    \left \lfloor level_{base}+\lambda + \frac{1}{2}\right \rfloor,   &
        \text{alternative}
  \end{cases}
\end{aligned}
++++++++++++++++++++++++

and

  :: [eq]#q = pname:levelCount - 1#

pname:levelCount is taken from the pname:subresourceRange of the image view.

If the sampler's pname:mipmapMode is ename:VK_SAMPLER_MIPMAP_MODE_LINEAR,
two neighboring levels are selected:

[latexmath]
++++++++++++++++++++++++
\begin{aligned}
d_{hi} & =
  \begin{cases}
    q,                                                 & level_{base} + \lambda \geq q \\
    \left \lfloor level_{base}+\lambda \right \rfloor, & \text{otherwise}
  \end{cases} \\
d_{lo} & =
  \begin{cases}
    q,        & level_{base} + \lambda \geq q \\
    d_{hi}+1, & \text{otherwise}
  \end{cases}
\end{aligned}
++++++++++++++++++++++++

  :: [eq]#{delta} = frac({lambda})#

is the fractional value used for <<textures-texel-filtering, linear
filtering>> between levels.


[[textures-normalized-to-unnormalized]]
=== (s,t,r,q,a) 转换到 (u,v,w,a)

归一化纹素坐标被已选择的图像level维度和array layer缩放。
这种转换对于每个在<<textures-texel-filtering, 过滤>>中使用的level ([eq]#d# or [eq]#d~hi~# 和 [eq]#d~lo~#) 都会执行一次。 

[latexmath]
++++++++++++++++++++++++
\begin{aligned}
u(x,y) & = s(x,y) \times width_{level} \\
v(x,y) & =
  \begin{cases}
    0                         & \text{for 1D images} \\
    t(x,y) \times height_{level} & \text{otherwise}
  \end{cases} \\
w(x,y) & =
  \begin{cases}
    0                         & \text{for 2D or Cube images} \\
    r(x,y) \times depth_{level}  & \text{otherwise}
  \end{cases} \\
\\
a(x,y) & =
  \begin{cases}
    a(x,y)                    & \text{for array images} \\
    0                         & \text{otherwise}
  \end{cases}
\end{aligned}
++++++++++++++++++++++++

Operations then proceed to Unnormalized Texel Coordinate Operations.


== 非归一化纹素坐标


[[textures-unnormalized-to-integer]]
=== (u,v,w,a) 转换到 (i,j,k,l,n) ，Array Layer 选择

非归一化的纹素坐标被转换到相对于被选择的mipmap 等级的整型纹素坐标。

layer索引 [eq]#l# 计算如下:

  :: [eq]#l = clamp(RNE(a), 0, pname:layerCount - 1) + pname:baseArrayLayer#

where pname:layerCount is the number of layers in the image subresource
range of the image view, pname:baseArrayLayer is the first layer from the
subresource range,和where:

[latexmath]
++++++++++++++++++++++++
\begin{aligned}
\mathbin{RNE}(a) & =
  \begin{cases}
    \mathbin{roundTiesToEven}(a)                  & \text{preferred, from IEEE Std 754-2008 Floating-Point Arithmetic} \\
    \left \lfloor a + \frac{1}{2} \right \rfloor & \text{alternative}
  \end{cases}
\end{aligned}
++++++++++++++++++++++++

The sample index n is assigned the value zero.

Nearest filtering (ename:VK_FILTER_NEAREST) computes the integer texel
coordinates that the unnormalized coordinates lie within:

  :: [eq]#i = {lfloor} u {rfloor}#
  :: [eq]#j = {lfloor} v {rfloor}#
  :: [eq]#k = {lfloor} w {rfloor}#

Linear filtering (ename:VK_FILTER_LINEAR) computes a set of neighboring
coordinates which bound the unnormalized coordinates.
The integer texel coordinates are combinations of [eq]#i~0~# or [eq]#i~1~#,
[eq]#j~0~# or [eq]#j~1~#, [eq]#k~0~# or [eq]#k~1~#, as well as weights
[eq]#{alpha}, {beta}#,和[eq]#{gamma}#.

  :: [eq]#i~0~ = {lfloor}u - {onehalf}{rfloor}#
  :: [eq]#i~1~ = i~0~ + 1#
  :: [eq]#j~0~ = {lfloor}v - {onehalf}{rfloor}#
  :: [eq]#j~1~ = j~0~ + 1#
  :: [eq]#k~0~ = {lfloor}w - {onehalf}{rfloor}#
  :: [eq]#k~1~ = k~0~ + 1#

  :: [eq]#{alpha} = frac(u - {onehalf})#
  :: [eq]#{beta} = frac(v - {onehalf})#
  :: [eq]#{gamma} = frac(w - {onehalf})#

ifdef::VK_IMG_filter_cubic[]
include::VK_IMG_filter_cubic/filter_cubic_texel_selection.txt[]
endif::VK_IMG_filter_cubic[]

若图像指令包含一个  [eq]#ConstOffset# 操作数，那么常量偏移 [eq]#({DeltaUpper}~i~, {DeltaUpper}~j~, {DeltaUpper}~k~)# 就会被添加到 整型纹素坐标的每个成分 [eq]#(i,j,k)# 上。 


[[textures-sample-operations]]
== 图像采样操作


[[textures-wrapping-operation]]
=== Wrapping Operation

code:Cube images ignore the wrap modes specified in the sampler.
Instead, if ename:VK_FILTER_NEAREST is used within a mip level then
ename:VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE is used,和if
ename:VK_FILTER_LINEAR is used within a mip level then sampling at the edges
is performed as described earlier in the <<textures-cubemapedge,Cube map
edge handling>> section.

The first integer texel coordinate i is transformed based on the
pname:addressModeU parameter of the sampler.

[latexmath]
++++++++++++++++++++++++
\begin{aligned}
i &=
  \begin{cases}
    i \bmod size                                & \text{for repeat} \\
    (size - 1) - \mathbin{mirror}
        ((i \bmod (2 \times size)) - size)      & \text{for mirrored repeat} \\
    \mathbin{clamp}(i,0,size-1)                  & \text{for clamp to edge} \\
    \mathbin{clamp}(i,-1,size)                   & \text{for clamp to border} \\
    \mathbin{clamp}(\mathbin{mirror}(i),0,size-1) & \text{for mirror clamp to edge}
  \end{cases}
\end{aligned}
++++++++++++++++++++++++

where:

[latexmath]
++++++++++++++++++++++++
\begin{aligned}
& \mathbin{mirror}(n) =
  \begin{cases}
    n      & \text{for}\  n \geq 0 \\
    -(1+n) & \text{otherwise}
  \end{cases}
\end{aligned}
++++++++++++++++++++++++

[eq]#j# (for 2D和Cube image)和[eq]#k# (for 3D image) are similarly
transformed based on the pname:addressModeV和pname:addressModeW
parameters of the sampler, respectively.


[[textures-gather]]
=== 纹素采集

带有 code:Gather的SPIR-V  指令返回一个数组，该数组源自图像视图base level的一个 2x2 矩形区域的纹素。

The rules for the 应用到ename:VK_FILTER_LINEAR 缩小 filter 的规则 确定了四个被选择的纹素。
每个纹素然后按照<<textures-conversion-to-rgba, 转换到RGBA>>被转换到一个RGBA 值，然后被<<textures-component-swizzle,swizzled>>。
 A four-component vector is then assembled by taking the component indicated
by the code:Component value in the instruction from the swizzled color value
of the four texels:

[latexmath]
++++++++++++++++++++++++
\begin{aligned}
\tau[R] &= \tau_{i0j1}[level_{base}][comp] \\
\tau[G] &= \tau_{i1j1}[level_{base}][comp] \\
\tau[B] &= \tau_{i1j0}[level_{base}][comp] \\
\tau[A] &= \tau_{i0j0}[level_{base}][comp]
\end{aligned}
++++++++++++++++++++++++

where:

[latexmath]
++++++++++++++++++++++++
\begin{aligned}
\tau[level_{base}][comp] &=
  \begin{cases}
    \tau[level_{base}][R], & \text{for}\  comp = 0 \\
    \tau[level_{base}][G], & \text{for}\  comp = 1 \\
    \tau[level_{base}][B], & \text{for}\  comp = 2 \\
    \tau[level_{base}][A], & \text{for}\  comp = 3
  \end{cases}\\
comp & \,\text{from SPIR-V operand Component}
\end{aligned}
++++++++++++++++++++++++


[[textures-texel-filtering]]
=== 纹素过滤

若 [eq]#{lambda}# 是小于等于0的，纹素就被认为是放大了，采样器中pname:magFilter 选择mip level中一个过滤模式。
若 [eq]#{lambda}# 是大于0，纹素就被认为是缩小了，采样器中 pname:minFilter 选择mip level中一个过滤模式。

一个 mip level中， ename:VK_FILTER_NEAREST 过滤过程使用[eq]#(i, j, k)# 纹素坐标从layer l中所有纹素 选择了单个值。

[latexmath]
++++++++++++++++++++++++
\begin{aligned}
\tau[level] &=
  \begin{cases}
     \tau_{ijk}[level], & \text{for 3D image} \\
     \tau_{ij}[level],  & \text{for 2D or Cube image} \\
     \tau_{i}[level],   & \text{for 1D image}
   \end{cases}
\end{aligned}
++++++++++++++++++++++++

Within a mip level, ename:VK_FILTER_LINEAR filtering computes a weighted
average of 8 (for 3D), 4 (for 2D or Cube), or 2 (for 1D) texel values, using
the weights computed earlier:

[latexmath]
++++++++++++++++++++++++
\begin{aligned}
\tau_{3D}[level] & = (1-\alpha)(1-\beta)(1-\gamma)\tau_{i0j0k0}[level] \\
          & \, + (\alpha)(1-\beta)(1-\gamma)\tau_{i1j0k0}[level] \\
          & \, + (1-\alpha)(\beta)(1-\gamma)\tau_{i0j1k0}[level] \\
          & \, + (\alpha)(\beta)(1-\gamma)\tau_{i1j1k0}[level]   \\
          & \, + (1-\alpha)(1-\beta)(\gamma)\tau_{i0j0k1}[level] \\
          & \, + (\alpha)(1-\beta)(\gamma)\tau_{i1j0k1}[level]   \\
          & \, + (1-\alpha)(\beta)(\gamma)\tau_{i0j1k1}[level]   \\
          & \, + (\alpha)(\beta)(\gamma)\tau_{i1j1k1}[level]
\end{aligned}
++++++++++++++++++++++++

[latexmath]
++++++++++++++++++++++++
\begin{aligned}
\tau_{2D}[level] & = (1-\alpha)(1-\beta)\tau_{i0j0}[level] \\
          & \, + (\alpha)(1-\beta)\tau_{i1j0}[level] \\
          & \, + (1-\alpha)(\beta)\tau_{i0j1}[level] \\
          & \, + (\alpha)(\beta)\tau_{i1j1}[level]
\end{aligned}
++++++++++++++++++++++++

[latexmath]
++++++++++++++++++++++++
\begin{aligned}
\tau_{1D}[level] & = (1-\alpha)\tau_{i0}[level] \\
          & \, + (\alpha)\tau_{i1}[level]
\end{aligned}
++++++++++++++++++++++++

[latexmath]
++++++++++++++++++++++++
\begin{aligned}
\tau[level] &=
  \begin{cases}
     \tau_{3D}[level], & \text{for 3D image} \\
     \tau_{2D}[level], & \text{for 2D or Cube image} \\
     \tau_{1D}[level], & \text{for 1D image}
   \end{cases}
\end{aligned}
++++++++++++++++++++++++


ifdef::VK_IMG_filter_cubic[]
include::VK_IMG_filter_cubic/filter_cubic_texel_filtering.txt[]
endif::VK_IMG_filter_cubic[]

Finally, mipmap filtering either selects a value from one mip level or
computes a weighted average between neighboring mip levels:

[latexmath]
++++++++++++++++++++++++
\begin{aligned}
\tau &=
  \begin{cases}
    \tau[d], & \text{for mip mode BASE or NEAREST} \\
    (1-\delta)\tau[d_{hi}]+\delta\tau[d_{lo}], & \text{for mip mode LINEAR}
  \end{cases}
\end{aligned}
++++++++++++++++++++++++


[[textures-texel-anisotropic-filtering]]
=== 纹素各向异性过滤

在采样器中通过pname:anisotropyEnable 启用各向异性过滤。
当被启用来，图像过滤方案占各向异性的角度。

各向异性纹理过滤的方案是依赖于vulkan实现。
实现应该考虑  采样器的pname:magFilter, pname:minFilter 和
pname:mipmapMode 来控制使用的各向异性过滤方案。
另外，实现应该考虑 采样器的 pname:minLod和pname:maxLod。

The following describes one particular approach to implementing anisotropic
filtering for the 2D Image case, implementations may: choose other methods:

Given a pname:magFilter, pname:minFilter of ename:VK_FILTER_LINEAR和a
pname:mipmapMode of ename:VK_SAMPLER_MIPMAP_MODE_NEAREST:

Instead of a single isotropic sample, N isotropic samples are be sampled
within the image footprint of the image level [eq]#d# to approximate an
anisotropic filter.
The sum [eq]#{tau}~2Daniso~# is defined using the single isotropic
[eq]#{tau}~2D~(u,v)# at level [eq]#d#.

[latexmath]
++++++++++++++++++++++++
\begin{aligned}
\tau_{2Daniso} & =
     \frac{1}{N}\sum_{i=1}^{N}
     {\tau_{2D}\left (
       u \left ( x - \frac{1}{2} + \frac{i}{N+1} , y \right ),
         \left ( v \left (x-\frac{1}{2}+\frac{i}{N+1} \right ), y
\right )
     \right )},
     & \text{when}\  \rho_{x} > \rho_{y} \\
\tau_{2Daniso} &=
     \frac{1}{N}\sum_{i=1}^{N}
     {\tau_{2D}\left (
        u \left  ( x, y - \frac{1}{2} + \frac{i}{N+1} \right ),
          \left ( v \left (x,y-\frac{1}{2}+\frac{i}{N+1} \right )
\right )
     \right )},
     & \text{when}\  \rho_{y} \geq \rho_{x}
\end{aligned}
++++++++++++++++++++++++

ifdef::editing-notes[]
[NOTE]
.editing-note
==================
(Bill) EXT_texture_filter_anisotropic has not been updated since 2000,
except for ES extension number (2007)和a minor speeling (sic) correction
(2014), neither of which are functional changes.
It is showing its age.

In particular, there is an open issue about 3D textures.

There are no interactions with ARB_texture_cube_map (approved 1999, promoted
to core OpenGL 1.3 in 2001), let alone interactions with
ARB_seamless_cube_map (approved和promoted to core OpenGL 3.2 in 2009).

There are no interactions with texture offsets or texture gather.
==================
endif::editing-notes[]


[[textures-instructions]]
== 图像操作步骤 

本章中描述的每一步被图像指令的子集所执行。


  * 纹素输入验证操作，格式转换，纹素替换，转换至RGBA，和 元素 Swizzle: 由所有指令执行，除了 code:OpImageWrite。
  * 深度比较 : 由 code:OpImage*code:Dref 指令执行。
  * 所有纹素输出操作 :  由 code:OpImageWrite指令执行。
  * 投影: 由所有code:OpImage*code:Proj 指令执行。
  * 图像操作求导，立体贴图操作，缩放因子操作，Level-of-Detail 操作 和 图像 Level(s) 选择，和纹素各向异性过滤：
    由所有  code:OpImageSample* 和
    code:OpImageSparseSample* 指令执行。
  * (s,t,r,q,a) 转换到 (u,v,w,a) , Wrapping，和(u,v,w,a) 转换到 (i,j,k,l,n)，和 Array Layer 选择: 
    由所有code:OpImageSample, code:OpImageSparseSample, 和    code:OpImage*code:Gather 指令执行。
  * 纹素采集 : 由 code:OpImage*code:Gather 指令执行。
  * 纹素过滤 : 由所有 code:OpImageSample* 和 code:OpImageSparseSample* 指令执行。
  * 稀疏驻存 : 由所有 code:OpImageSparse* 指令执行。
