// Copyright (c) 2015-2017 The Khronos Group Inc.
// Copyright notice at https://www.khronos.org/registry/speccopyright.html

[[descriptorsets]]
= 资源描述符

着色器通过使用特殊的着色器变量(通过API间接绑定到缓冲区或者图像视图)来访问缓冲区和图像资源。
这些变量被组织进入集合，每一个绑定的集合都通过API的一个 _描述符集合_ 对象来表示，描述符集合只能被绑定一次。
一个 _描述符_ 是一个不透明的数据类型，表示一个着色器资源，诸如缓冲区视图、图像视图、采样器或者被绑定的着色器资源。
每一个集合的内容由它自己的 _描述集合布局_ 来决定，可以被管线内部的着色器资源变量使用的集合布局的序列由  _pipeline layout_ 指定。

每一个着色器可以使用最多pname:maxBoundDescriptorSets 个描述符集合（参考<<features-limits, Limits>>），
每一个描述符集合可以包含所有类型描述符的绑定。
每一个着色器资源变量都被赋值为一个tuple（集合个数，绑定个数，数组元素），定义了它在描述集合布局中的位置。
在GLSL中，集合个数和绑定个数是通过布局限定符赋值的，数组元素是被连续的赋值到其中，数组中第一个元素的索引为0（非数组变量的位置用0填充）。


.GLSL example
[source,glsl]
---------------------------------------------------
// Assign set number = M, binding number = N, array element = 0
layout (set=M, binding=N) uniform sampler2D variableName;

// Assign set number = M, binding number = N for all array elements, and
// array element = I for the I'th member of the array.
layout (set=M, binding=N) uniform sampler2D variableNameArray[I];
---------------------------------------------------

.SPIR-V example
[source,spirv]
---------------------------------------------------
// Assign set number = M, binding number = N, array element = 0
               ...
          %1 = OpExtInstImport "GLSL.std.450"
               ...
               OpName %10 "variableName"
               OpDecorate %10 DescriptorSet M
               OpDecorate %10 Binding N
          %2 = OpTypeVoid
          %3 = OpTypeFunction %2
          %6 = OpTypeFloat 32
          %7 = OpTypeImage %6 2D 0 0 0 1 Unknown
          %8 = OpTypeSampledImage %7
          %9 = OpTypePointer UniformConstant %8
         %10 = OpVariable %9 UniformConstant
               ...

// Assign set number = M, binding number = N for all array elements, and
// array element = I for the I'th member of the array.
               ...
          %1 = OpExtInstImport "GLSL.std.450"
               ...
               OpName %13 "variableNameArray"
               OpDecorate %13 DescriptorSet M
               OpDecorate %13 Binding N
          %2 = OpTypeVoid
          %3 = OpTypeFunction %2
          %6 = OpTypeFloat 32
          %7 = OpTypeImage %6 2D 0 0 0 1 Unknown
          %8 = OpTypeSampledImage %7
          %9 = OpTypeInt 32 0
         %10 = OpConstant %9 I
         %11 = OpTypeArray %8 %10
         %12 = OpTypePointer UniformConstant %11
         %13 = OpVariable %12 UniformConstant
               ...
---------------------------------------------------


[[descriptorsets-types]]
== 描述符类型
如下几个小节简单讲解Vulkan支持的各种描述符类型。
每一小节定义了一种描述符类型，每一种类型在着色器语言和SPIR-V中都有详细讲解。
描述符类型和着色器语言中不透明类型的类别大多数情况下是一对一的，着色器语言中不透明类型必须指代
对应描述符类型的管线布局中的一个描述符。
但是，对于此规则，如下情形是一个例外
<<descriptorsets-combinedimagesampler, Combined Image Sampler>>。


[[descriptorsets-storageimage]]
=== Storage Image

一个 _storage image_ (ename:VK_DESCRIPTOR_TYPE_STORAGE_IMAGE) 是一种描述符类型，
用于绑定到管线的着色器内部 对图像的装载、存储和原子操作。 

从 storage images 中装载并不会使用采样器，且是unfiltered，并不支持
坐标折叠与截断。
flink:vkGetPhysicalDeviceFormatProperties 指定的 <<features-formats-properties,ename:VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT>>
支持的图像格式都能在所有的着色器阶段中载入。

ename:VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT 格式图像可以在计算着色器中 存储到 storage images 。


<<features-formats-properties,ename:VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT>>
格式的图像可以支持在计算着色器中进行原子操作。

storage images 上的载入与存储操作，只能在
ename:VK_IMAGE_LAYOUT_GENERAL 布局的图像上进行。

当<<features-features-fragmentStoresAndAtomics,
pname:fragmentStoresAndAtomics>> 特征被启用，那么就可支持 对同一集合的图像格式的storage images 在
片元着色器阶段内执行 存储和原子操作。
当 <<features-features-vertexPipelineStoresAndAtomics, pname:vertexPipelineStoresAndAtomics>> 特征被启用时，
那么对 计算着色器阶段受支持的图像格式，同样也支持在顶点、细分、几何着色器阶段进行 存储和原子操作。


在着色器内，若变量被用于原子操作，Storage image 声明必须指定图像格式。 

若 <<features-features-shaderStorageImageReadWithoutFormat,
pname:shaderStorageImageReadWithoutFormat>> 特征没有被启用，在着色器内，若变量被用于载入操作， storage
image 声明必须指定图像格式。

若 <<features-features-shaderStorageImageWriteWithoutFormat,
pname:shaderStorageImageWriteWithoutFormat>> 特征没有被启用，在着色器内，若变量被用于存储操作，
 storage image 声明必须指定图像格式。


Storage images 在GLSL着色器源代码中使用 uniform code:image 声明一个变量为合适的维度，同样与指定格式布局描述:

.GLSL example
[source,glsl]
---------------------------------------------------
layout (set=m, binding=n, r32f) uniform image2D myStorageImage;
---------------------------------------------------

.SPIR-V example
[source,spirv]
---------------------------------------------------
               ...
          %1 = OpExtInstImport "GLSL.std.450"
               ...
               OpName %9 "myStorageImage"
               OpDecorate %9 DescriptorSet m
               OpDecorate %9 Binding n
          %2 = OpTypeVoid
          %3 = OpTypeFunction %2
          %6 = OpTypeFloat 32
          %7 = OpTypeImage %6 2D 0 0 0 2 R32f
          %8 = OpTypePointer UniformConstant %7
          %9 = OpVariable %8 UniformConstant
               ...
---------------------------------------------------


[[descriptorsets-sampler]]
=== 采样器
一个 _sampler_ (ename:VK_DESCRIPTOR_TYPE_SAMPLER) 代表一系列的参数，它控制了寻址计算，过滤行为，和其他的属性，
这可以被用于执行从一个 采样过的图像 进行过滤加载(参考 <<descriptorsets-sampledimage, 采样的图像>>)。

采样器时在GLSL着色器代码中使用 uniform code:sampler 来声明的变量，采样器类型并没有关联的纹理维度：


.GLSL Example
[source,glsl]
---------------------------------------------------
layout (set=m, binding=n) uniform sampler mySampler;
---------------------------------------------------

.SPIR-V example
[source,spirv]
---------------------------------------------------
               ...
          %1 = OpExtInstImport "GLSL.std.450"
               ...
               OpName %8 "mySampler"
               OpDecorate %8 DescriptorSet m
               OpDecorate %8 Binding n
          %2 = OpTypeVoid
          %3 = OpTypeFunction %2
          %6 = OpTypeSampler
          %7 = OpTypePointer UniformConstant %6
          %8 = OpVariable %7 UniformConstant
               ...
---------------------------------------------------


[[descriptorsets-sampledimage]]
=== 采样的图像

一个 _采样的图像_ (ename:VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE) 可以: 被用于从采样过的图像数据中提取数据
（通常联合使用一个采样器）。 着色器使用一个采样的图像handle，与 一个采样器handle来采样数据，图像handle通常定义里内存的
形状和格式，采样器通常定义了如何进行坐标系寻址。
同一个采样器可以被用于对多个图像，且可以使用多个采样器对同一个采样的图像进行采样，每一个都包含不同的采样参数。

采样的图像在GLSL着色器源代码中使用uniform code:texture 变量来声明，有合适维度：


.GLSL example
[source,glsl]
---------------------------------------------------
layout (set=m, binding=n) uniform texture2D mySampledImage;
---------------------------------------------------

.SPIR-V example
[source,spirv]
---------------------------------------------------
               ...
          %1 = OpExtInstImport "GLSL.std.450"
               ...
               OpName %9 "mySampledImage"
               OpDecorate %9 DescriptorSet m
               OpDecorate %9 Binding n
          %2 = OpTypeVoid
          %3 = OpTypeFunction %2
          %6 = OpTypeFloat 32
          %7 = OpTypeImage %6 2D 0 0 0 1 Unknown
          %8 = OpTypePointer UniformConstant %7
          %9 = OpVariable %8 UniformConstant
               ...
---------------------------------------------------


[[descriptorsets-combinedimagesampler]]
=== 联合图像采样器

一个 _combined image sampler_ (ename:VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER)
代表一个采样的图像，且带有一些采样参数。在逻辑上，他被认为是一个采样的图像，且绑定了一个采样器。

[NOTE]
.注意
====
On some implementations, it may: be more efficient to sample from an image
using a combination of sampler and sampled image that are stored together in
the descriptor set in a combined descriptor.
====

Combined image samplers are declared in GLSL shader source using uniform
code:sampler variables of the appropriate dimensionality:

.GLSL example
[source,glsl]
---------------------------------------------------
layout (set=m, binding=n) uniform sampler2D myCombinedImageSampler;
---------------------------------------------------

.SPIR-V example
[source,spirv]
---------------------------------------------------
               ...
          %1 = OpExtInstImport "GLSL.std.450"
               ...
               OpName %10 "myCombinedImageSampler"
               OpDecorate %10 DescriptorSet m
               OpDecorate %10 Binding n
          %2 = OpTypeVoid
          %3 = OpTypeFunction %2
          %6 = OpTypeFloat 32
          %7 = OpTypeImage %6 2D 0 0 0 1 Unknown
          %8 = OpTypeSampledImage %7
          %9 = OpTypePointer UniformConstant %8
         %10 = OpVariable %9 UniformConstant
               ...
---------------------------------------------------

ename:VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER descriptor set entries can:
also be accessed via separate sampler and sampled image shader variables.
Such variables refer exclusively to the corresponding half of the
descriptor, and can: be combined in the shader with samplers or sampled
images that can: come from the same descriptor or from other combined or
separate descriptor types.
There are no additional restrictions on how a separate sampler or sampled
image variable is used due to it originating from a combined descriptor.


[[descriptorsets-uniformtexelbuffer]]
=== Uniform Texel Buffer

A _uniform texel buffer_ (ename:VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER)
represents a tightly packed array of homogeneous formatted data that is
stored in a buffer and is made accessible to shaders.
Uniform texel buffers are read-only.

Uniform texel buffers are declared in GLSL shader source using uniform
code:samplerBuffer variables:

.GLSL example
[source,glsl]
---------------------------------------------------
layout (set=m, binding=n) uniform samplerBuffer myUniformTexelBuffer;
---------------------------------------------------

.SPIR-V example
[source,spirv]
---------------------------------------------------
               ...
          %1 = OpExtInstImport "GLSL.std.450"
               ...
               OpName %10 "myUniformTexelBuffer"
               OpDecorate %10 DescriptorSet m
               OpDecorate %10 Binding n
          %2 = OpTypeVoid
          %3 = OpTypeFunction %2
          %6 = OpTypeFloat 32
          %7 = OpTypeImage %6 Buffer 0 0 0 1 Unknown
          %8 = OpTypeSampledImage %7
          %9 = OpTypePointer UniformConstant %8
         %10 = OpVariable %9 UniformConstant
               ...
---------------------------------------------------


[[descriptorsets-storagetexelbuffer]]
=== 仓库纹素缓冲区

一个 _storage texel buffer_ (ename:VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER)
代表一个紧致压缩的同构格式数据数组，被存储在一个缓冲区，且着色器可访问。
仓库纹素缓冲区与 统一纹素缓冲区不同点在于它们支持存储和 着色器内原子操作，也支持不同的最大长度，亦可有不同的性能特征。

在GLSL源代码中，可使用统一code:imageBuffer变量来声明 仓储纹素缓冲区：


.GLSL example
[source,glsl]
---------------------------------------------------
layout (set=m, binding=n, r32f) uniform imageBuffer myStorageTexelBuffer;
---------------------------------------------------

.SPIR-V example
[source,spirv]
---------------------------------------------------
               ...
          %1 = OpExtInstImport "GLSL.std.450"
               ...
               OpName %9 "myStorageTexelBuffer"
               OpDecorate %9 DescriptorSet m
               OpDecorate %9 Binding n
          %2 = OpTypeVoid
          %3 = OpTypeFunction %2
          %6 = OpTypeFloat 32
          %7 = OpTypeImage %6 Buffer 0 0 0 2 R32f
          %8 = OpTypePointer UniformConstant %7
          %9 = OpVariable %8 UniformConstant
               ...
---------------------------------------------------


[[descriptorsets-uniformbuffer]]
=== 统一缓冲区

一个 _uniform buffer_ (ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER) 是一个结构化的存储区域，
对于着色器程序而言只能够只读访问。
它通常被用来初春中等字节大小的常量述祖，例如着色器参数，矩阵，其他相关的数据。

可在GLSL着色器源代码中使用 统一存储描述符和block语法来声明 统一缓冲区：

.GLSL example
[source,glsl]
---------------------------------------------------
layout (set=m, binding=n) uniform myUniformBuffer
{
    vec4 myElement[32];
};
---------------------------------------------------

.SPIR-V example
[source,spirv]
---------------------------------------------------
               ...
          %1 = OpExtInstImport "GLSL.std.450"
               ...
               OpName %11 "myUniformBuffer"
               OpMemberName %11 0 "myElement"
               OpName %13 ""
               OpDecorate %10 ArrayStride 16
               OpMemberDecorate %11 0 Offset 0
               OpDecorate %11 Block
               OpDecorate %13 DescriptorSet m
               OpDecorate %13 Binding n
          %2 = OpTypeVoid
          %3 = OpTypeFunction %2
          %6 = OpTypeFloat 32
          %7 = OpTypeVector %6 4
          %8 = OpTypeInt 32 0
          %9 = OpConstant %8 32
         %10 = OpTypeArray %7 %9
         %11 = OpTypeStruct %10
         %12 = OpTypePointer Uniform %11
         %13 = OpVariable %12 Uniform
               ...
---------------------------------------------------


[[descriptorsets-storagebuffer]]
=== 存储缓冲区

一个 _storage buffer_ (ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER) 是一个结构化存储的区域，
他支持着色器的读写访问。
除了常规读写操作，存储缓冲区的一些成员可被用于原子操作的对象。
总的来说，原子操作通常只支持有无符号整型格式的成员。

可在GLSL着色器源代码中使用缓冲区存储描述符和block语法来声明存储缓冲区：

.GLSL example
[source,glsl]
---------------------------------------------------
layout (set=m, binding=n) buffer myStorageBuffer
{
    vec4 myElement[];
};
---------------------------------------------------

.SPIR-V example
[source,spirv]
---------------------------------------------------
               ...
          %1 = OpExtInstImport "GLSL.std.450"
               ...
               OpName %9 "myStorageBuffer"
               OpMemberName %9 0 "myElement"
               OpName %11 ""
               OpDecorate %8 ArrayStride 16
               OpMemberDecorate %9 0 Offset 0
               OpDecorate %9 BufferBlock
               OpDecorate %11 DescriptorSet m
               OpDecorate %11 Binding n
          %2 = OpTypeVoid
          %3 = OpTypeFunction %2
          %6 = OpTypeFloat 32
          %7 = OpTypeVector %6 4
          %8 = OpTypeRuntimeArray %7
          %9 = OpTypeStruct %8
         %10 = OpTypePointer Uniform %9
         %11 = OpVariable %10 Uniform
               ...
---------------------------------------------------


[[descriptorsets-uniformbufferdynamic]]
=== 动态统一缓冲区

一个 _dynamic uniform buffer_ (ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC)
与统一缓冲区的唯一区别在于它的地址与长度是如何被指定的。
统一缓冲区与一个缓冲区地址绑定，长度在描述符集合更新的缓冲区handle、偏移与区间来指定(参考
<<descriptorsets-updates, Descriptor Set Updates>>)。
使用动态统一缓冲区指定缓冲区句柄、偏移量和范围 在描述符集中定义基本地址和长度。
相对于这个基础地址的动态偏移是从pname:pDynamicOffsets 参数取出到 flink:vkCmdBindDescriptorSets (参考
<<descriptorsets-binding, Descriptor Set Binding>>)。
用于动态统一缓冲区的地址是缓冲区base 地址和相对偏移之和。
长度未被改变，且保持区间为描述符更新中指定的大小。
动态缓冲区着色器语法和统一缓冲区一样。



[[descriptorsets-storagebufferdynamic]]
=== 动态仓储缓冲区

一个 _dynamic storage buffer_ (ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC)
与仓储缓冲区的唯一不同点是它的地址与长度是如何被指定的。
不同之处和统一缓冲区与动态缓冲区之间的差别是一样的(参考 <<descriptorsets-uniformbufferdynamic, Dynamic
Uniform Buffer>>).
动态仓储缓冲区着色器语法和仓储缓冲区的一样。



[[descriptorsets-inputattachment]]
=== 输入附件

一个 _input attachment_ (ename:VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT) 是一个图像时图，可以被用于
绑定到管线的片元着色器内像素局部载入操作。 
从输入附件中载入的内容是unfiltered。
对于一个给定图像的tiling模式 的颜色附件(ename:VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT)或者深度/stencil
(ename:VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT) 
 附件支持的所有图像格式 都为输入附件所支持。

在着色器内，除了描述符集合和绑定数量，输入附件必须 被它们的输入附件所引所描述。


.GLSL example
[source,glsl]
---------------------------------------------------
layout (input_attachment_index=i, set=m, binding=n) uniform subpassInput myInputAttachment;
---------------------------------------------------

.SPIR-V example
[source,spirv]
---------------------------------------------------
               ...
          %1 = OpExtInstImport "GLSL.std.450"
               ...
               OpName %9 "myInputAttachment"
               OpDecorate %9 DescriptorSet m
               OpDecorate %9 Binding n
               OpDecorate %9 InputAttachmentIndex i
          %2 = OpTypeVoid
          %3 = OpTypeFunction %2
          %6 = OpTypeFloat 32
          %7 = OpTypeImage %6 SubpassData 0 0 0 2 Unknown
          %8 = OpTypePointer UniformConstant %7
          %9 = OpVariable %8 UniformConstant
               ...
---------------------------------------------------


[[descriptorsets-sets]]
== 描述符集合

多个描述符被分组进入一个描述符集合对象中。一个描述符集合对象是一个不透明对象，包含一个描述符集合的存储
，类型和描述符的数量由一个描述符集合布局所定义。
布局对象也许会被用于定义每一个描述符与内存或者其他硬件资源绑定的关联信息。
布局被用于决定被关联到描述符集合的资源，且决定着色器资源与着色器阶段直接的接口。


[[descriptorsets-setlayout]]
=== 描述符集合布局


// refBegin VkDescriptorSetLayout Opaque handle to a descriptor set layout object

一个描述符集合布局对象是通过一个描述符绑定的数组来定义的。
每一个描述符绑定都有一个指定的描述符类型，绑定之中的描述符数量（数组元素个数），可访问到绑定的着色器阶段的集合，
和一个采样器描述符数组（若使用不可变采样器的话）。

描述符集合布局对象通过 sname:VkDescriptorSetLayout 类型handle 来定义：

include::../api/handles/VkDescriptorSetLayout.txt[]

// refEnd VkDescriptorSetLayout

// refBegin vkCreateDescriptorSetLayout Create a new descriptor set layout

想要创建描述符集合对象，可调用：

include::../api/protos/vkCreateDescriptorSetLayout.txt[]

  * pname:device 是创建描述符集合对象布局的逻辑设备。
  * pname:pCreateInfo 是一个指针，指向一个
    slink:VkDescriptorSetLayoutCreateInfo 数据结构实例，指定了描述符集合布局对象的状态。
  * pname:pAllocator 控制CPU端内存分配，如<<memory-allocation, Memory Allocation>> 一章所述。
  * pname:pSetLayout 指向一个 sname:VkDescriptorSetLayout handle，它存储被生成的描述符集合布局对象。


include::../validity/protos/vkCreateDescriptorSetLayout.txt[]

// refBegin VkDescriptorSetLayoutCreateInfo Structure specifying parameters of a newly created descriptor set layout

关于描述符集合布局的信息是包含在一个sname:VkDescriptorSetLayoutCreateInfo数据结构实例中被传递的。

include::../api/structs/VkDescriptorSetLayoutCreateInfo.txt[]

  * pname:sType 是数据结构的类型。
  * pname:pNext 是 `NULL` 或者一个指向拓展特定的数据结构的指针。
  * pname:flags 被保留。
  * pname:bindingCount 是 pname:pBindings 中元素的个数。
  * pname:pBindings 是一个指针，指向一个元素类型为
    slink:VkDescriptorSetLayoutBinding的数组。

.正确使用
****
  * pname:pBindings 数组的slink:VkDescriptorSetLayoutBinding::pname:binding 成员必须
每一个都有不同的值。
****

include::../validity/structs/VkDescriptorSetLayoutCreateInfo.txt[]

// refBegin VkDescriptorSetLayoutBinding Structure specifying a descriptor set layout binding

sname:VkDescriptorSetLayoutBinding 类型数据结构定义如下：

include::../api/structs/VkDescriptorSetLayoutBinding.txt[]

  * pname:binding is the binding number of this entry and corresponds to a
    resource of the same binding number in the shader stages.
  * pname:descriptorType is a elink:VkDescriptorType specifying which type
    of resource descriptors are used for this binding.
  * pname:descriptorCount is the number of descriptors contained in the
    binding, accessed in a shader as an array.
    If pname:descriptorCount is zero this binding entry is reserved and the
    resource must: not be accessed from any stage via this binding within
    any pipeline using the set layout.
  * pname:stageFlags member is a bitmask of elink:VkShaderStageFlagBits
    specifying which pipeline shader stages can: access a resource for this
    binding.
    ename:VK_SHADER_STAGE_ALL is a shorthand specifying that all defined
    shader stages, including any additional stages defined by extensions,
    can: access the resource.
+
--
If a shader stage is not included in pname:stageFlags, then a resource must:
not be accessed from that stage via this binding within any pipeline using
the set layout.
There are no limitations on what combinations of stages can: be used by a
descriptor binding, and in particular a binding can: be used by both
graphics stages and the compute stage.
--
  * pname:pImmutableSamplers affects initialization of samplers.
    If pname:descriptorType specifies a ename:VK_DESCRIPTOR_TYPE_SAMPLER or
    ename:VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER type descriptor, then
    pname:pImmutableSamplers can: be used to initialize a set of _immutable
    samplers_.
    Immutable samplers are permanently bound into the set layout; later
    binding a sampler into an immutable sampler slot in a descriptor set is
    not allowed.
    If pname:pImmutableSamplers is not `NULL`, then it is considered to be a
    pointer to an array of sampler handles that will be consumed by the set
    layout and used for the corresponding binding.
    If pname:pImmutableSamplers is `NULL`, then the sampler slots are
    dynamic and sampler handles must: be bound into descriptor sets using
    this layout.
    If pname:descriptorType is not one of these descriptor types, then
    pname:pImmutableSamplers is ignored.

The above layout definition allows the descriptor bindings to be specified
sparsely such that not all binding numbers between 0 and the maximum binding
number need to be specified in the pname:pBindings array.
Bindings that are not specified have a pname:descriptorCount and
pname:stageFlags of zero, and the pname:descriptorType is treated as
undefined.
However, all binding numbers between 0 and the maximum binding number in the
slink:VkDescriptorSetLayoutCreateInfo::pname:pBindings array may: consume
memory in the descriptor set layout even if not all descriptor bindings are
used, though it should: not consume additional memory from the descriptor
pool.

[NOTE]
.注意
====
The maximum binding number specified should: be as compact as possible to
avoid wasted memory.
====

.正确使用
****
  * 若 pname:descriptorType 是 ename:VK_DESCRIPTOR_TYPE_SAMPLER 或者
    ename:VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER，且
    pname:descriptorCount 不为 `0` 、 pname:pImmutableSamplers 不为
    `NULL`, pname:pImmutableSamplers 必须: 是一个指向
    pname:descriptorCount 个有效 sname:VkSampler handles的数组的指针。
  * 若 pname:descriptorCount 不为 `0`, pname:stageFlags 必须: 是一个有效的elink:VkShaderStageFlagBits 类型值。
****

include::../validity/structs/VkDescriptorSetLayoutBinding.txt[]

The following examples show a shader snippet using two descriptor sets, and
application code that creates corresponding descriptor set layouts.

.GLSL example
[source,glsl]
---------------------------------------------------
//
// binding to a single sampled image descriptor in set 0
//
layout (set=0, binding=0) uniform texture2D mySampledImage;

//
// binding to an array of sampled image descriptors in set 0
//
layout (set=0, binding=1) uniform texture2D myArrayOfSampledImages[12];

//
// binding to a single uniform buffer descriptor in set 1
//
layout (set=1, binding=0) uniform myUniformBuffer
{
    vec4 myElement[32];
};
---------------------------------------------------

.SPIR-V example
[source,spirv]
---------------------------------------------------
               ...
          %1 = OpExtInstImport "GLSL.std.450"
               ...
               OpName %9 "mySampledImage"
               OpName %14 "myArrayOfSampledImages"
               OpName %18 "myUniformBuffer"
               OpMemberName %18 0 "myElement"
               OpName %20 ""
               OpDecorate %9 DescriptorSet 0
               OpDecorate %9 Binding 0
               OpDecorate %14 DescriptorSet 0
               OpDecorate %14 Binding 1
               OpDecorate %17 ArrayStride 16
               OpMemberDecorate %18 0 Offset 0
               OpDecorate %18 Block
               OpDecorate %20 DescriptorSet 1
               OpDecorate %20 Binding 0
          %2 = OpTypeVoid
          %3 = OpTypeFunction %2
          %6 = OpTypeFloat 32
          %7 = OpTypeImage %6 2D 0 0 0 1 Unknown
          %8 = OpTypePointer UniformConstant %7
          %9 = OpVariable %8 UniformConstant
         %10 = OpTypeInt 32 0
         %11 = OpConstant %10 12
         %12 = OpTypeArray %7 %11
         %13 = OpTypePointer UniformConstant %12
         %14 = OpVariable %13 UniformConstant
         %15 = OpTypeVector %6 4
         %16 = OpConstant %10 32
         %17 = OpTypeArray %15 %16
         %18 = OpTypeStruct %17
         %19 = OpTypePointer Uniform %18
         %20 = OpVariable %19 Uniform
               ...
---------------------------------------------------

.API example
[source,c++]
-------------------------------------------------------------------------------
VkResult myResult;

const VkDescriptorSetLayoutBinding myDescriptorSetLayoutBinding[] =
{
    // binding to a single image descriptor
    {
        0,                                      // binding
        VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE,       // descriptorType
        1,                                      // descriptorCount
        VK_SHADER_STAGE_FRAGMENT_BIT,           // stageFlags
        NULL                                    // pImmutableSamplers
    },

    // binding to an array of image descriptors
    {
        1,                                      // binding
        VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE,       // descriptorType
        12,                                     // descriptorCount
        VK_SHADER_STAGE_FRAGMENT_BIT,           // stageFlags
        NULL                                    // pImmutableSamplers
    },

    // binding to a single uniform buffer descriptor
    {
        0,                                      // binding
        VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER,      // descriptorType
        1,                                      // descriptorCount
        VK_SHADER_STAGE_FRAGMENT_BIT,           // stageFlags
        NULL                                    // pImmutableSamplers
    }
};

const VkDescriptorSetLayoutCreateInfo myDescriptorSetLayoutCreateInfo[] =
{
    // Create info for first descriptor set with two descriptor bindings
    {
        VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO,    // sType
        NULL,                                                   // pNext
        0,                                                      // flags
        2,                                                      // bindingCount
        &myDescriptorSetLayoutBinding[0]                        // pBindings
    },

    // Create info for second descriptor set with one descriptor binding
    {
        VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO,    // sType
        NULL,                                                   // pNext
        0,                                                      // flags
        1,                                                      // bindingCount
        &myDescriptorSetLayoutBinding[2]                        // pBindings
    }
};

VkDescriptorSetLayout myDescriptorSetLayout[2];

//
// Create first descriptor set layout
//
myResult = vkCreateDescriptorSetLayout(
    myDevice,
    &myDescriptorSetLayoutCreateInfo[0],
    NULL,
    &myDescriptorSetLayout[0]);

//
// Create second descriptor set layout
//
myResult = vkCreateDescriptorSetLayout(
    myDevice,
    &myDescriptorSetLayoutCreateInfo[1],
    NULL,
    &myDescriptorSetLayout[1]);
-------------------------------------------------------------------------------

// refBegin vkDestroyDescriptorSetLayout Destroy a descriptor set layout object

想要销毁描述符集合布局，可调用：

include::../api/protos/vkDestroyDescriptorSetLayout.txt[]

  * pname:device 是销毁描述符集合布局的逻辑设备。
  * pname:descriptorSetLayout 是需要被销毁的描述符集合布局。
  * pname:pAllocator 控制CPU端内存分配，如 <<memory-allocation, Memory Allocation>> 一章所述。

.正确使用
****
  * 若在创建pname:descriptorSetLayout 是提供了 sname:VkAllocationCallbacks，那么也必须在此处
    提供兼容的callbacks。
  * 若在创建pname:descriptorSetLayout时没有提供  sname:VkAllocationCallbacks，那么pname:pAllocator 必须: 为 `NULL`
****

include::../validity/protos/vkDestroyDescriptorSetLayout.txt[]


[[descriptorsets-pipelinelayout]]
=== 管线布局

// refBegin VkPipelineLayout Opaque handle to a pipeline layout object

Access to descriptor sets from a pipeline is accomplished through a
_pipeline layout_.
Zero or more descriptor set layouts and zero or more push constant ranges
are combined to form a pipeline layout object which describes the complete
set of resources that can: be accessed by a pipeline.
The pipeline layout represents a sequence of descriptor sets with each
having a specific layout.
This sequence of layouts is used to determine the interface between shader
stages and shader resources.
Each pipeline is created using a pipeline layout.

Pipeline layout objects are represented by sname:VkPipelineLayout handles:

include::../api/handles/VkPipelineLayout.txt[]

// refEnd VkPipelineLayout

// refBegin vkCreatePipelineLayout Creates a new pipeline layout object

欲创建管线布局，可调用：

include::../api/protos/vkCreatePipelineLayout.txt[]

  * pname:device 是创建管线布局的逻辑设备。
  * pname:pCreateInfo 是一个指针，指向 slink:VkPipelineLayoutCreateInfo 数据结构实例，其指定来管线布局对象的状态。
  * pname:pAllocator 控制CPU端内存分配，如 <<memory-allocation, Memory Allocation>> 一章所述。
  * pname:pPipelineLayout 指向一个 sname:VkPipelineLayout handl，它是生成并被返回的管线布局对象。

include::../validity/protos/vkCreatePipelineLayout.txt[]

// refBegin VkPipelineLayoutCreateInfo Structure specifying the parameters of a newly created pipeline layout object

slink:VkPipelineLayoutCreateInfo 类型数据结构定义如下：

include::../api/structs/VkPipelineLayoutCreateInfo.txt[]

  * pname:sType 是数据结构的类型。
  * pname:pNext 是 `NULL` 或者一个指向拓展特定的数据结构的指针。
  * pname:flags 被保留。
  * pname:setLayoutCount 是包含在管线布局中的描述符集合的个数。
  * pname:pSetLayouts 是一个指针，指向sname:VkDescriptorSetLayout 类型的数组。
  * pname:pushConstantRangeCount 是包含在管线布局中的push constants区间的个数。
  * pname:pPushConstantRanges 是一个指针，指向    sname:VkPushConstantRange 类型数组，定一个了一个集合的push constants区间，
	被用于单个管线布局。除了描述符集合布局，一个管线布局也表述了管线的每个阶段可访问到的push constatns数量。
+
[NOTE]
.注意
====
Push constants represent a high speed path to modify constant data in
pipelines that is expected to outperform memory-backed resource updates.
====

.正确使用
****
  * pname:setLayoutCount 必须: 小于等于 sname:VkPhysicalDeviceLimits::pname:maxBoundDescriptorSets
  * 可被pname:pSetLayouts 之中 任意着色器阶段访问的
    ename:VK_DESCRIPTOR_TYPE_SAMPLER 和
    ename:VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER 类型的描述符的总个数， 必须: 小于等于 sname:VkPhysicalDeviceLimits::pname:maxPerStageDescriptorSamplers
  * The total number of descriptors of the type
    ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER and
    ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC accessible to any given
    shader stage across all elements of pname:pSetLayouts must: be less than
    or equal to
    sname:VkPhysicalDeviceLimits::pname:maxPerStageDescriptorUniformBuffers
  * The total number of descriptors of the type
    ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER and
    ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC accessible to any given
    shader stage across all elements of pname:pSetLayouts must: be less than
    or equal to
    sname:VkPhysicalDeviceLimits::pname:maxPerStageDescriptorStorageBuffers
  * The total number of descriptors of the type
    ename:VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER,
    ename:VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE, and
    ename:VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER accessible to any given
    shader stage across all elements of pname:pSetLayouts must: be less than
    or equal to
    sname:VkPhysicalDeviceLimits::pname:maxPerStageDescriptorSampledImages
  * The total number of descriptors of the type
    ename:VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, and
    ename:VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER accessible to any given
    shader stage across all elements of pname:pSetLayouts must: be less than
    or equal to
    sname:VkPhysicalDeviceLimits::pname:maxPerStageDescriptorStorageImages
  * Any two elements of pname:pPushConstantRanges must: not include the same
    stage in pname:stageFlags
****

include::../validity/structs/VkPipelineLayoutCreateInfo.txt[]

// refBegin VkPushConstantRange Structure specifying a push constant range

sname:VkPushConstantRange 类型数据结构定义如下：

include::../api/structs/VkPushConstantRange.txt[]

  * pname:stageFlags is a set of stage flags describing the shader stages
    that will access a range of push constants.
    If a particular stage is not included in the range, then accessing
    members of that range of push constants from the corresponding shader
    stage will result in undefined data being read.
  * pname:offset and pname:size are the start offset and size, respectively,
    consumed by the range.
    Both pname:offset and pname:size are in units of bytes and must: be a
    multiple of 4.
    The layout of the push constant variables is specified in the shader.

.正确使用
****
  * pname:offset 必须: 小于 sname:VkPhysicalDeviceLimits::pname:maxPushConstantsSize
  * pname:offset 必须: 是`4`的倍数
  * pname:size 必须: 大于`0`
  * pname:size 必须: 是`4`的倍数
  * pname:size 必须: 小于等于
    sname:VkPhysicalDeviceLimits::pname:maxPushConstantsSize 减去
    pname:offset之差
****

include::../validity/structs/VkPushConstantRange.txt[]

一旦被创建，管线布局被用于管线创建的一部分 (see
<<pipelines, Pipelines>>), 作为描述符集合绑定的一部分 (see
<<descriptorsets-binding, Descriptor Set Binding>>), 而且作为设置push 常量的一部分
(see <<descriptorsets-push-constants, Push Constant Updates>>)。
管线创建接受一个管线布局作为输入，且布局可能被用于映射（集合、绑定、数组元素）tuples到硬件资源或者一个描述符集合的内存地址上。
The assignment of hardware resources depends only on the bindings defined in
the descriptor sets that comprise the pipeline layout, and not on any shader
source.

[[descriptorsets-pipelinelayout-consistency]]
All resource variables <<shaders-staticuse,statically used>> in all shaders
in a pipeline must: be declared with a (set,binding,arrayElement) that
exists in the corresponding descriptor set layout and is of an appropriate
descriptor type and includes the set of shader stages it is used by in
pname:stageFlags.
The pipeline layout can: include entries that are not used by a particular
pipeline, or that are dead-code eliminated from any of the shaders.
The pipeline layout allows the application to provide a consistent set of
bindings across multiple pipeline compiles, which enables those pipelines to
be compiled in a way that the implementation may: cheaply switch pipelines
without reprogramming the bindings.

Similarly, the push constant block declared in each shader (if present)
must: only place variables at offsets that are each included in a push
constant range with pname:stageFlags including the bit corresponding to the
shader stage that uses it.
The pipeline layout can: include ranges or portions of ranges that are not
used by a particular pipeline, or for which the variables have been
dead-code eliminated from any of the shaders.

There is a limit on the total number of resources of each type that can: be
included in bindings in all descriptor set layouts in a pipeline layout as
shown in <<descriptorsets-pipelinelayout-limits,Pipeline Layout Resource
Limits>>.
The "`Total Resources Available`" column gives the limit on the number of
each type of resource that can: be included in bindings in all descriptor
sets in the pipeline layout.
Some resource types count against multiple limits.
Additionally, there are limits on the total number of each type of resource
that can: be used in any pipeline stage as described in
<<interfaces-resources-limits,Shader Resource Limits>>.

[[descriptorsets-pipelinelayout-limits]]
.Pipeline Layout Resource Limits
[width="80%",cols="<37,<22",options="header"]
|====
| Total Resources Available | Resource Types
.2+<.^| pname:maxDescriptorSetSamplers
            | sampler           | combined image sampler
.3+<.^| pname:maxDescriptorSetSampledImages
            | sampled image     | combined image sampler | uniform texel buffer
.2+<.^| pname:maxDescriptorSetStorageImages
            | storage image     | storage texel buffer
.2+<.^| pname:maxDescriptorSetUniformBuffers
            | uniform buffer    | uniform buffer dynamic
| pname:maxDescriptorSetUniformBuffersDynamic
            | uniform buffer dynamic
.2+<.^| pname:maxDescriptorSetStorageBuffers
            | storage buffer    | storage buffer dynamic
| pname:maxDescriptorSetStorageBuffersDynamic
            | storage buffer dynamic
| pname:maxDescriptorSetInputAttachments
            | input attachment
|====


// refBegin vkDestroyPipelineLayout Destroy a pipeline layout object

与销毁管线布局，可调用：

include::../api/protos/vkDestroyPipelineLayout.txt[]

  * pname:device 是销毁管线布局的逻辑设备。
  * pname:pipelineLayout 是需要被销毁的管线布局。
  * pname:pAllocator 控制CPU端内存分配，如    <<memory-allocation, Memory Allocation>> 一章所述。

.正确使用
****
  * 若创建pname:pipelineLayout时提供了 sname:VkAllocationCallbacks，那么在此处必须提供兼容的callbacks。
  * 创建pname:pipelineLayout时没有提供 sname:VkAllocationCallbacks，那么 pname:pAllocator 必须: 为 `NULL`
****

include::../validity/protos/vkDestroyPipelineLayout.txt[]


[[descriptorsets-compatibility]]
==== 管线布局兼容性

若两个管线布局被创建时，带有的push constants 区间完全一致，那么它们就被定义为 "`compatible for
<<descriptorsets-push-constants, push constants>>`"。
Two pipeline layouts are defined to be "`compatible for set N`" if they were
created with _identically defined_ descriptor set layouts for sets zero
through N, and if they were created with identical push constant ranges.

When binding a descriptor set (see <<descriptorsets-binding, Descriptor Set
Binding>>) to set number N, if the previously bound descriptor sets for sets
zero through N-1 were all bound using compatible pipeline layouts, then
performing this binding does not disturb any of the lower numbered sets.
If, additionally, the previous bound descriptor set for set N was bound
using a pipeline layout compatible for set N, then the bindings in sets
numbered greater than N are also not disturbed.

Similarly, when binding a pipeline, the pipeline can: correctly access any
previously bound descriptor sets which were bound with compatible pipeline
layouts, as long as all lower numbered sets were also bound with compatible
layouts.

Layout compatibility means that descriptor sets can: be bound to a command
buffer for use by any pipeline created with a compatible pipeline layout,
and without having bound a particular pipeline first.
It also means that descriptor sets can: remain valid across a pipeline
change, and the same resources will be accessible to the newly bound
pipeline.

ifdef::implementation-guide[]
.Implementor's Note
****
A consequence of layout compatibility is that when the implementation
compiles a pipeline layout and assigns hardware units to resources, the
mechanism to assign hardware units for set N should: only be a function of
sets [0..N].
****
endif::implementation-guide[]

[NOTE]
.注意
====
Place the least frequently changing descriptor sets near the start of the
pipeline layout, and place the descriptor sets representing the most
frequently changing resources near the end.
When pipelines are switched, only the descriptor set bindings that have been
invalidated will need to be updated and the remainder of the descriptor set
bindings will remain in place.
====

The maximum number of descriptor sets that can: be bound to a pipeline
layout is queried from physical device properties (see
pname:maxBoundDescriptorSets in <<features-limits, Limits>>).

.API example
[source,c++]
---------------------------------------------------
const VkDescriptorSetLayout layouts[] = { layout1, layout2 };

const VkPushConstantRange ranges[] =
{
    {
        VK_PIPELINE_STAGE_VERTEX_SHADER_BIT,    // stageFlags
        0,                                      // offset
        4                                       // size
    },

    {
        VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT,  // stageFlags
        4,                                      // offset
        4                                       // size
    },
};

const VkPipelineLayoutCreateInfo createInfo =
{
    VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO,  // sType
    NULL,                                           // pNext
    0,                                              // flags
    2,                                              // setLayoutCount
    layouts,                                        // pSetLayouts
    2,                                              // pushConstantRangeCount
    ranges                                          // pPushConstantRanges
};

VkPipelineLayout myPipelineLayout;
myResult = vkCreatePipelineLayout(
    myDevice,
    &createInfo,
    NULL,
    &myPipelineLayout);
---------------------------------------------------


[[descriptorsets-allocation]]
=== 描述符集合的分配

// refBegin VkDescriptorPool Opaque handle to a descriptor pool object

A _descriptor pool_ maintains a pool of descriptors, from which descriptor
sets are allocated.
Descriptor pools are externally synchronized, meaning that the application
must: not allocate and/or free descriptor sets from the same pool in
multiple threads simultaneously.

Descriptor pools are represented by sname:VkDescriptorPool handles:

include::../api/handles/VkDescriptorPool.txt[]

// refEnd VkDescriptorPool

// refBegin vkCreateDescriptorPool Creates a descriptor pool object

与创建描述符池对对象，可调用：

include::../api/protos/vkCreateDescriptorPool.txt[]

  * pname:device 是创建描述符池的逻辑设备。
  * pname:pCreateInfo 是一个指针，指向一个 slink:VkDescriptorPoolCreateInfo 数据结构实例，指定了描述符池对象的状态。
  * pname:pAllocator 控制CPU端内存分配，如    <<memory-allocation, Memory Allocation>> 一章所述。
  * pname:pDescriptorPool 指向一个 sname:VkDescriptorPool handle，它是生成并被返回的描述符池对象。

pname:pAllocator controls host memory allocation as described in the
<<memory-allocation, Memory Allocation>> chapter.

被创建的描述符池通过 pname:pDescriptorPool 返回。

include::../validity/protos/vkCreateDescriptorPool.txt[]

// refBegin VkDescriptorPoolCreateInfo Structure specifying parameters of a newly created descriptor pool

Additional information about the pool is passed in an instance of the
sname:VkDescriptorPoolCreateInfo structure:

include::../api/structs/VkDescriptorPoolCreateInfo.txt[]

  * pname:sType 是数据结构的类型。
  * pname:pNext 是 `NULL` 或者一个指向拓展特定的数据结构的指针。
  * pname:flags 指定了池上支持的某些操作。Bit位如下：
+
--
// refBegin VkDescriptorPoolCreateFlagBits Bitmask specifying certain supported operations on a descriptor pool
include::../api/enums/VkDescriptorPoolCreateFlagBits.txt[]
--
+
If pname:flags includes
ename:VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT, then descriptor
sets can: return their individual allocations to the pool, i.e. all of
fname:vkAllocateDescriptorSets, fname:vkFreeDescriptorSets, and
fname:vkResetDescriptorPool are allowed.
Otherwise, descriptor sets allocated from the pool must: not be individually
freed back to the pool, i.e. only fname:vkAllocateDescriptorSets and
fname:vkResetDescriptorPool are allowed.
+
  * pname:maxSets is the maximum number of descriptor sets that can: be
    allocated from the pool.
  * pname:poolSizeCount is the number of elements in pname:pPoolSizes.
  * pname:pPoolSizes is a pointer to an array of sname:VkDescriptorPoolSize
    structures, each containing a descriptor type and number of descriptors
    of that type to be allocated in the pool.

If multiple sname:VkDescriptorPoolSize structures appear in the
pname:pPoolSizes array then the pool will be created with enough storage for
the total number of descriptors of each type.

Fragmentation of a descriptor pool is possible and may: lead to descriptor
set allocation failures.
A failure due to fragmentation is defined as failing a descriptor set
allocation despite the sum of all outstanding descriptor set allocations
from the pool plus the requested allocation requiring no more than the total
number of descriptors requested at pool creation.
Implementations provide certain guarantees of when fragmentation must: not
cause allocation failure, as described below.

If a descriptor pool has not had any descriptor sets freed since it was
created or most recently reset then fragmentation must: not cause an
allocation failure (note that this is always the case for a pool created
without the ename:VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT bit
set).
Additionally, if all sets allocated from the pool since it was created or
most recently reset use the same number of descriptors (of each type) and
the requested allocation also uses that same number of descriptors (of each
type), then fragmentation must: not cause an allocation failure.

If an allocation failure occurs due to fragmentation, an application can:
create an additional descriptor pool to perform further descriptor set
allocations.

.正确使用
****
  * pname:maxSets 必须: 大于 `0`
****

include::../validity/structs/VkDescriptorPoolCreateInfo.txt[]

// refBegin VkDescriptorPoolSize Structure specifying descriptor pool size

sname:VkDescriptorPoolSize 类型数据结构定义如下：

include::../api/structs/VkDescriptorPoolSize.txt[]

  * pname:type 是描述符的类型。
  * pname:descriptorCount 是需要分配的类型的描述符的个数。

.正确使用
****
  * pname:descriptorCount 必须: 大于 `0`
****

include::../validity/structs/VkDescriptorPoolSize.txt[]

// refBegin vkDestroyDescriptorPool Destroy a descriptor pool object

欲销毁一个描述符池，可调用：

include::../api/protos/vkDestroyDescriptorPool.txt[]

  * pname:device 是销毁描述符池的逻辑设备。
  * pname:descriptorPool 是需要被销毁的描述符池。
  * pname:pAllocator 控制CPU端内存分配，如 <<memory-allocation, Memory Allocation>> 一章所述。

当一个pool被销毁后，从它分配而来的描述符集合都隐式的变得无效了。
从一个指定的池中分配而来的描述符集合，并不需要在描述符池销毁之前被释放。

.正确使用
****
  * All submitted commands that refer to pname:descriptorPool (via any
    allocated descriptor sets) must: have completed execution
  * If sname:VkAllocationCallbacks were provided when pname:descriptorPool
    was created, a compatible set of callbacks must: be provided here
  * If no sname:VkAllocationCallbacks were provided when
    pname:descriptorPool was created, pname:pAllocator must: be `NULL`
****

include::../validity/protos/vkDestroyDescriptorPool.txt[]

// refBegin VkDescriptorSet Opaque handle to a descriptor set object

Descriptor sets are allocated from descriptor pool objects, and are
represented by sname:VkDescriptorSet handles:

include::../api/handles/VkDescriptorSet.txt[]

// refEnd VkDescriptorSet

// refBegin vkAllocateDescriptorSets Allocate one or more descriptor sets

欲从描述符池中分配描述符集合，可调用：

include::../api/protos/vkAllocateDescriptorSets.txt[]

  * pname:device 是拥有描述符池的逻辑设备。
  * pname:pAllocateInfo 是一个指针，指向一个    slink:VkDescriptorSetAllocateInfo 实例，描述了分配的参数。
  * pname:pDescriptorSets is a pointer to an array of sname:VkDescriptorSet
    handles in which the resulting descriptor set objects are returned.
    The array must: be at least the length specified by the
    pname:descriptorSetCount member of pname:pAllocateInfo.

The allocated descriptor sets are returned in pname:pDescriptorSets.

When a descriptor set is allocated, the initial state is largely
uninitialized and all descriptors are undefined.
However, the descriptor set can: be bound in a command buffer without
causing errors or exceptions.
All entries that are statically used by a pipeline in a drawing or
dispatching command must: have been populated before the descriptor set is
bound for use by that command.
Entries that are not statically used by a pipeline can: have uninitialized
descriptors or descriptors of resources that have been destroyed, and
executing a draw or dispatch with such a descriptor set bound does not cause
undefined behavior.
This means applications need not populate unused entries with dummy
descriptors.

If an allocation fails due to fragmentation, an indeterminate error is
returned with an unspecified error code.
Any returned error other than ename:VK_ERROR_FRAGMENTED_POOL does not imply
its usual meaning: applications should: assume that the allocation failed
due to fragmentation, and create a new descriptor pool.

ifdef::VK_KHR_maintenance1[]
If the allocation fails due to no more space in the descriptor pool, and not
because of system or device memory exhaustion, then
ename:VK_ERROR_OUT_OF_POOL_MEMORY_KHR must: be returned.

fname:vkAllocateDescriptorSets can: be used to create multiple descriptor
sets.
If the creation of any of those descriptor sets fails, then the
implementation must: destroy all successfully created descriptor set objects
from this command, set all entries of the pname:pDescriptorSets array to
dlink:VK_NULL_HANDLE and return the error.
endif::VK_KHR_maintenance1[]

[NOTE]
.注意
====
Applications should: check for a negative return value when allocating new
descriptor sets, assume that any error effectively means
ename:VK_ERROR_FRAGMENTED_POOL, and try to create a new descriptor pool.
If ename:VK_ERROR_FRAGMENTED_POOL is the actual return value, it adds
certainty to that decision.

The reason for this is that ename:VK_ERROR_FRAGMENTED_POOL was only added in
a later revision of the 1.0 specification, and so drivers may: return other
errors if they were written against earlier revisions.
To ensure full compatibility with earlier patch revisions, these other
errors are allowed.
====

include::../validity/protos/vkAllocateDescriptorSets.txt[]

// refBegin VkDescriptorSetAllocateInfo Structure specifying the allocation parameters for descriptor sets

sname:VkDescriptorSetAllocateInfo 类型数据结构定义如下：

include::../api/structs/VkDescriptorSetAllocateInfo.txt[]

  * pname:sType 是数据结构的类型。
  * pname:pNext 是 `NULL` 或者一个指向拓展特定的数据结构的指针。
  * pname:descriptorPool is the pool which the sets will be allocated from.
  * pname:descriptorSetCount determines the number of descriptor sets to be
    allocated from the pool.
  * pname:pSetLayouts is an array of descriptor set layouts, with each
    member specifying how the corresponding descriptor set is allocated.

.正确使用
****
  * pname:descriptorSetCount must: not be greater than the number of sets
    that are currently available for allocation in pname:descriptorPool
  * pname:descriptorPool must: have enough free descriptor capacity
    remaining to allocate the descriptor sets of the specified layouts
****

include::../validity/structs/VkDescriptorSetAllocateInfo.txt[]

// refBegin vkFreeDescriptorSets Free one or more descriptor sets

与释放被分配的描述符集合，可调用：

include::../api/protos/vkFreeDescriptorSets.txt[]

  * pname:device is the logical device that owns the descriptor pool.
  * pname:descriptorPool is the descriptor pool from which the descriptor
    sets were allocated.
  * pname:descriptorSetCount is the number of elements in the
    pname:pDescriptorSets array.
  * pname:pDescriptorSets is an array of handles to sname:VkDescriptorSet
    objects.

After a successful call to fname:vkFreeDescriptorSets, all descriptor sets
in pname:pDescriptorSets are invalid.

.正确使用
****
  * All submitted commands that refer to any element of
    pname:pDescriptorSets must: have completed execution
  * pname:pDescriptorSets must: be a pointer to an array of
    pname:descriptorSetCount sname:VkDescriptorSet handles, each element of
    which must: either be a valid handle or dlink:VK_NULL_HANDLE
  * Each valid handle in pname:pDescriptorSets must: have been allocated
    from pname:descriptorPool
  * pname:descriptorPool must: have been created with the
    ename:VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT flag
****

include::../validity/protos/vkFreeDescriptorSets.txt[]

// refBegin vkResetDescriptorPool Resets a descriptor pool object

To return all descriptor sets allocated from a given pool to the pool,
rather than freeing individual descriptor sets, call:

include::../api/protos/vkResetDescriptorPool.txt[]

  * pname:device 书拥有描述符池的逻辑设备。
  * pname:descriptorPool 是需要被重置的描述符池。
  * pname:flags 被保留。

Resetting a descriptor pool recycles all of the resources from all of the
descriptor sets allocated from the descriptor pool back to the descriptor
pool, and the descriptor sets are implicitly freed.

.正确使用
****
  * All uses of pname:descriptorPool (via any allocated descriptor sets)
    must: have completed execution
****

include::../validity/protos/vkResetDescriptorPool.txt[]


[[descriptorsets-updates]]
=== 描述符集合更新

// refBegin vkUpdateDescriptorSets Update the contents of a descriptor set object

Once allocated, descriptor sets can: be updated with a combination of write
and copy operations.
欲更新描述符集合，可调用：

include::../api/protos/vkUpdateDescriptorSets.txt[]

  * pname:device 是更新描述符集合的逻辑设备。
  * pname:descriptorWriteCount 是    pname:pDescriptorWrites 数组中元素的个数。
  * pname:pDescriptorWrites 是一个指针，指向一个
    slink:VkWriteDescriptorSet 类型数组，描述了将被写入的描述符集合。
  * pname:descriptorCopyCount 是 pname:pDescriptorCopies 数组中元素个数.
  * pname:pDescriptorCopies 是一个指针，窒息那个一个    slink:VkCopyDescriptorSet 类型数组，描述了将要复制的
	描述符集合。

The operations described by pname:pDescriptorWrites are performed first,
followed by the operations described by pname:pDescriptorCopies.
Within each array, the operations are performed in the order they appear in
the array.

Each element in the pname:pDescriptorWrites array describes an operation
updating the descriptor set using descriptors for resources specified in the
structure.

Each element in the pname:pDescriptorCopies array is a
slink:VkCopyDescriptorSet structure describing an operation copying
descriptors between sets.

include::../validity/protos/vkUpdateDescriptorSets.txt[]

// refBegin VkWriteDescriptorSet Structure specifying the parameters of a descriptor set write operation

sname:VkWriteDescriptorSet 类型数据结构定义如下：

include::../api/structs/VkWriteDescriptorSet.txt[]

  * pname:sType 是数据结构的类型。
  * pname:pNext 是 `NULL` 或者一个指向拓展特定的数据结构的指针。
  * pname:dstSet is the destination descriptor set to update.
  * pname:dstBinding is the descriptor binding within that set.
  * pname:dstArrayElement is the starting element in that array.
  * pname:descriptorCount is the number of descriptors to update (the number
    of elements in pname:pImageInfo, pname:pBufferInfo, or
    pname:pTexelBufferView).
  * pname:descriptorType is a elink:VkDescriptorType specifying the type of
    each descriptor in pname:pImageInfo, pname:pBufferInfo, or
    pname:pTexelBufferView, as described below.
    It must: be the same type as that specified in
    sname:VkDescriptorSetLayoutBinding for pname:dstSet at pname:dstBinding.
    The type of the descriptor also controls which array the descriptors are
    taken from.
  * pname:pImageInfo points to an array of slink:VkDescriptorImageInfo
    structures or is ignored, as described below.
  * pname:pBufferInfo points to an array of slink:VkDescriptorBufferInfo
    structures or is ignored, as described below.
  * pname:pTexelBufferView points to an array of slink:VkBufferView handles
    as described in the <<resources-buffer-views,Buffer Views>> section or
    is ignored, as described below.

Only one of pname:pImageInfo, pname:pBufferInfo, or pname:pTexelBufferView
members is used according to the descriptor type specified in the
pname:descriptorType member of the containing sname:VkWriteDescriptorSet
structure, as specified below.

[[descriptorsets-updates-consecutive, consecutive binding updates]]
If the pname:dstBinding has fewer than pname:descriptorCount array elements
remaining starting from pname:dstArrayElement, then the remainder will be
used to update the subsequent binding - pname:dstBinding+1 starting at array
element zero.
If a binding has a pname:descriptorCount of zero, it is skipped.
This behavior applies recursively, with the update affecting consecutive
bindings as needed to update all pname:descriptorCount descriptors.
All consecutive bindings updated via a single sname:VkWriteDescriptorSet
structure, except those with a pname:descriptorCount of zero, must: have
identical pname:descriptorType and pname:stageFlags, and must: all either
use immutable samplers or must: all not use immutable samplers.

.正确使用
****
  * pname:dstBinding must: be less than or equal to the maximum value of
    pname:binding of all slink:VkDescriptorSetLayoutBinding structures
    specified when pname:dstSet's descriptor set layout was created
  * pname:dstBinding must: be a binding with a non-zero
    pname:descriptorCount
  * pname:descriptorType must: match the type of pname:dstBinding within
    pname:dstSet
  * The sum of pname:dstArrayElement and pname:descriptorCount must: be less
    than or equal to the number of array elements in the descriptor set
    binding specified by pname:dstBinding, and all applicable consecutive
    bindings, as described by <<descriptorsets-updates-consecutive>>
  * If pname:descriptorType is ename:VK_DESCRIPTOR_TYPE_SAMPLER,
    ename:VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER,
    ename:VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE,
    ename:VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, or
    ename:VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT, pname:pImageInfo must: be a
    pointer to an array of pname:descriptorCount valid
    sname:VkDescriptorImageInfo structures
  * If pname:descriptorType is ename:VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER
    or ename:VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER, pname:pTexelBufferView
    must: be a pointer to an array of pname:descriptorCount valid
    sname:VkBufferView handles
  * If pname:descriptorType is ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER,
    ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER,
    ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC, or
    ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC, pname:pBufferInfo must:
    be a pointer to an array of pname:descriptorCount valid
    sname:VkDescriptorBufferInfo structures
  * If pname:descriptorType is ename:VK_DESCRIPTOR_TYPE_SAMPLER or
    ename:VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, and pname:dstSet was
    not allocated with a layout that included immutable samplers for
    pname:dstBinding with pname:descriptorType, the pname:sampler member of
    any given element of pname:pImageInfo must: be a valid sname:VkSampler
    object
  * If pname:descriptorType is
    ename:VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER,
    ename:VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE,
    ename:VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, or
    ename:VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT, the pname:imageView and
    pname:imageLayout members of any given element of pname:pImageInfo must:
    be a valid sname:VkImageView and elink:VkImageLayout, respectively
  * If pname:descriptorType is ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER or
    ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC, the pname:offset member
    of any given element of pname:pBufferInfo must: be a multiple of
    sname:VkPhysicalDeviceLimits::pname:minUniformBufferOffsetAlignment
  * If pname:descriptorType is ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER or
    ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC, the pname:offset member
    of any given element of pname:pBufferInfo must: be a multiple of
    sname:VkPhysicalDeviceLimits::pname:minStorageBufferOffsetAlignment
  * If pname:descriptorType is ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER,
    ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC,
    ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER, or
    ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC, the pname:buffer member
    of any given element of pname:pBufferInfo that is non-sparse must: be
    bound completely and contiguously to a single sname:VkDeviceMemory
    object
  * If pname:descriptorType is ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER or
    ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC, the pname:buffer member
    of any given element of pname:pBufferInfo must: have been created with
    ename:VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT set
  * If pname:descriptorType is ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER or
    ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC, the pname:buffer member
    of any given element of pname:pBufferInfo must: have been created with
    ename:VK_BUFFER_USAGE_STORAGE_BUFFER_BIT set
  * If pname:descriptorType is ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER or
    ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC, the pname:range member
    of any given element of pname:pBufferInfo, or the effective range if
    pname:range is ename:VK_WHOLE_SIZE, must: be less than or equal to
    sname:VkPhysicalDeviceLimits::pname:maxUniformBufferRange
  * If pname:descriptorType is ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER or
    ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC, the pname:range member
    of any given element of pname:pBufferInfo, or the effective range if
    pname:range is ename:VK_WHOLE_SIZE, must: be less than or equal to
    sname:VkPhysicalDeviceLimits::pname:maxStorageBufferRange
  * If pname:descriptorType is
    ename:VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER, the sname:VkBuffer that
    any given element of pname:pTexelBufferView was created from must: have
    been created with ename:VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT set
  * If pname:descriptorType is
    ename:VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER, the sname:VkBuffer that
    any given element of pname:pTexelBufferView was created from must: have
    been created with ename:VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT set
  * If pname:descriptorType is ename:VK_DESCRIPTOR_TYPE_STORAGE_IMAGE or
    ename:VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT, the pname:imageView member of
    any given element of pname:pImageInfo must: have been created with the
    identity swizzle
****

include::../validity/structs/VkWriteDescriptorSet.txt[]

// refBegin VkDescriptorType Specifies the type of a descriptor in a descriptor set

The type of descriptors in a descriptor set is specified by
slink:VkWriteDescriptorSet::pname:descriptorType, which must: be one of the
values:

include::../api/enums/VkDescriptorType.txt[]

If pname:descriptorType is ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER,
ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER,
ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC, or
ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC, the elements of the
slink:VkWriteDescriptorSet::pname:pBufferInfo array of
slink:VkDescriptorBufferInfo structures will be used to update the
descriptors, and other arrays will be ignored.

If pname:descriptorType is ename:VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER or
ename:VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER, the
slink:VkWriteDescriptorSet::pname:pTexelBufferView array will be used to
update the descriptors, and other arrays will be ignored.

If pname:descriptorType is ename:VK_DESCRIPTOR_TYPE_SAMPLER,
ename:VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER,
ename:VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE,
ename:VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, or
ename:VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT, the elements of the
slink:VkWriteDescriptorSet::pname:pImageInfo array of
slink:VkDescriptorImageInfo structures will be used to update the
descriptors, and other arrays will be ignored.

// refEnd VkDescriptorType

// refBegin VkDescriptorBufferInfo Structure specifying descriptor buffer info

sname:VkDescriptorBufferInfo 类型数据结构定义如下：

include::../api/structs/VkDescriptorBufferInfo.txt[]

  * pname:buffer is the buffer resource.
  * pname:offset is the offset in bytes from the start of pname:buffer.
    Access to buffer memory via this descriptor uses addressing that is
    relative to this starting offset.
  * pname:range is the size in bytes that is used for this descriptor
    update, or ename:VK_WHOLE_SIZE to use the range from pname:offset to the
    end of the buffer.
+
--
[NOTE]
.注意
====
When using ename:VK_WHOLE_SIZE, the effective range must: not be larger than
the maximum range for the descriptor type
(<<features-limits-maxUniformBufferRange, maxUniformBufferRange>> or
<<features-limits-maxStorageBufferRange, maxStorageBufferRange>>).
This means that ename:VK_WHOLE_SIZE is not typically useful in the common
case where uniform buffer descriptors are suballocated from a buffer that is
much larger than pname:maxUniformBufferRange.
====
--
+
For ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC and
ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC descriptor types,
pname:offset is the base offset from which the dynamic offset is applied and
pname:range is the static size used for all dynamic offsets.

.正确使用
****
  * pname:offset must: be less than the size of pname:buffer
  * If pname:range is not equal to ename:VK_WHOLE_SIZE, pname:range must: be
    greater than `0`
  * If pname:range is not equal to ename:VK_WHOLE_SIZE, pname:range must: be
    less than or equal to the size of pname:buffer minus pname:offset
****

include::../validity/structs/VkDescriptorBufferInfo.txt[]

// refBegin VkDescriptorImageInfo Structure specifying descriptor image info

sname:VkDescriptorImageInfo 类型数据结构定义如下：

include::../api/structs/VkDescriptorImageInfo.txt[]

  * pname:sampler is a sampler handle, and is used in descriptor updates for
    types ename:VK_DESCRIPTOR_TYPE_SAMPLER and
    ename:VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER if the binding being
    updated does not use immutable samplers.
  * pname:imageView is an image view handle, and is used in descriptor
    updates for types ename:VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE,
    ename:VK_DESCRIPTOR_TYPE_STORAGE_IMAGE,
    ename:VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, and
    ename:VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT.
  * pname:imageLayout is the layout that the image will be in at the time
    this descriptor is accessed.
    pname:imageLayout is used in descriptor updates for types
    ename:VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE,
    ename:VK_DESCRIPTOR_TYPE_STORAGE_IMAGE,
    ename:VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, and
    ename:VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT.

Members of sname:VkDescriptorImageInfo that are not used in an update (as
described above) are ignored.

include::../validity/structs/VkDescriptorImageInfo.txt[]

// refBegin VkCopyDescriptorSet Structure specifying a copy descriptor set operation

sname:VkCopyDescriptorSet 类型数据结构定义如下：

include::../api/structs/VkCopyDescriptorSet.txt[]

  * pname:sType 是数据结构的类型。
  * pname:pNext 是 `NULL` 或者一个指向拓展特定的数据结构的指针。
  * pname:srcSet, pname:srcBinding, and pname:srcArrayElement are the source
    set, binding, and array element, respectively.
  * pname:dstSet, pname:dstBinding, and pname:dstArrayElement are the
    destination set, binding, and array element, respectively.
  * pname:descriptorCount is the number of descriptors to copy from the
    source to destination.
    If pname:descriptorCount is greater than the number of remaining array
    elements in the source or destination binding, those affect consecutive
    bindings in a manner similar to slink:VkWriteDescriptorSet above.

.正确使用
****
  * pname:srcBinding must: be a valid binding within pname:srcSet
  * The sum of pname:srcArrayElement and pname:descriptorCount must: be less
    than or equal to the number of array elements in the descriptor set
    binding specified by pname:srcBinding, and all applicable consecutive
    bindings, as described by <<descriptorsets-updates-consecutive>>
  * pname:dstBinding must: be a valid binding within pname:dstSet
  * The sum of pname:dstArrayElement and pname:descriptorCount must: be less
    than or equal to the number of array elements in the descriptor set
    binding specified by pname:dstBinding, and all applicable consecutive
    bindings, as described by <<descriptorsets-updates-consecutive>>
  * If pname:srcSet is equal to pname:dstSet, then the source and
    destination ranges of descriptors must: not overlap, where the ranges
    may: include array elements from consecutive bindings as described by
    <<descriptorsets-updates-consecutive>>
****

include::../validity/structs/VkCopyDescriptorSet.txt[]


[[descriptorsets-binding]]
=== Descriptor Set Binding

// refBegin vkCmdBindDescriptorSets Binds descriptor sets to a command buffer

To bind one or more descriptor sets to a command buffer, call:

include::../api/protos/vkCmdBindDescriptorSets.txt[]

  * pname:commandBuffer is the command buffer that the descriptor sets will
    be bound to.
  * pname:pipelineBindPoint is a elink:VkPipelineBindPoint indicating
    whether the descriptors will be used by graphics pipelines or compute
    pipelines.
    There is a separate set of bind points for each of graphics and compute,
    so binding one does not disturb the other.
  * pname:layout is a sname:VkPipelineLayout object used to program the
    bindings.
  * pname:firstSet is the set number of the first descriptor set to be
    bound.
  * pname:descriptorSetCount is the number of elements in the
    pname:pDescriptorSets array.
  * pname:pDescriptorSets is an array of handles to sname:VkDescriptorSet
    objects describing the descriptor sets to write to.
  * pname:dynamicOffsetCount is the number of dynamic offsets in the
    pname:pDynamicOffsets array.
  * pname:pDynamicOffsets is a pointer to an array of code:uint32_t values
    specifying dynamic offsets.

fname:vkCmdBindDescriptorSets causes the sets numbered [pname:firstSet..
pname:firstSet+pname:descriptorSetCount-1] to use the bindings stored in
pname:pDescriptorSets[0..pname:descriptorSetCount-1] for subsequent
rendering commands (either compute or graphics, according to the
pname:pipelineBindPoint).
Any bindings that were previously applied via these sets are no longer
valid.

Once bound, a descriptor set affects rendering of subsequent graphics or
compute commands in the command buffer until a different set is bound to the
same set number, or else until the set is disturbed as described in
<<descriptorsets-compatibility, Pipeline Layout Compatibility>>.

A compatible descriptor set must: be bound for all set numbers that any
shaders in a pipeline access, at the time that a draw or dispatch command is
recorded to execute using that pipeline.
However, if none of the shaders in a pipeline statically use any bindings
with a particular set number, then no descriptor set need be bound for that
set number, even if the pipeline layout includes a non-trivial descriptor
set layout for that set number.

If any of the sets being bound include dynamic uniform or storage buffers,
then pname:pDynamicOffsets includes one element for each array element in
each dynamic descriptor type binding in each set.
Values are taken from pname:pDynamicOffsets in an order such that all
entries for set N come before set N+1; within a set, entries are ordered by
the binding numbers in the descriptor set layouts; and within a binding
array, elements are in order.
pname:dynamicOffsetCount must: equal the total number of dynamic descriptors
in the sets being bound.

The effective offset used for dynamic uniform and storage buffer bindings is
the sum of the relative offset taken from pname:pDynamicOffsets, and the
base address of the buffer plus base offset in the descriptor set.
The length of the dynamic uniform and storage buffer bindings is the buffer
range as specified in the descriptor set.

Each of the pname:pDescriptorSets must: be compatible with the pipeline
layout specified by pname:layout.
The layout used to program the bindings must: also be compatible with the
pipeline used in subsequent graphics or compute commands, as defined in the
<<descriptorsets-compatibility, Pipeline Layout Compatibility>> section.

The descriptor set contents bound by a call to fname:vkCmdBindDescriptorSets
may: be consumed during host execution of the command, or during shader
execution of the resulting draws, or any time in between.
Thus, the contents must: not be altered (overwritten by an update command,
or freed) between when the command is recorded and when the command
completes executing on the queue.
The contents of pname:pDynamicOffsets are consumed immediately during
execution of fname:vkCmdBindDescriptorSets.
Once all pending uses have completed, it is legal to update and reuse a
descriptor set.

.正确使用
****
  * Any given element of pname:pDescriptorSets must: have been allocated
    with a sname:VkDescriptorSetLayout that matches (is the same as, or
    identically defined as) the sname:VkDescriptorSetLayout at set _n_ in
    pname:layout, where _n_ is the sum of pname:firstSet and the index into
    pname:pDescriptorSets
  * pname:dynamicOffsetCount must: be equal to the total number of dynamic
    descriptors in pname:pDescriptorSets
  * The sum of pname:firstSet and pname:descriptorSetCount must: be less
    than or equal to sname:VkPipelineLayoutCreateInfo::pname:setLayoutCount
    provided when pname:layout was created
  * pname:pipelineBindPoint must: be supported by the pname:commandBuffer's
    parent sname:VkCommandPool's queue family
  * Any given element of pname:pDynamicOffsets must: satisfy the required
    alignment for the corresponding descriptor binding's descriptor type
****

include::../validity/protos/vkCmdBindDescriptorSets.txt[]


=== Push Constant Updates

[[descriptorsets-push-constants]]

As described above in section <<descriptorsets-pipelinelayout, Pipeline
Layouts>>, the pipeline layout defines shader push constants which are
updated via Vulkan commands rather than via writes to memory or copy
commands.

[NOTE]
.注意
====
Push constants represent a high speed path to modify constant data in
pipelines that is expected to outperform memory-backed resource updates.
====

The values of push constants are undefined at the start of a command buffer.

// refBegin vkCmdPushConstants Update the values of push constants

欲更新push constants，可调用：

include::../api/protos/vkCmdPushConstants.txt[]

  * pname:commandBuffer is the command buffer in which the push constant
    update will be recorded.
  * pname:layout is the pipeline layout used to program the push constant
    updates.
  * pname:stageFlags is a bitmask of elink:VkShaderStageFlagBits specifying
    the shader stages that will use the push constants in the updated range.
  * pname:offset is the start offset of the push constant range to update,
    in units of bytes.
  * pname:size is the size of the push constant range to update, in units of
    bytes.
  * pname:pValues is an array of pname:size bytes containing the new push
    constant values.

.正确使用
****
  * pname:stageFlags must: match exactly the shader stages used in
    pname:layout for the range specified by pname:offset and pname:size
  * pname:offset must: be a multiple of `4`
  * pname:size must: be a multiple of `4`
  * pname:offset must: be less than
    sname:VkPhysicalDeviceLimits::pname:maxPushConstantsSize
  * pname:size must: be less than or equal to
    sname:VkPhysicalDeviceLimits::pname:maxPushConstantsSize minus
    pname:offset
****

include::../validity/protos/vkCmdPushConstants.txt[]
