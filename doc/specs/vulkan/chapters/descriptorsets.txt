// Copyright (c) 2015-2017 The Khronos Group Inc.
// Copyright notice at https://www.khronos.org/registry/speccopyright.html

[[descriptorsets]]
= 资源描述符

着色器通过使用特殊的着色器变量(通过API间接绑定到缓冲区或者图像视图)来访问缓冲区和图像资源。
这些变量被组织进入集合，每一个绑定的集合都通过API的一个 _描述符集合_ 对象来表示，描述符集合只能被绑定一次。
一个 _描述符_ 是一个不透明的数据类型，表示一个着色器资源，诸如缓冲区视图、图像视图、采样器或者被绑定的着色器资源。
每一个集合的内容由它自己的 _描述集合布局_ 来决定，可以被管线内部的着色器资源变量使用的集合布局的序列由  _pipeline layout_ 指定。

每一个着色器可以使用最多pname:maxBoundDescriptorSets 个描述符集合（参考<<features-limits, Limits>>），
每一个描述符集合可以包含所有类型描述符的绑定。
每一个着色器资源变量都被赋值为一个tuple（集合个数，绑定个数，数组元素），定义了它在描述集合布局中的位置。
在GLSL中，集合个数和绑定个数是通过布局限定符赋值的，数组元素是被连续的赋值到其中，数组中第一个元素的索引为0（非数组变量的位置用0填充）。


.GLSL example
[source,glsl]
---------------------------------------------------
// Assign set number = M, binding number = N, array element = 0
layout (set=M, binding=N) uniform sampler2D variableName;

// Assign set number = M, binding number = N for all array elements, and
// array element = I for the I'th member of the array.
layout (set=M, binding=N) uniform sampler2D variableNameArray[I];
---------------------------------------------------

.SPIR-V example
[source,spirv]
---------------------------------------------------
// Assign set number = M, binding number = N, array element = 0
               ...
          %1 = OpExtInstImport "GLSL.std.450"
               ...
               OpName %10 "variableName"
               OpDecorate %10 DescriptorSet M
               OpDecorate %10 Binding N
          %2 = OpTypeVoid
          %3 = OpTypeFunction %2
          %6 = OpTypeFloat 32
          %7 = OpTypeImage %6 2D 0 0 0 1 Unknown
          %8 = OpTypeSampledImage %7
          %9 = OpTypePointer UniformConstant %8
         %10 = OpVariable %9 UniformConstant
               ...

// Assign set number = M, binding number = N for all array elements, and
// array element = I for the I'th member of the array.
               ...
          %1 = OpExtInstImport "GLSL.std.450"
               ...
               OpName %13 "variableNameArray"
               OpDecorate %13 DescriptorSet M
               OpDecorate %13 Binding N
          %2 = OpTypeVoid
          %3 = OpTypeFunction %2
          %6 = OpTypeFloat 32
          %7 = OpTypeImage %6 2D 0 0 0 1 Unknown
          %8 = OpTypeSampledImage %7
          %9 = OpTypeInt 32 0
         %10 = OpConstant %9 I
         %11 = OpTypeArray %8 %10
         %12 = OpTypePointer UniformConstant %11
         %13 = OpVariable %12 UniformConstant
               ...
---------------------------------------------------


[[descriptorsets-types]]
== 描述符类型
如下几个小节简单讲解Vulkan支持的各种描述符类型。
每一小节定义了一种描述符类型，每一种类型在着色器语言和SPIR-V中都有详细讲解。
描述符类型和着色器语言中不透明类型的类别大多数情况下是一对一的，着色器语言中不透明类型必须指代
对应描述符类型的管线布局中的一个描述符。
但是，对于此规则，如下情形是一个例外
<<descriptorsets-combinedimagesampler, Combined Image Sampler>>。


[[descriptorsets-storageimage]]
=== 存储图像

一个 _storage image_ (ename:VK_DESCRIPTOR_TYPE_STORAGE_IMAGE) 是一种描述符类型，
用于绑定到管线的着色器内部 对图像的装载、存储和原子操作。

从 storage images 中装载并不会使用采样器，且是unfiltered，并不支持
坐标折叠与截断。
flink:vkGetPhysicalDeviceFormatProperties 指定的 <<features-formats-properties,ename:VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT>>
支持的图像格式都能在所有的着色器阶段中载入。

ename:VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT 格式图像可以在计算着色器中 存储到 storage images 。


<<features-formats-properties,ename:VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT>>
格式的图像可以支持在计算着色器中进行原子操作。

storage images 上的载入与存储操作，只能在
ename:VK_IMAGE_LAYOUT_GENERAL 布局的图像上进行。

当<<features-features-fragmentStoresAndAtomics,
pname:fragmentStoresAndAtomics>> 特征被启用，那么就可支持 对同一集合的图像格式的storage images 在
片元着色器阶段内执行 存储和原子操作。
当 <<features-features-vertexPipelineStoresAndAtomics, pname:vertexPipelineStoresAndAtomics>> 特征被启用时，
那么对 计算着色器阶段受支持的图像格式，同样也支持在顶点、细分、几何着色器阶段进行 存储和原子操作。


在着色器内，若变量被用于原子操作，Storage image 声明必须指定图像格式。

若 <<features-features-shaderStorageImageReadWithoutFormat,
pname:shaderStorageImageReadWithoutFormat>> 特征没有被启用，在着色器内，若变量被用于载入操作， storage
image 声明必须指定图像格式。

若 <<features-features-shaderStorageImageWriteWithoutFormat,
pname:shaderStorageImageWriteWithoutFormat>> 特征没有被启用，在着色器内，若变量被用于存储操作，
 storage image 声明必须指定图像格式。


Storage images 在GLSL着色器源代码中使用 uniform code:image 声明一个变量为合适的维度，同样与指定格式布局描述:

.GLSL example
[source,glsl]
---------------------------------------------------
layout (set=m, binding=n, r32f) uniform image2D myStorageImage;
---------------------------------------------------

.SPIR-V example
[source,spirv]
---------------------------------------------------
               ...
          %1 = OpExtInstImport "GLSL.std.450"
               ...
               OpName %9 "myStorageImage"
               OpDecorate %9 DescriptorSet m
               OpDecorate %9 Binding n
          %2 = OpTypeVoid
          %3 = OpTypeFunction %2
          %6 = OpTypeFloat 32
          %7 = OpTypeImage %6 2D 0 0 0 2 R32f
          %8 = OpTypePointer UniformConstant %7
          %9 = OpVariable %8 UniformConstant
               ...
---------------------------------------------------


[[descriptorsets-sampler]]
=== 采样器
一个 _sampler_ (ename:VK_DESCRIPTOR_TYPE_SAMPLER) 代表一系列的参数，它控制了寻址计算，过滤行为，和其他的属性，
这可以被用于执行从一个 采样过的图像 进行过滤加载(参考 <<descriptorsets-sampledimage, 采样的图像>>)。

采样器时在GLSL着色器代码中使用 uniform code:sampler 来声明的变量，采样器类型并没有关联的纹理维度：


.GLSL Example
[source,glsl]
---------------------------------------------------
layout (set=m, binding=n) uniform sampler mySampler;
---------------------------------------------------

.SPIR-V example
[source,spirv]
---------------------------------------------------
               ...
          %1 = OpExtInstImport "GLSL.std.450"
               ...
               OpName %8 "mySampler"
               OpDecorate %8 DescriptorSet m
               OpDecorate %8 Binding n
          %2 = OpTypeVoid
          %3 = OpTypeFunction %2
          %6 = OpTypeSampler
          %7 = OpTypePointer UniformConstant %6
          %8 = OpVariable %7 UniformConstant
               ...
---------------------------------------------------


[[descriptorsets-sampledimage]]
=== 采样的图像

一个 _采样的图像_ (ename:VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE) 可以: 被用于从采样过的图像数据中提取数据
（通常联合使用一个采样器）。 着色器使用一个采样的图像handle，与 一个采样器handle来采样数据，图像handle通常定义里内存的
形状和格式，采样器通常定义了如何进行坐标系寻址。
同一个采样器可以被用于对多个图像，且可以使用多个采样器对同一个采样的图像进行采样，每一个都包含不同的采样参数。

采样的图像在GLSL着色器源代码中使用uniform code:texture 变量来声明，有合适维度：


.GLSL example
[source,glsl]
---------------------------------------------------
layout (set=m, binding=n) uniform texture2D mySampledImage;
---------------------------------------------------

.SPIR-V example
[source,spirv]
---------------------------------------------------
               ...
          %1 = OpExtInstImport "GLSL.std.450"
               ...
               OpName %9 "mySampledImage"
               OpDecorate %9 DescriptorSet m
               OpDecorate %9 Binding n
          %2 = OpTypeVoid
          %3 = OpTypeFunction %2
          %6 = OpTypeFloat 32
          %7 = OpTypeImage %6 2D 0 0 0 1 Unknown
          %8 = OpTypePointer UniformConstant %7
          %9 = OpVariable %8 UniformConstant
               ...
---------------------------------------------------


[[descriptorsets-combinedimagesampler]]
=== 联合图像采样器

一个 _combined image sampler_ (ename:VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER)
代表一个采样的图像，且带有一些采样参数。在逻辑上，他被认为是一个采样的图像，且绑定了一个采样器。

[NOTE]
.注意
====
在一些Vulkan实现上，可能: 使用采样器与采样的图像结合的方式从图像中采样可能更高效，采样器与采样的图像存储在联合的描述中的描述符集合。
====

在着色器源代码中使用 合适维度的 uniform code:sampler 变量 来声明 联合图像采样器：

.GLSL example
[source,glsl]
---------------------------------------------------
layout (set=m, binding=n) uniform sampler2D myCombinedImageSampler;
---------------------------------------------------

.SPIR-V example
[source,spirv]
---------------------------------------------------
               ...
          %1 = OpExtInstImport "GLSL.std.450"
               ...
               OpName %10 "myCombinedImageSampler"
               OpDecorate %10 DescriptorSet m
               OpDecorate %10 Binding n
          %2 = OpTypeVoid
          %3 = OpTypeFunction %2
          %6 = OpTypeFloat 32
          %7 = OpTypeImage %6 2D 0 0 0 1 Unknown
          %8 = OpTypeSampledImage %7
          %9 = OpTypePointer UniformConstant %8
         %10 = OpVariable %9 UniformConstant
               ...
---------------------------------------------------

ename:VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER 描述符集合的入口 也可以
通过单独的采样器和采样图像着色器变量 来 访问。
此种变量指除了 描述中对应的一半，可以在着色器中与采样器或者采样的描述符联合，可以在着色器中与采样器或采样的图像联合，该图像来自于
同一个描述符，或者来自其他联合或独立描述符类型的同一个描述符。
在独立的采样器或采样的图像变量如何被使用来从一个联合描述符转换到另一个时，并不存在额外的限制条件。


[[descriptorsets-uniformtexelbuffer]]
=== 统一纹素缓冲区

一个 _uniform texel buffer_ (ename:VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER)
代表一个紧致压缩的同构格式数据的数组，存储在一个缓冲区，且可被着色器访问。统一纹素缓冲区是只读的。

可在GLSL源代码中使用 统一code:samplerBuffer变量  声明统一纹素缓冲区：
.GLSL example
[source,glsl]
---------------------------------------------------
layout (set=m, binding=n) uniform samplerBuffer myUniformTexelBuffer;
---------------------------------------------------

.SPIR-V example
[source,spirv]
---------------------------------------------------
               ...
          %1 = OpExtInstImport "GLSL.std.450"
               ...
               OpName %10 "myUniformTexelBuffer"
               OpDecorate %10 DescriptorSet m
               OpDecorate %10 Binding n
          %2 = OpTypeVoid
          %3 = OpTypeFunction %2
          %6 = OpTypeFloat 32
          %7 = OpTypeImage %6 Buffer 0 0 0 1 Unknown
          %8 = OpTypeSampledImage %7
          %9 = OpTypePointer UniformConstant %8
         %10 = OpVariable %9 UniformConstant
               ...
---------------------------------------------------


[[descriptorsets-storagetexelbuffer]]
=== 仓库纹素缓冲区

一个 _storage texel buffer_ (ename:VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER)
代表一个紧致压缩的同构格式数据数组，被存储在一个缓冲区，且着色器可访问。
仓库纹素缓冲区与 统一纹素缓冲区不同点在于它们支持存储和 着色器内原子操作，也支持不同的最大长度，亦可有不同的性能特征。

在GLSL源代码中，可使用统一code:imageBuffer变量来声明 仓储纹素缓冲区：


.GLSL example
[source,glsl]
---------------------------------------------------
layout (set=m, binding=n, r32f) uniform imageBuffer myStorageTexelBuffer;
---------------------------------------------------

.SPIR-V example
[source,spirv]
---------------------------------------------------
               ...
          %1 = OpExtInstImport "GLSL.std.450"
               ...
               OpName %9 "myStorageTexelBuffer"
               OpDecorate %9 DescriptorSet m
               OpDecorate %9 Binding n
          %2 = OpTypeVoid
          %3 = OpTypeFunction %2
          %6 = OpTypeFloat 32
          %7 = OpTypeImage %6 Buffer 0 0 0 2 R32f
          %8 = OpTypePointer UniformConstant %7
          %9 = OpVariable %8 UniformConstant
               ...
---------------------------------------------------


[[descriptorsets-uniformbuffer]]
=== 统一缓冲区

一个 _uniform buffer_ (ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER) 是一个结构化的存储区域，
对于着色器程序而言只能够只读访问。
它通常被用来初春中等字节大小的常量述祖，例如着色器参数，矩阵，其他相关的数据。

可在GLSL着色器源代码中使用 统一存储描述符和block语法来声明 统一缓冲区：

.GLSL example
[source,glsl]
---------------------------------------------------
layout (set=m, binding=n) uniform myUniformBuffer
{
    vec4 myElement[32];
};
---------------------------------------------------

.SPIR-V example
[source,spirv]
---------------------------------------------------
               ...
          %1 = OpExtInstImport "GLSL.std.450"
               ...
               OpName %11 "myUniformBuffer"
               OpMemberName %11 0 "myElement"
               OpName %13 ""
               OpDecorate %10 ArrayStride 16
               OpMemberDecorate %11 0 Offset 0
               OpDecorate %11 Block
               OpDecorate %13 DescriptorSet m
               OpDecorate %13 Binding n
          %2 = OpTypeVoid
          %3 = OpTypeFunction %2
          %6 = OpTypeFloat 32
          %7 = OpTypeVector %6 4
          %8 = OpTypeInt 32 0
          %9 = OpConstant %8 32
         %10 = OpTypeArray %7 %9
         %11 = OpTypeStruct %10
         %12 = OpTypePointer Uniform %11
         %13 = OpVariable %12 Uniform
               ...
---------------------------------------------------


[[descriptorsets-storagebuffer]]
=== 存储缓冲区

一个 _storage buffer_ (ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER) 是一个结构化存储的区域，
他支持着色器的读写访问。
除了常规读写操作，存储缓冲区的一些成员可被用于原子操作的对象。
总的来说，原子操作通常只支持有无符号整型格式的成员。

可在GLSL着色器源代码中使用缓冲区存储描述符和block语法来声明存储缓冲区：

.GLSL example
[source,glsl]
---------------------------------------------------
layout (set=m, binding=n) buffer myStorageBuffer
{
    vec4 myElement[];
};
---------------------------------------------------

.SPIR-V example
[source,spirv]
---------------------------------------------------
               ...
          %1 = OpExtInstImport "GLSL.std.450"
               ...
               OpName %9 "myStorageBuffer"
               OpMemberName %9 0 "myElement"
               OpName %11 ""
               OpDecorate %8 ArrayStride 16
               OpMemberDecorate %9 0 Offset 0
               OpDecorate %9 BufferBlock
               OpDecorate %11 DescriptorSet m
               OpDecorate %11 Binding n
          %2 = OpTypeVoid
          %3 = OpTypeFunction %2
          %6 = OpTypeFloat 32
          %7 = OpTypeVector %6 4
          %8 = OpTypeRuntimeArray %7
          %9 = OpTypeStruct %8
         %10 = OpTypePointer Uniform %9
         %11 = OpVariable %10 Uniform
               ...
---------------------------------------------------


[[descriptorsets-uniformbufferdynamic]]
=== 动态统一缓冲区

一个 _dynamic uniform buffer_ (ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC)
与统一缓冲区的唯一区别在于它的地址与长度是如何被指定的。
统一缓冲区与一个缓冲区地址绑定，长度在描述符集合更新的缓冲区handle、偏移与区间来指定(参考
<<descriptorsets-updates, Descriptor Set Updates>>)。
使用动态统一缓冲区指定缓冲区句柄、偏移量和范围 在描述符集中定义基本地址和长度。
相对于这个基础地址的动态偏移是从pname:pDynamicOffsets 参数取出到 flink:vkCmdBindDescriptorSets (参考
<<descriptorsets-binding, Descriptor Set Binding>>)。
用于动态统一缓冲区的地址是缓冲区base 地址和相对偏移之和。
长度未被改变，且保持区间为描述符更新中指定的大小。
动态缓冲区着色器语法和统一缓冲区一样。



[[descriptorsets-storagebufferdynamic]]
=== 动态仓储缓冲区

一个 _dynamic storage buffer_ (ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC)
与仓储缓冲区的唯一不同点是它的地址与长度是如何被指定的。
不同之处和统一缓冲区与动态缓冲区之间的差别是一样的(参考 <<descriptorsets-uniformbufferdynamic, Dynamic
Uniform Buffer>>).
动态仓储缓冲区着色器语法和仓储缓冲区的一样。



[[descriptorsets-inputattachment]]
=== 输入附件

一个 _input attachment_ (ename:VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT) 是一个图像时图，可以被用于
绑定到管线的片元着色器内像素局部载入操作。
从输入附件中载入的内容是unfiltered。
对于一个给定图像的tiling模式 的颜色附件(ename:VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT)或者深度/stencil
(ename:VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT)
 附件支持的所有图像格式 都为输入附件所支持。

在着色器内，除了描述符集合和绑定数量，输入附件必须 被它们的输入附件所引所描述。


.GLSL example
[source,glsl]
---------------------------------------------------
layout (input_attachment_index=i, set=m, binding=n) uniform subpassInput myInputAttachment;
---------------------------------------------------

.SPIR-V example
[source,spirv]
---------------------------------------------------
               ...
          %1 = OpExtInstImport "GLSL.std.450"
               ...
               OpName %9 "myInputAttachment"
               OpDecorate %9 DescriptorSet m
               OpDecorate %9 Binding n
               OpDecorate %9 InputAttachmentIndex i
          %2 = OpTypeVoid
          %3 = OpTypeFunction %2
          %6 = OpTypeFloat 32
          %7 = OpTypeImage %6 SubpassData 0 0 0 2 Unknown
          %8 = OpTypePointer UniformConstant %7
          %9 = OpVariable %8 UniformConstant
               ...
---------------------------------------------------


[[descriptorsets-sets]]
== 描述符集合

多个描述符被分组进入一个描述符集合对象中。一个描述符集合对象是一个不透明对象，包含一个描述符集合的存储
，类型和描述符的数量由一个描述符集合布局所定义。
布局对象也许会被用于定义每一个描述符与内存或者其他硬件资源绑定的关联信息。
布局被用于决定被关联到描述符集合的资源，且决定着色器资源与着色器阶段直接的接口。


[[descriptorsets-setlayout]]
=== 描述符集合布局


// refBegin VkDescriptorSetLayout Opaque handle to a descriptor set layout object

一个描述符集合布局对象是通过一个描述符绑定的数组来定义的。
每一个描述符绑定都有一个指定的描述符类型，绑定之中的描述符数量（数组元素个数），可访问到绑定的着色器阶段的集合，
和一个采样器描述符数组（若使用不可变采样器的话）。

描述符集合布局对象通过 sname:VkDescriptorSetLayout 类型handle 来定义：

include::../api/handles/VkDescriptorSetLayout.txt[]

// refEnd VkDescriptorSetLayout

// refBegin vkCreateDescriptorSetLayout Create a new descriptor set layout

想要创建描述符集合对象，可调用：

include::../api/protos/vkCreateDescriptorSetLayout.txt[]

  * pname:device 是创建描述符集合对象布局的逻辑设备。
  * pname:pCreateInfo 是一个指针，指向一个
    slink:VkDescriptorSetLayoutCreateInfo 数据结构实例，指定了描述符集合布局对象的状态。
  * pname:pAllocator 控制CPU端内存分配，如<<memory-allocation, Memory Allocation>> 一章所述。
  * pname:pSetLayout 指向一个 sname:VkDescriptorSetLayout handle，它存储被生成的描述符集合布局对象。


include::../validity/protos/vkCreateDescriptorSetLayout.txt[]

// refBegin VkDescriptorSetLayoutCreateInfo Structure specifying parameters of a newly created descriptor set layout

关于描述符集合布局的信息是包含在一个sname:VkDescriptorSetLayoutCreateInfo数据结构实例中被传递的。

include::../api/structs/VkDescriptorSetLayoutCreateInfo.txt[]

  * pname:sType 是数据结构的类型。
  * pname:pNext 是 `NULL` 或者一个指向拓展特定的数据结构的指针。
  * pname:flags 被保留。
  * pname:bindingCount 是 pname:pBindings 中元素的个数。
  * pname:pBindings 是一个指针，指向一个元素类型为 slink:VkDescriptorSetLayoutBinding的数组。

.正确使用
****
  * pname:pBindings 数组的slink:VkDescriptorSetLayoutBinding::pname:binding 成员必须
每一个都有不同的值。
****

include::../validity/structs/VkDescriptorSetLayoutCreateInfo.txt[]

// refBegin VkDescriptorSetLayoutBinding Structure specifying a descriptor set layout binding

sname:VkDescriptorSetLayoutBinding 类型数据结构定义如下：

include::../api/structs/VkDescriptorSetLayoutBinding.txt[]

  * pname:binding 是此入口的的绑定数，对应着色器阶段内等于此绑定数的一个资源。
  * pname:descriptorType 是一个 elink:VkDescriptorType，指定了 被用于此次绑定的资源描述的类型。
  * pname:descriptorCount 是绑定内被包含的描述符的个数，以数组的形式可以在着色器内访问到。
    若 pname:descriptorCount 为0，此绑定入口被保留，资源不能从任何阶段内通过 使用此集合布局的任何管线之内的绑定 被访问到。
  * pname:stageFlags 成员是一个 elink:VkShaderStageFlagBits类型的位掩码，指定了可以为此绑定访问的管线着色器阶段。
    ename:VK_SHADER_STAGE_ALL 是一种简洁写法，指定了所有被定义的着色器阶段，包含任何额外的拓展定义的阶段，可以访问资源。
+
--
If a shader stage is not included in pname:stageFlags, then a resource must:
not be accessed from that stage via this binding within any pipeline using
the set layout.
There are no limitations on what combinations of stages can: be used by a
descriptor binding, and in particular a binding can: be used by both
graphics stages and the compute stage.
--
  * pname:pImmutableSamplers 影响采样器的初始化。
    若 pname:descriptorType 指定了一个 ename:VK_DESCRIPTOR_TYPE_SAMPLER 或
    ename:VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER 类型的描述符，那么
    pname:pImmutableSamplers 可以被用于初始化一个集合的 _immutable samplers_.
    Immutable samplers 被永久绑定到此集合布局；伺候绑定一个采样器到一个 描述符集合内的 immutable sampler 槽，是不被允许的。
    若 pname:pImmutableSamplers 不为`NULL`，那么它被认为是一个指针，指向一个采样器handle 数组，将被集合布局所使用，且被用于对应的绑定。
    若 pname:pImmutableSamplers 为 `NULL`，那么此采样器槽是动态的，采样器hadle 必需使用此布局 被绑定到描述符集合。
    若 pname:descriptorType 不是这些描述符类型其中之一，那么 pname:pImmutableSamplers 被忽略。

上面的布局定义允许此描述符绑定为指定的稀疏形式，因此并不是在0 和最大绑定数 之间的所有的绑定数 需要在pname:pBindings数组中指定。
Bindings that are not specified 没有明确指定的绑定 含有一个 pname:descriptorCount 与pname:stageFlags 为0，且pname:descriptorType 被当作未定义。
然而，slink:VkDescriptorSetLayoutCreateInfo::pname:pBindings数组内 在0与最大绑定数之间的所有绑定数，可能
在描述符集合布局内消耗内存，即使不是所有的描述符绑定都被使用了，即便是它不应该从描述符池中消耗额外的内存。


[NOTE]
.注意
====
被指定的最大绑定数 应该是尽量紧致，避免浪费内存。
====

.正确使用
****
  * 若 pname:descriptorType 是 ename:VK_DESCRIPTOR_TYPE_SAMPLER 或者
    ename:VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER，且
    pname:descriptorCount 不为 `0` 、 pname:pImmutableSamplers 不为
    `NULL`, pname:pImmutableSamplers 必须: 是一个指向
    pname:descriptorCount 个有效 sname:VkSampler handles的数组的指针。
  * 若 pname:descriptorCount 不为 `0`, pname:stageFlags 必须: 是一个有效的elink:VkShaderStageFlagBits 类型值。
****

include::../validity/structs/VkDescriptorSetLayoutBinding.txt[]

The following examples show a shader snippet using two descriptor sets, and
application code that creates corresponding descriptor set layouts.

.GLSL example
[source,glsl]
---------------------------------------------------
//
// binding to a single sampled image descriptor in set 0
//
layout (set=0, binding=0) uniform texture2D mySampledImage;

//
// binding to an array of sampled image descriptors in set 0
//
layout (set=0, binding=1) uniform texture2D myArrayOfSampledImages[12];

//
// binding to a single uniform buffer descriptor in set 1
//
layout (set=1, binding=0) uniform myUniformBuffer
{
    vec4 myElement[32];
};
---------------------------------------------------

.SPIR-V example
[source,spirv]
---------------------------------------------------
               ...
          %1 = OpExtInstImport "GLSL.std.450"
               ...
               OpName %9 "mySampledImage"
               OpName %14 "myArrayOfSampledImages"
               OpName %18 "myUniformBuffer"
               OpMemberName %18 0 "myElement"
               OpName %20 ""
               OpDecorate %9 DescriptorSet 0
               OpDecorate %9 Binding 0
               OpDecorate %14 DescriptorSet 0
               OpDecorate %14 Binding 1
               OpDecorate %17 ArrayStride 16
               OpMemberDecorate %18 0 Offset 0
               OpDecorate %18 Block
               OpDecorate %20 DescriptorSet 1
               OpDecorate %20 Binding 0
          %2 = OpTypeVoid
          %3 = OpTypeFunction %2
          %6 = OpTypeFloat 32
          %7 = OpTypeImage %6 2D 0 0 0 1 Unknown
          %8 = OpTypePointer UniformConstant %7
          %9 = OpVariable %8 UniformConstant
         %10 = OpTypeInt 32 0
         %11 = OpConstant %10 12
         %12 = OpTypeArray %7 %11
         %13 = OpTypePointer UniformConstant %12
         %14 = OpVariable %13 UniformConstant
         %15 = OpTypeVector %6 4
         %16 = OpConstant %10 32
         %17 = OpTypeArray %15 %16
         %18 = OpTypeStruct %17
         %19 = OpTypePointer Uniform %18
         %20 = OpVariable %19 Uniform
               ...
---------------------------------------------------

.API example
[source,c++]
-------------------------------------------------------------------------------
VkResult myResult;

const VkDescriptorSetLayoutBinding myDescriptorSetLayoutBinding[] =
{
    // binding to a single image descriptor
    {
        0,                                      // binding
        VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE,       // descriptorType
        1,                                      // descriptorCount
        VK_SHADER_STAGE_FRAGMENT_BIT,           // stageFlags
        NULL                                    // pImmutableSamplers
    },

    // binding to an array of image descriptors
    {
        1,                                      // binding
        VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE,       // descriptorType
        12,                                     // descriptorCount
        VK_SHADER_STAGE_FRAGMENT_BIT,           // stageFlags
        NULL                                    // pImmutableSamplers
    },

    // binding to a single uniform buffer descriptor
    {
        0,                                      // binding
        VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER,      // descriptorType
        1,                                      // descriptorCount
        VK_SHADER_STAGE_FRAGMENT_BIT,           // stageFlags
        NULL                                    // pImmutableSamplers
    }
};

const VkDescriptorSetLayoutCreateInfo myDescriptorSetLayoutCreateInfo[] =
{
    // Create info for first descriptor set with two descriptor bindings
    {
        VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO,    // sType
        NULL,                                                   // pNext
        0,                                                      // flags
        2,                                                      // bindingCount
        &myDescriptorSetLayoutBinding[0]                        // pBindings
    },

    // Create info for second descriptor set with one descriptor binding
    {
        VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO,    // sType
        NULL,                                                   // pNext
        0,                                                      // flags
        1,                                                      // bindingCount
        &myDescriptorSetLayoutBinding[2]                        // pBindings
    }
};

VkDescriptorSetLayout myDescriptorSetLayout[2];

//
// Create first descriptor set layout
//
myResult = vkCreateDescriptorSetLayout(
    myDevice,
    &myDescriptorSetLayoutCreateInfo[0],
    NULL,
    &myDescriptorSetLayout[0]);

//
// Create second descriptor set layout
//
myResult = vkCreateDescriptorSetLayout(
    myDevice,
    &myDescriptorSetLayoutCreateInfo[1],
    NULL,
    &myDescriptorSetLayout[1]);
-------------------------------------------------------------------------------

// refBegin vkDestroyDescriptorSetLayout Destroy a descriptor set layout object

想要销毁描述符集合布局，可调用：

include::../api/protos/vkDestroyDescriptorSetLayout.txt[]

  * pname:device 是销毁描述符集合布局的逻辑设备。
  * pname:descriptorSetLayout 是需要被销毁的描述符集合布局。
  * pname:pAllocator 控制CPU端内存分配，如 <<memory-allocation, Memory Allocation>> 一章所述。

.正确使用
****
  * 若在创建pname:descriptorSetLayout 是提供了 sname:VkAllocationCallbacks，那么也必须在此处
    提供兼容的callbacks。
  * 若在创建pname:descriptorSetLayout时没有提供  sname:VkAllocationCallbacks，那么pname:pAllocator 必须: 为 `NULL`
****

include::../validity/protos/vkDestroyDescriptorSetLayout.txt[]


[[descriptorsets-pipelinelayout]]
=== 管线布局

// refBegin VkPipelineLayout Opaque handle to a pipeline layout object

从管线中访问描述符集合是通过 _pipeline layout_ 实现的。
零个或者多个描述符集合布局，零个或者多个push constant 区间被联合形成一个管线布局对象，它描述了可以被管线访问的资源的完整集合。
管线布局可表示连续的描述符集合，每一个都有指定的布局。
布局的序列用于决定着色器阶段之间的接口和着色器资源。
每一个管线是通过管线布局创建的。

管线布局对象可使用 sname:VkPipelineLayout handle表示:

include::../api/handles/VkPipelineLayout.txt[]

// refEnd VkPipelineLayout

// refBegin vkCreatePipelineLayout Creates a new pipeline layout object

欲创建管线布局，可调用：

include::../api/protos/vkCreatePipelineLayout.txt[]

  * pname:device 是创建管线布局的逻辑设备。
  * pname:pCreateInfo 是一个指针，指向 slink:VkPipelineLayoutCreateInfo 数据结构实例，其指定来管线布局对象的状态。
  * pname:pAllocator 控制CPU端内存分配，如 <<memory-allocation, Memory Allocation>> 一章所述。
  * pname:pPipelineLayout 指向一个 sname:VkPipelineLayout handl，它是生成并被返回的管线布局对象。

include::../validity/protos/vkCreatePipelineLayout.txt[]

// refBegin VkPipelineLayoutCreateInfo Structure specifying the parameters of a newly created pipeline layout object

slink:VkPipelineLayoutCreateInfo 类型数据结构定义如下：

include::../api/structs/VkPipelineLayoutCreateInfo.txt[]

  * pname:sType 是数据结构的类型。
  * pname:pNext 是 `NULL` 或者一个指向拓展特定的数据结构的指针。
  * pname:flags 被保留。
  * pname:setLayoutCount 是包含在管线布局中的描述符集合的个数。
  * pname:pSetLayouts 是一个指针，指向sname:VkDescriptorSetLayout 类型的数组。
  * pname:pushConstantRangeCount 是包含在管线布局中的push constants区间的个数。
  * pname:pPushConstantRanges 是一个指针，指向    sname:VkPushConstantRange 类型数组，定一个了一个集合的push constants区间，
	被用于单个管线布局。除了描述符集合布局，一个管线布局也表述了管线的每个阶段可访问到的push constatns数量。
+
[NOTE]
.注意
====
Push constants 可表示修改管线内常量数据的高速通道，此方式设计目标就应该比基于内存的资源更新更高效率。
====

.正确使用
****
  * pname:setLayoutCount 必须: 小于等于 sname:VkPhysicalDeviceLimits::pname:maxBoundDescriptorSets
  * 可被pname:pSetLayouts 之中 任意着色器阶段访问的
    ename:VK_DESCRIPTOR_TYPE_SAMPLER 和
    ename:VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER 类型的描述符的总个数， 必须: 小于等于 sname:VkPhysicalDeviceLimits::pname:maxPerStageDescriptorSamplers
  * 可以被任何指定的 跨跃pname:pSetLayouts所有元素的 着色器阶段访问的
    ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER 和
    ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC类型的描述符的总数，必须小于等于
    sname:VkPhysicalDeviceLimits::pname:maxPerStageDescriptorUniformBuffers
  * 可以被任何指定的 跨跃pname:pSetLayouts所有元素的 着色器阶段访问的
    ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER 和
    ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC 类型的描述符的总数，必须小于等于
    sname:VkPhysicalDeviceLimits::pname:maxPerStageDescriptorStorageBuffers
  * 可以被任何指定的 跨跃pname:pSetLayouts所有元素的 着色器阶段访问的
    ename:VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER,
    ename:VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE, 和
    ename:VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER 类型的描述符的总数，必须小于等于
    sname:VkPhysicalDeviceLimits::pname:maxPerStageDescriptorSampledImages
  * 可以被任何指定的 跨跃pname:pSetLayouts所有元素的 着色器阶段访问的
    ename:VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, 和
    ename:VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER 类型的描述符的总数，必须小于等于
    sname:VkPhysicalDeviceLimits::pname:maxPerStageDescriptorStorageImages
  * pname:pPushConstantRanges 的任意两个元素 不能: 包含相同的 pname:stageFlags 阶段。
****

include::../validity/structs/VkPipelineLayoutCreateInfo.txt[]

// refBegin VkPushConstantRange Structure specifying a push constant range

sname:VkPushConstantRange 类型数据结构定义如下：

include::../api/structs/VkPushConstantRange.txt[]

  * pname:stageFlags 是一些阶段flags的集合，描述了将访问push constants的着色器阶段。若区间没有包含一个特定的阶段，那么
    从对应着色器阶段 访问该区间的数字 将会导致读出未定义的数据。
  * pname:offset 和 pname:size 各自是起始偏移和大小，描述该区间。
    pname:offset 和 pname:size 都是字节大小，且必须是 4 的倍数。push constants变量的布局在着色器中被指定。

.正确使用
****
  * pname:offset 必须: 小于 sname:VkPhysicalDeviceLimits::pname:maxPushConstantsSize
  * pname:offset 必须: 是`4`的倍数
  * pname:size 必须: 大于`0`
  * pname:size 必须: 是`4`的倍数
  * pname:size 必须: 小于等于
    sname:VkPhysicalDeviceLimits::pname:maxPushConstantsSize 减去 pname:offset之差
****

include::../validity/structs/VkPushConstantRange.txt[]

一旦被创建，管线布局被用于管线创建的一部分 (参考<<pipelines, Pipelines>>), 作为描述符集合绑定的一部分 (参考
<<descriptorsets-binding, Descriptor Set Binding>>), 而且作为设置push 常量的一部分
(参考 <<descriptorsets-push-constants, Push Constant Updates>>)。
管线创建接受一个管线布局作为输入，且布局可能被用于映射（集合、绑定、数组元素）tuples到硬件资源或者一个描述符集合的内存地址上。
硬件资源的管理只依赖于绑定，在组成管线布局的描述符集合中定义，且不依赖于任何着色器资源。

[[descriptorsets-pipelinelayout-consistency]]
All resource variables 在一个管线内所有着色器中的所有<<shaders-staticuse,statically used>> 的所有资源变量必须带有一个
(set,binding,arrayElement) 来被声明，它们存在于一个对应的描述符集合布局，且属于一个合适的描述符类型，且包含它被使用的
pname:stageFlags着色器阶段的集合。
管线布局可以包含不是被一个特定管线使用的入口，或者是任意着色器内被消除的 不会被执行的代码。
管线布局可以允许应用程序提供一个 跨多管线编译一致的绑定集合， 它让这些管线被按照一种方式被编译，于是Vulkan实现可以
低代价的的切换管线，而不需要重新编程绑定。

Similarly, the push constant block declared in each shader (if present)
must: only place variables at offsets that are each included in a push
constant range with pname:stageFlags including the bit corresponding to the
shader stage that uses it.
The pipeline layout can: include ranges or portions of ranges that are not
used by a particular pipeline, or for which the variables have been
dead-code eliminated from any of the shaders.

There is a limit on the total number of resources of each type that can: be
included in bindings in all descriptor set layouts in a pipeline layout as
shown in <<descriptorsets-pipelinelayout-limits,Pipeline Layout Resource
Limits>>.
The "`Total Resources Available`" column gives the limit on the number of
each type of resource that can: be included in bindings in all descriptor
sets in the pipeline layout.
Some resource types count against multiple limits.
Additionally, there are limits on the total number of each type of resource
that can: be used in any pipeline stage as described in
<<interfaces-resources-limits,Shader Resource Limits>>.

[[descriptorsets-pipelinelayout-limits]]
.Pipeline Layout Resource Limits
[width="80%",cols="<37,<22",options="header"]
|====
| Total Resources Available | Resource Types
.2+<.^| pname:maxDescriptorSetSamplers
            | sampler           | combined image sampler
.3+<.^| pname:maxDescriptorSetSampledImages
            | sampled image     | combined image sampler | uniform texel buffer
.2+<.^| pname:maxDescriptorSetStorageImages
            | storage image     | storage texel buffer
.2+<.^| pname:maxDescriptorSetUniformBuffers
            | uniform buffer    | uniform buffer dynamic
| pname:maxDescriptorSetUniformBuffersDynamic
            | uniform buffer dynamic
.2+<.^| pname:maxDescriptorSetStorageBuffers
            | storage buffer    | storage buffer dynamic
| pname:maxDescriptorSetStorageBuffersDynamic
            | storage buffer dynamic
| pname:maxDescriptorSetInputAttachments
            | input attachment
|====


// refBegin vkDestroyPipelineLayout Destroy a pipeline layout object

与销毁管线布局，可调用：

include::../api/protos/vkDestroyPipelineLayout.txt[]

  * pname:device 是销毁管线布局的逻辑设备。
  * pname:pipelineLayout 是需要被销毁的管线布局。
  * pname:pAllocator 控制CPU端内存分配，如    <<memory-allocation, Memory Allocation>> 一章所述。

.正确使用
****
  * 若创建pname:pipelineLayout时提供了 sname:VkAllocationCallbacks，那么在此处必须提供兼容的callbacks。
  * 创建pname:pipelineLayout时没有提供 sname:VkAllocationCallbacks，那么 pname:pAllocator 必须: 为 `NULL`
****

include::../validity/protos/vkDestroyPipelineLayout.txt[]


[[descriptorsets-compatibility]]
==== 管线布局兼容性

若两个管线布局被创建时，带有的push constants 区间完全一致，那么它们就被定义为 "`compatible for
<<descriptorsets-push-constants, push constants>>`"。
Two pipeline layouts are defined to be "`compatible for set N`" if they were
created with _identically defined_ descriptor set layouts for sets zero
through N, and if they were created with identical push constant ranges.

When binding a descriptor set (see <<descriptorsets-binding, Descriptor Set
Binding>>) to set number N, if the previously bound descriptor sets for sets
zero through N-1 were all bound using compatible pipeline layouts, then
performing this binding does not disturb any of the lower numbered sets.
If, additionally, the previous bound descriptor set for set N was bound
using a pipeline layout compatible for set N, then the bindings in sets
numbered greater than N are also not disturbed.

Similarly, when binding a pipeline, the pipeline can: correctly access any
previously bound descriptor sets which were bound with compatible pipeline
layouts, as long as all lower numbered sets were also bound with compatible
layouts.

Layout compatibility means that descriptor sets can: be bound to a command
buffer for use by any pipeline created with a compatible pipeline layout,
and without having bound a particular pipeline first.
It also means that descriptor sets can: remain valid across a pipeline
change, and the same resources will be accessible to the newly bound
pipeline.

ifdef::implementation-guide[]
.Implementor's Note
****
A consequence of layout compatibility is that when the implementation
compiles a pipeline layout and assigns hardware units to resources, the
mechanism to assign hardware units for set N should: only be a function of
sets [0..N].
****
endif::implementation-guide[]

[NOTE]
.注意
====
Place the least frequently changing descriptor sets near the start of the
pipeline layout, and place the descriptor sets representing the most
frequently changing resources near the end.
When pipelines are switched, only the descriptor set bindings that have been
invalidated will need to be updated and the remainder of the descriptor set
bindings will remain in place.
====

可以绑定到管线布局的描述符集合的最大数量来自物理硬件的属性
(参考 pname:maxBoundDescriptorSets in <<features-limits, Limits>>).

.API example
[source,c++]
---------------------------------------------------
const VkDescriptorSetLayout layouts[] = { layout1, layout2 };

const VkPushConstantRange ranges[] =
{
    {
        VK_PIPELINE_STAGE_VERTEX_SHADER_BIT,    // stageFlags
        0,                                      // offset
        4                                       // size
    },

    {
        VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT,  // stageFlags
        4,                                      // offset
        4                                       // size
    },
};

const VkPipelineLayoutCreateInfo createInfo =
{
    VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO,  // sType
    NULL,                                           // pNext
    0,                                              // flags
    2,                                              // setLayoutCount
    layouts,                                        // pSetLayouts
    2,                                              // pushConstantRangeCount
    ranges                                          // pPushConstantRanges
};

VkPipelineLayout myPipelineLayout;
myResult = vkCreatePipelineLayout(
    myDevice,
    &createInfo,
    NULL,
    &myPipelineLayout);
---------------------------------------------------


[[descriptorsets-allocation]]
=== 描述符集合的分配

// refBegin VkDescriptorPool Opaque handle to a descriptor pool object

一个 _descriptor pool_ 维护来一个描述符池，描述符集合从这里分配而来。
描述符池需要在外部保持同步，意味着，应用程序不能多线程同时从池中分配、释放描述符集合。

描述符池通过 sname:VkDescriptorPool handle表示:

include::../api/handles/VkDescriptorPool.txt[]

// refEnd VkDescriptorPool

// refBegin vkCreateDescriptorPool Creates a descriptor pool object

与创建描述符池对对象，可调用：

include::../api/protos/vkCreateDescriptorPool.txt[]

  * pname:device 是创建描述符池的逻辑设备。
  * pname:pCreateInfo 是一个指针，指向一个 slink:VkDescriptorPoolCreateInfo 数据结构实例，指定了描述符池对象的状态。
  * pname:pAllocator 控制CPU端内存分配，如    <<memory-allocation, Memory Allocation>> 一章所述。
  * pname:pDescriptorPool 指向一个 sname:VkDescriptorPool handle，它是生成并被返回的描述符池对象。

pname:pAllocator controls host memory allocation as described in the
<<memory-allocation, Memory Allocation>> chapter.

被创建的描述符池通过 pname:pDescriptorPool 返回。

include::../validity/protos/vkCreateDescriptorPool.txt[]

// refBegin VkDescriptorPoolCreateInfo Structure specifying parameters of a newly created descriptor pool

关于池的其他信息通过一个
sname:VkDescriptorPoolCreateInfo 数据结构实例 传入:

include::../api/structs/VkDescriptorPoolCreateInfo.txt[]

  * pname:sType 是数据结构的类型。
  * pname:pNext 是 `NULL` 或者一个指向拓展特定的数据结构的指针。
  * pname:flags 指定了池上支持的某些操作。Bit位如下：
+
--
// refBegin VkDescriptorPoolCreateFlagBits Bitmask specifying certain supported operations on a descriptor pool
include::../api/enums/VkDescriptorPoolCreateFlagBits.txt[]
--
+
If pname:flags includes
ename:VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT, then descriptor
sets can: return their individual allocations to the pool, i.e. all of
fname:vkAllocateDescriptorSets, fname:vkFreeDescriptorSets, and
fname:vkResetDescriptorPool are allowed.
Otherwise, descriptor sets allocated from the pool must: not be individually
freed back to the pool, i.e. only fname:vkAllocateDescriptorSets and
fname:vkResetDescriptorPool are allowed.
+
  * pname:maxSets is the maximum number of descriptor sets that can: be
    allocated from the pool.
  * pname:poolSizeCount is the number of elements in pname:pPoolSizes.
  * pname:pPoolSizes is a pointer to an array of sname:VkDescriptorPoolSize
    structures, each containing a descriptor type and number of descriptors
    of that type to be allocated in the pool.

If multiple sname:VkDescriptorPoolSize structures appear in the
pname:pPoolSizes array then the pool will be created with enough storage for
the total number of descriptors of each type.

描述符池碎片化是可能存在的，且可能导致描述符集合分配失败。
由于碎片化而导致的失败被定义为：即是 所有已经从池中分配出去的描述符集合 加上 要求分配的数量 之和，小于可以从池中创建的总数量。
Vulkan实现提供保证：当某些条件下，碎片化不会导致分配失败，如下：

若描述符池在其被创建之后没有进行过描述符集合释放，或者最近被重置过，那么碎片化不能导致分配失败
(注意，这里只针对创建时没有带有 ename:VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT bit的 描述符池)。
另外，若在池被创建之后或重置之后，从池中分配而来的所有集合使用相同数量的描述符，且要求分配的描述符也使用相同数量的描述，
那么碎皮化不能导致分配失败。

若由于碎片化导致了分配失败，应用程序可以创建另外的描述符池，来继续完成描述符分配。

.正确使用
****
  * pname:maxSets 必须: 大于 `0`
****

include::../validity/structs/VkDescriptorPoolCreateInfo.txt[]

// refBegin VkDescriptorPoolSize Structure specifying descriptor pool size

sname:VkDescriptorPoolSize 类型数据结构定义如下：

include::../api/structs/VkDescriptorPoolSize.txt[]

  * pname:type 是描述符的类型。
  * pname:descriptorCount 是需要分配的类型的描述符的个数。

.正确使用
****
  * pname:descriptorCount 必须: 大于 `0`
****

include::../validity/structs/VkDescriptorPoolSize.txt[]

// refBegin vkDestroyDescriptorPool Destroy a descriptor pool object

欲销毁一个描述符池，可调用：

include::../api/protos/vkDestroyDescriptorPool.txt[]

  * pname:device 是销毁描述符池的逻辑设备。
  * pname:descriptorPool 是需要被销毁的描述符池。
  * pname:pAllocator 控制CPU端内存分配，如 <<memory-allocation, Memory Allocation>> 一章所述。

当一个pool被销毁后，从它分配而来的描述符集合都隐式的变得无效了。
从一个指定的池中分配而来的描述符集合，并不需要在描述符池销毁之前被释放。

.正确使用
****
  * 所有被提交的涉及到pname:descriptorPool （通过任何已分配的描述符集合）的命令 必须已经完成执行。
  * 若创建pname:descriptorPool时提供了 sname:VkAllocationCallbacks，那么在此处必须提供一些兼容的回调函数。
  * 若创建pname:descriptorPool是没有提供 sname:VkAllocationCallbacks ，那么此处的 pname:pAllocator 必须为  `NULL`
****

include::../validity/protos/vkDestroyDescriptorPool.txt[]

// refBegin VkDescriptorSet Opaque handle to a descriptor set object

描述符集合从描述符池中分配而来，使用sname:VkDescriptorSet handle表示:

include::../api/handles/VkDescriptorSet.txt[]

// refEnd VkDescriptorSet

// refBegin vkAllocateDescriptorSets Allocate one or more descriptor sets

欲从描述符池中分配描述符集合，可调用：

include::../api/protos/vkAllocateDescriptorSets.txt[]

  * pname:device 是拥有描述符池的逻辑设备。
  * pname:pAllocateInfo 是一个指针，指向一个    slink:VkDescriptorSetAllocateInfo 实例，描述了分配的参数。
  * pname:pDescriptorSets 是一个指针，指向 sname:VkDescriptorSet类型的数组，保存被生成并返回的描述符集合对象。
    这个数组的最小个数必须是 pname:pAllocateInfo的    pname:descriptorSetCount 成员指定的大小。


被分配的描述符集合通过 pname:pDescriptorSets 返回。

当已分配了一个描述符集合，其初始状态很大可能是未厨师还的，所有的描述符是未定义的。
然而，描述符集合可以被绑定到命令缓冲区，而不会导致任何错误或异常。
被一个绘制或者dispatching命令的管线使用时，每个数组元素必须在绑定并被该命令使用之前，已经被实际填充数据。
没有被管线静态使用的数组元素可以有未初始化的描述符或者  已经被销毁了的资源的描述符，且使用这样的描述符集合绑定
来 执行绘制或者dispatch命令并不会导致未定义行为。
这表示，应用程序不需要使用假数据填充未使用的数组元素。

若应用程序在fragmentation失败了，会使用未指定的错误码来表示 返回了一个不确定的错误。
非ename:VK_ERROR_FRAGMENTED_POOL 的其他任意错误码并不意味着它实际的含义：
应用程序应该假设因为fragmentation 分配失败了，且创建了一个新的描述符池。

ifdef::VK_KHR_maintenance1[]
If the allocation fails due to no more space in the descriptor pool, and not
because of system or device memory exhaustion, then
ename:VK_ERROR_OUT_OF_POOL_MEMORY_KHR must: be returned.

fname:vkAllocateDescriptorSets can: be used to create multiple descriptor
sets.
If the creation of any of those descriptor sets fails, then the
implementation must: destroy all successfully created descriptor set objects
from this command, set all entries of the pname:pDescriptorSets array to
dlink:VK_NULL_HANDLE and return the error.
endif::VK_KHR_maintenance1[]

[NOTE]
.注意
====
Applications should: check for a negative return value when allocating new
descriptor sets, assume that any error effectively means
ename:VK_ERROR_FRAGMENTED_POOL, and try to create a new descriptor pool.
If ename:VK_ERROR_FRAGMENTED_POOL is the actual return value, it adds
certainty to that decision.

The reason for this is that ename:VK_ERROR_FRAGMENTED_POOL was only added in
a later revision of the 1.0 specification, and so drivers may: return other
errors if they were written against earlier revisions.
To ensure full compatibility with earlier patch revisions, these other
errors are allowed.
====

include::../validity/protos/vkAllocateDescriptorSets.txt[]

// refBegin VkDescriptorSetAllocateInfo Structure specifying the allocation parameters for descriptor sets

sname:VkDescriptorSetAllocateInfo 类型数据结构定义如下：

include::../api/structs/VkDescriptorSetAllocateInfo.txt[]

  * pname:sType 是数据结构的类型。
  * pname:pNext 是 `NULL` 或者一个指向拓展特定的数据结构的指针。
  * pname:descriptorPool 是描述符集合从这个pool分配而来的。
  * pname:descriptorSetCount 决定了需要从pool中分配的描述符集合的数量。
  * pname:pSetLayouts 是一个描述符集合布局的数组，每一个数字指定了对应的描述符集合如何被分配。


.正确使用
****
  * pname:descriptorSetCount 不能: 大于集合pname:descriptorPool 中可用于分配的数量
  * pname:descriptorPool 必须: 有足够的剩余量，可分配指定布局的描述符集合。
****

include::../validity/structs/VkDescriptorSetAllocateInfo.txt[]

// refBegin vkFreeDescriptorSets Free one or more descriptor sets

与释放被分配的描述符集合，可调用：

include::../api/protos/vkFreeDescriptorSets.txt[]

  * pname:device 是拥有描述符池的逻辑设备。
  * pname:descriptorPool 是分配描述符集合的描述符池。
  * pname:descriptorSetCount 是 pname:pDescriptorSets 数组中元素的个数。
  * pname:pDescriptorSets 是一个 sname:VkDescriptorSet handle 对象数组。

调用fname:vkFreeDescriptorSets成功后， pname:pDescriptorSets 中所有的描述符集合都是无效的。

.正确使用
****
  * 所有被提交的涉及到pname:pDescriptorSets中任何一个的命令 必须已经完成执行。
  * pname:pDescriptorSets 必须是一个指向 元素个数为
    pname:descriptorSetCount 的sname:VkDescriptorSet类型 数组的指针， 每个元素必须是一个有效的handle，
    或者是 dlink:VK_NULL_HANDLE
  * Each valid handle in pname:pDescriptorSets 中每个有效的handle必须 已经从 pname:descriptorPool分配。
  * pname:descriptorPool 必须在创建时带有
    ename:VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT 标识位
****

include::../validity/protos/vkFreeDescriptorSets.txt[]

// refBegin vkResetDescriptorPool Resets a descriptor pool object

欲把从指定池中分配而来的所有描述符集合返回给该池，而非释放单个描述符集合，可调用：

include::../api/protos/vkResetDescriptorPool.txt[]

  * pname:device 书拥有描述符池的逻辑设备。
  * pname:descriptorPool 是需要被重置的描述符池。
  * pname:flags 被保留。

重置一个描述符池将回收所有之前从之分配出去的描述符集合，回收到描述符集合，且描述符集合被隐式释放。

.正确使用
****
  * All uses of pname:descriptorPool (via any allocated descriptor sets)
    must: have completed execution
****

include::../validity/protos/vkResetDescriptorPool.txt[]


[[descriptorsets-updates]]
=== 描述符集合更新

// refBegin vkUpdateDescriptorSets Update the contents of a descriptor set object

一旦分配好了，描述符集合可以被写入欲复制操作的组合所更新。
欲更新描述符集合，可调用：

include::../api/protos/vkUpdateDescriptorSets.txt[]

  * pname:device 是更新描述符集合的逻辑设备。
  * pname:descriptorWriteCount 是    pname:pDescriptorWrites 数组中元素的个数。
  * pname:pDescriptorWrites 是一个指针，指向一个
    slink:VkWriteDescriptorSet 类型数组，描述了将被写入的描述符集合。
  * pname:descriptorCopyCount 是 pname:pDescriptorCopies 数组中元素个数.
  * pname:pDescriptorCopies 是一个指针，指向一个    slink:VkCopyDescriptorSet 类型数组，描述了将要复制的
	描述符集合。

通过pname:pDescriptorWrites 描述的操作首先被执行，接下来是被 pname:pDescriptorCopies描述的操作。
在每个数组内，操作的执行顺序依它们在数组中出现的顺序。

pname:pDescriptorWrites 数组中每一个元素描述了一个操作，该操作使用数据结构中指定的资源 更新了描述符集合。


pname:pDescriptorCopies 数组中每一个元素是一个
slink:VkCopyDescriptorSet 数据结构，描述了两个集合之间的复制描述符操作。

include::../validity/protos/vkUpdateDescriptorSets.txt[]

// refBegin VkWriteDescriptorSet Structure specifying the parameters of a descriptor set write operation

sname:VkWriteDescriptorSet 类型数据结构定义如下：

include::../api/structs/VkWriteDescriptorSet.txt[]

  * pname:sType 是数据结构的类型。
  * pname:pNext 是 `NULL` 或者一个指向拓展特定的数据结构的指针。
  * pname:dstSet 是需要被更新的目标描述符集合。
  * pname:dstBinding 是该集合内的描述符绑定。
  * pname:dstArrayElement 是该数组的起始元素。
  * pname:descriptorCount 是需要被更新的描述符个数 ( pname:pImageInfo, pname:pBufferInfo, 或者
    pname:pTexelBufferView 的元素个数).
  * pname:descriptorType 是一个 elink:VkDescriptorType，指定了pname:pImageInfo, pname:pBufferInfo, 或者
    pname:pTexelBufferView之中每一个描述符的类型，如下所述。它 必须: 与
    在 pname:dstBinding的pname:dstSet 为 sname:VkDescriptorSetLayoutBinding中指定的类型 相同。
    描述的类型也控制了从哪个数组中取出描述符。
  * pname:pImageInfo 指向一个slink:VkDescriptorImageInfo数组，或者被忽略，如下描述。
  * pname:pBufferInfo 指向一个 slink:VkDescriptorBufferInfo数组，或者被忽略，如下描述。
  * pname:pTexelBufferView 指向一个  slink:VkBufferView handle数组，如 <<resources-buffer-views,Buffer Views>> 小节所述，或者被忽略，如下描述。

按照 sname:VkWriteDescriptorSet 数据结构 的pname:descriptorType 成员所指定的 描述符类型，
只有pname:pImageInfo, pname:pBufferInfo, 或者 pname:pTexelBufferView
成员之一被使用, 如下所描述。

[[descriptorsets-updates-consecutive, consecutive binding updates]]
If the pname:dstBinding has fewer than pname:descriptorCount array elements
remaining starting from pname:dstArrayElement, then the remainder will be
used to update the subsequent binding - pname:dstBinding+1 starting at array
element zero.
If a binding has a pname:descriptorCount of zero, it is skipped.
This behavior applies recursively, with the update affecting consecutive
bindings as needed to update all pname:descriptorCount descriptors.
All consecutive bindings updated via a single sname:VkWriteDescriptorSet
structure, except those with a pname:descriptorCount of zero, must: have
identical pname:descriptorType and pname:stageFlags, and must: all either
use immutable samplers or must: all not use immutable samplers.

.正确使用
****
  * 当 pname:dstSet的描述符集合布局被创建时，pname:dstBinding 必须小于等于 所有slink:VkDescriptorSetLayoutBinding 数据结构的 pname:binding 的最大值
  * pname:dstBinding 必须: 被绑定一个非 0的 pname:descriptorCount
  * pname:descriptorType 必须 与pname:dstSet内的  pname:dstBinding 的类型相匹配
  * pname:dstArrayElement 与 pname:descriptorCount 之和必须 小于等于 pname:dstBinding指定的描述符集合绑定中数组元素的个数，
    如<<descriptorsets-updates-consecutive>>所描述
  * 若 pname:descriptorType 是 ename:VK_DESCRIPTOR_TYPE_SAMPLER,
    ename:VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER,
    ename:VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE,
    ename:VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, 或
    ename:VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT, pname:pImageInfo 必须是一个指针，
    指向一个 个数为pname:descriptorCount 的有效
    sname:VkDescriptorImageInfo 数据结构数组
  * 若 pname:descriptorType 是 ename:VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER
    或 ename:VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER, pname:pTexelBufferView
    必须是一个指针，指向 一个元素个数为pname:descriptorCount的有效
    sname:VkBufferView handle的数组
  * 若 pname:descriptorType 是 ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER,
    ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER,
    ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC, 或
    ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC, pname:pBufferInfo 必须是一个指针，指向一个元素个数为
    pname:descriptorCount 的有效
    sname:VkDescriptorBufferInfo 数据结构的数组
  * 若 pname:descriptorType 是 ename:VK_DESCRIPTOR_TYPE_SAMPLER 或
    ename:VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, 且 pname:dstSet 被分配时没有带有
    含有为pname:descriptorType的pname:dstBinding准备的不可变采样器 的布局， pname:pImageInfo 中任何给定元素的 pname:sampler 成员必须是一个
    有效的 sname:VkSampler对象
  * 若 pname:descriptorType 是
    ename:VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER,
    ename:VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE,
    ename:VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, 或
    ename:VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT,  pname:pImageInfo的任何给定元素的 pname:imageView 和
    pname:imageLayout 成员 必须是一个有效的
    sname:VkImageView 或 elink:VkImageLayout
  * 若 pname:descriptorType 是 ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER 或
    ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC, pname:pBufferInfo的任何给定元素的 pname:offset 成员必须
    是一个可变的 sname:VkPhysicalDeviceLimits::pname:minUniformBufferOffsetAlignment
  * 若 pname:descriptorType 是 ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER 或
    ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC,  pname:pBufferInfo 的任何给定元素的 pname:offset 成员必须是
    sname:VkPhysicalDeviceLimits::pname:minStorageBufferOffsetAlignment的倍数
  * 若 pname:descriptorType 是 ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER,
    ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC,
    ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER, 或
    ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC, 非稀疏的  pname:pBufferInfo 的任何给定元素的 pname:buffer 成员必须是已被
    完全且连续绑定到单个   sname:VkDeviceMemory对象。
  * 若 pname:descriptorType 是 ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER 或
    ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC, pname:pBufferInfo的任何给定元素的 pname:buffer 成员必须
    在创建是带有 ename:VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT 标识位
  * 若 pname:descriptorType 是 ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER 或
    ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC, pname:pBufferInfo 的任何给定元素的 pname:buffer 成员必须
    在创建时带有ename:VK_BUFFER_USAGE_STORAGE_BUFFER_BIT 标识位
  * 若 pname:descriptorType 是 ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER 或
    ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC, pname:pBufferInfo中任何给定元素的 pname:range 成员，或者区间为ename:VK_WHOLE_SIZE的有效区间，
    必须小于等于
    sname:VkPhysicalDeviceLimits::pname:maxUniformBufferRange
  * 若 pname:descriptorType 是 ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER 或
    ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC, pname:pBufferInfo中任何给定元素的 pname:range 成员，或者区间为ename:VK_WHOLE_SIZE的有效区间，
    必须小于等于
    sname:VkPhysicalDeviceLimits::pname:maxStorageBufferRange
  * 若 pname:descriptorType 是
    ename:VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER, sname:VkBuffer （pname:pTexelBufferView中任何给定元素从其创建而来）
    必须在创建时带有  ename:VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT 标识位
  * 若 pname:descriptorType 是
    ename:VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER,   sname:VkBuffer （pname:pTexelBufferView 中任何给定元素都从其创建而来）
    必须在创建时带有
     ename:VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT 标识位
  * 若 pname:descriptorType 是 ename:VK_DESCRIPTOR_TYPE_STORAGE_IMAGE 或
    ename:VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT, pname:pImageInfo 中任何给定元素的 pname:imageView 成员必须在创建时
    其ID是调和的。
****

include::../validity/structs/VkWriteDescriptorSet.txt[]

// refBegin VkDescriptorType Specifies the type of a descriptor in a descriptor set

The type of descriptors in a descriptor set is specified by
slink:VkWriteDescriptorSet::pname:descriptorType, which must: be one of the
values:

include::../api/enums/VkDescriptorType.txt[]

若 pname:descriptorType 是 ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER,
ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER,
ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC, 或者
ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC类型,
slink:VkDescriptorBufferInfo 数据结构的 slink:VkWriteDescriptorSet::pname:pBufferInfo 数组的元素将会被用于更新描述符
，其他的数组将被忽略。

若pname:descriptorType 是 ename:VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER 或者
ename:VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER类型，
slink:VkWriteDescriptorSet::pname:pTexelBufferView 数组将被用于更新描述符，其他的数组将被忽略。

若 pname:descriptorType 是 ename:VK_DESCRIPTOR_TYPE_SAMPLER,
ename:VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER,
ename:VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE,
ename:VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, 或
ename:VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT类型，
slink:VkDescriptorImageInfo 数据结构的 slink:VkWriteDescriptorSet::pname:pImageInfo 数组的元素将被用于
更新描述符，其他的数组将被忽略。

// refEnd VkDescriptorType

// refBegin VkDescriptorBufferInfo Structure specifying descriptor buffer info

sname:VkDescriptorBufferInfo 类型数据结构定义如下：

include::../api/structs/VkDescriptorBufferInfo.txt[]

  * pname:buffer 是缓冲区资源。、
  * pname:offset 是 从pname:buffer的起始位置的偏移子节量。
    通过这个描述符访问缓冲区内存，会使用相对于起始偏移的地址。
  * pname:range 是用于此次描述符更新的字节大小，或者为ename:VK_WHOLE_SIZE时，将使用  pname:offset 到缓冲区结束的区间。
+
--
[NOTE]
.注意
====
When using ename:VK_WHOLE_SIZE, the effective range must: not be larger than
the maximum range for the descriptor type
(<<features-limits-maxUniformBufferRange, maxUniformBufferRange>> or
<<features-limits-maxStorageBufferRange, maxStorageBufferRange>>).
This means that ename:VK_WHOLE_SIZE is not typically useful in the common
case where uniform buffer descriptors are suballocated from a buffer that is
much larger than pname:maxUniformBufferRange.
====
--
+
For ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC and
ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC descriptor types,
pname:offset is the base offset from which the dynamic offset is applied and
pname:range is the static size used for all dynamic offsets.

.正确使用
****
  * pname:offset 必须: 小于 pname:buffer
  * 若 pname:range 不等于 ename:VK_WHOLE_SIZE， pname:range 必须: 大于 `0`
  * 若 pname:range 不等于 ename:VK_WHOLE_SIZE，pname:range 必须: 小于等于  pname:buffer 减去 pname:offset之差。
****

include::../validity/structs/VkDescriptorBufferInfo.txt[]

// refBegin VkDescriptorImageInfo Structure specifying descriptor image info

sname:VkDescriptorImageInfo 类型数据结构定义如下：

include::../api/structs/VkDescriptorImageInfo.txt[]

  * pname:sampler 是一个采样器handle， 若正在被更新的绑定并不使用 不可变的采样器，在
    ename:VK_DESCRIPTOR_TYPE_SAMPLER 和 ename:VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER 类型的描述符更新中被使用。
  * pname:imageView 是一个图像视图handle, 在ename:VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE，
    ename:VK_DESCRIPTOR_TYPE_STORAGE_IMAGE，
    ename:VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, 和
    ename:VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT 类型的描述符更新中使用。
  * pname:imageLayout 是描述符被访问时图像所处于的布局。
    pname:imageLayout 在
    ename:VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE,
    ename:VK_DESCRIPTOR_TYPE_STORAGE_IMAGE,
    ename:VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, 和
    ename:VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT 类型的描述符更新中被使用。

一次更新中没有使用的 sname:VkDescriptorImageInfo的成员将被忽略。(如上所述) .

include::../validity/structs/VkDescriptorImageInfo.txt[]

// refBegin VkCopyDescriptorSet Structure specifying a copy descriptor set operation

sname:VkCopyDescriptorSet 类型数据结构定义如下：

include::../api/structs/VkCopyDescriptorSet.txt[]

  * pname:sType 是数据结构的类型。
  * pname:pNext 是 `NULL` 或者一个指向拓展特定的数据结构的指针。
  * pname:srcSet, pname:srcBinding, 和 pname:srcArrayElement 各自是源集合、绑定与数组元素。
  * pname:dstSet, pname:dstBinding, 和 pname:dstArrayElement 各自是目标集合、绑定与数组元素。
  * pname:descriptorCount 是需要从源复制到目标的描述符个数。
    若 pname:descriptorCount 大于源或者目标绑定中的剩余的数组元素数量，它们影响连续的绑定，类似于上面 slink:VkWriteDescriptorSet的方式。

.正确使用
****
  * pname:srcBinding 必须: 是pname:srcSet之内的一个有效的绑定
  * pname:srcArrayElement 和 pname:descriptorCount之和 必须: 小于等于pname:srcBinding指定的、应用程序中所有连续的绑定指定的描述符集合绑定中数组元素个数，
    如<<descriptorsets-updates-consecutive>>小节所描述。
  * pname:dstBinding 必须: pname:dstSet之内的一个有效绑定
  * pname:dstArrayElement 和 pname:descriptorCount之和 必须: 小于等于pname:dstBinding指定的，应用程序中所有连续的绑定指定的 描述符集合绑定
    的数组元素个数。如<<descriptorsets-updates-consecutive>>一节所描述。
  * 若 pname:srcSet 等于 pname:dstSet, 那么描述符的目标与源区间不能重叠，区间可能包括<<descriptorsets-updates-consecutive>>
    所描述的连续绑定的任何数组元素。

****

include::../validity/structs/VkCopyDescriptorSet.txt[]


[[descriptorsets-binding]]
=== 描述符集合绑定

// refBegin vkCmdBindDescriptorSets Binds descriptor sets to a command buffer

欲绑定一个或者多个描述符集合到命令缓冲区，可调用：

include::../api/protos/vkCmdBindDescriptorSets.txt[]

  * pname:commandBuffer 描述符集合将被绑定到的命令缓冲区。
  * pname:pipelineBindPoint 是一个 elink:VkPipelineBindPoint，表明描述符被图形还是计算管线所使用。
    对于每一个图形和计算管线，都有独立的绑定点，所以绑定一个并不会影响其他的。
  * pname:layout 是一个 sname:VkPipelineLayout 对象，被用于规划该绑定。
  * pname:firstSet 是需要被绑定的第一个描述符集合的数量。
  * pname:descriptorSetCount 是 pname:pDescriptorSets 数组的元素数量。
  * pname:pDescriptorSets 是一个 sname:VkDescriptorSet handle 数组，这些对象描述了将被写入的描述符集合。
  * pname:dynamicOffsetCount 是 pname:pDynamicOffsets 数组中动态偏移的大小。
  * pname:pDynamicOffsets 是一个指针，指向一个元素类型为code:uint32_t 的数组，元素值指定了动态偏移。

fname:vkCmdBindDescriptorSets causes the sets numbered [pname:firstSet..
pname:firstSet+pname:descriptorSetCount-1] to use the bindings stored in
pname:pDescriptorSets[0..pname:descriptorSetCount-1] for subsequent
rendering commands (either compute or graphics, according to the
pname:pipelineBindPoint).
Any bindings that were previously applied via these sets are no longer
valid.

Once bound, a descriptor set affects rendering of subsequent graphics or
compute commands in the command buffer until a different set is bound to the
same set number, or else until the set is disturbed as described in
<<descriptorsets-compatibility, Pipeline Layout Compatibility>>.

A compatible descriptor set must: be bound for all set numbers that any
shaders in a pipeline access, at the time that a draw or dispatch command is
recorded to execute using that pipeline.
However, if none of the shaders in a pipeline statically use any bindings
with a particular set number, then no descriptor set need be bound for that
set number, even if the pipeline layout includes a non-trivial descriptor
set layout for that set number.

If any of the sets being bound include dynamic uniform or storage buffers,
then pname:pDynamicOffsets includes one element for each array element in
each dynamic descriptor type binding in each set.
Values are taken from pname:pDynamicOffsets in an order such that all
entries for set N come before set N+1; within a set, entries are ordered by
the binding numbers in the descriptor set layouts; and within a binding
array, elements are in order.
pname:dynamicOffsetCount must: equal the total number of dynamic descriptors
in the sets being bound.

The effective offset used for dynamic uniform and storage buffer bindings is
the sum of the relative offset taken from pname:pDynamicOffsets, and the
base address of the buffer plus base offset in the descriptor set.
The length of the dynamic uniform and storage buffer bindings is the buffer
range as specified in the descriptor set.

Each of the pname:pDescriptorSets must: be compatible with the pipeline
layout specified by pname:layout.
The layout used to program the bindings must: also be compatible with the
pipeline used in subsequent graphics or compute commands, as defined in the
<<descriptorsets-compatibility, Pipeline Layout Compatibility>> section.

The descriptor set contents bound by a call to fname:vkCmdBindDescriptorSets
may: be consumed during host execution of the command, or during shader
execution of the resulting draws, or any time in between.
Thus, the contents must: not be altered (overwritten by an update command,
or freed) between when the command is recorded and when the command
completes executing on the queue.
The contents of pname:pDynamicOffsets are consumed immediately during
execution of fname:vkCmdBindDescriptorSets.
Once all pending uses have completed, it is legal to update and reuse a
descriptor set.

.正确使用
****
  * Any given element of pname:pDescriptorSets must: have been allocated
    with a sname:VkDescriptorSetLayout that matches (is the same as, or
    identically defined as) the sname:VkDescriptorSetLayout at set _n_ in
    pname:layout, where _n_ is the sum of pname:firstSet and the index into
    pname:pDescriptorSets
  * pname:dynamicOffsetCount must: be equal to the total number of dynamic
    descriptors in pname:pDescriptorSets
  * The sum of pname:firstSet and pname:descriptorSetCount must: be less
    than or equal to sname:VkPipelineLayoutCreateInfo::pname:setLayoutCount
    provided when pname:layout was created
  * pname:pipelineBindPoint must: be supported by the pname:commandBuffer's
    parent sname:VkCommandPool's queue family
  * Any given element of pname:pDynamicOffsets must: satisfy the required
    alignment for the corresponding descriptor binding's descriptor type
****

include::../validity/protos/vkCmdBindDescriptorSets.txt[]


=== Push Constant Updates

[[descriptorsets-push-constants]]

As described above in section <<descriptorsets-pipelinelayout, Pipeline
Layouts>>, the pipeline layout defines shader push constants which are
updated via Vulkan commands rather than via writes to memory or copy
commands.

[NOTE]
.注意
====
Push constants represent a high speed path to modify constant data in
pipelines that is expected to outperform memory-backed resource updates.
====

The values of push constants are undefined at the start of a command buffer.

// refBegin vkCmdPushConstants Update the values of push constants

欲更新push constants，可调用：

include::../api/protos/vkCmdPushConstants.txt[]

  * pname:commandBuffer is the command buffer in which the push constant
    update will be recorded.
  * pname:layout is the pipeline layout used to program the push constant
    updates.
  * pname:stageFlags is a bitmask of elink:VkShaderStageFlagBits specifying
    the shader stages that will use the push constants in the updated range.
  * pname:offset is the start offset of the push constant range to update,
    in units of bytes.
  * pname:size is the size of the push constant range to update, in units of
    bytes.
  * pname:pValues is an array of pname:size bytes containing the new push
    constant values.

.正确使用
****
  * pname:stageFlags 必须: 与
    pname:layout 中用到的着色器阶段 在pname:offset 和 pname:size 指定的区间上完全一致。
  * pname:offset 必须: 是 `4`的倍数
  * pname:size 必须: 是 `4`的倍数
  * pname:offset 必须: 小于
    sname:VkPhysicalDeviceLimits::pname:maxPushConstantsSize
  * pname:size 必须: 小于等于
    sname:VkPhysicalDeviceLimits::pname:maxPushConstantsSize 减去
    pname:offset之差
****

include::../validity/protos/vkCmdPushConstants.txt[]
