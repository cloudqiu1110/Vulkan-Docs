// Copyright (c) 2015-2017 The Khronos Group Inc.
// Copyright notice at https://www.khronos.org/registry/speccopyright.html

[[resources]]
= 资源的创建

Vulkan支持两种主要的资源类型： _缓冲区_ 和 _图像_。
资源是带有关联格式、维度信息的内存视图。
缓冲区是未格式化字节数组，图像包含格式化信息，可以是多维的，也能有关联的元数据。


[[resources-buffers]]
== 缓冲区

// refBegin VkBuffer Opaque handle to a buffer object

缓冲区表示线性数组数据，通过描述符集合或特定命令或直接指定它们作为特定命令的参数
绑定到图形或者计算管线被用于各种目的。

缓冲区由 sname:VkBuffer 类型handle表示：

include::../api/handles/VkBuffer.txt[]

// refEnd VkBuffer

// refBegin vkCreateBuffer Create a new buffer object

可调用如下命令来创建缓冲区：

include::../api/protos/vkCreateBuffer.txt[]

  * pname:device 是创建缓冲区对象的逻辑设备。
  * pname:pCreateInfo 是一个指向 sname:VkBufferCreateInfo 类型实例的指针，包含了影响创建缓冲区的参数。
  * pname:pAllocator 控制主机端内存分配，如 <<memory-allocation, 内存分配>>章所讲。
  * pname:pBuffer 指向一个 sname:VkBuffer handle，生成的缓冲区对象以此被返回。

.Valid Usage
****
  * 若 pname:pCreateInfo 的成员pname:flags 包含 ename:VK_BUFFER_CREATE_SPARSE_BINDING_BIT，创建这个 sname:VkBuffer
	不能导致在设备上当前有效的稀疏资源总体需求的稀疏内存  超过
    sname:VkPhysicalDeviceLimits::pname:sparseAddressSpaceSize
****

include::../validity/protos/vkCreateBuffer.txt[]

// refBegin VkBufferCreateInfo Structure specifying the parameters of a newly created buffer object

sname:VkBufferCreateInfo 数据结构定义如下：

include::../api/structs/VkBufferCreateInfo.txt[]

  * pname:sType 是这个数据结构的类型。
  * pname:pNext 是 `NULL` 或者一个  extension-specific 数据结构的指针。
  * pname:flags 是一个位掩码，描述了缓冲区的附加参数。参看下方受支持的 elink:VkBufferCreateFlagBits 描述。
  * pname:size 是将被创建的缓冲区的字节数。
  * pname:usage  是一个 bitmask，描述了缓冲区被允许的使用方式。
    参考 如下 elink:VkBufferUsageFlagBits 受支持的bit。
  * pname:sharingMode 是缓冲区被多个队列族访问时的共享模式，参考
    <<resources-sharing,Resource Sharing>> 小节中 elink:VkSharingMode 给出的受支持的值。
  * pname:queueFamilyIndexCount 是 pname:pQueueFamilyIndices 数组中的元素个数。
  * pname:pQueueFamilyIndices 是一些队列族，它们将访问这个缓冲区 (ignored if pname:sharingMode is not
    ename:VK_SHARING_MODE_CONCURRENT)。

pname:usage 中可以设置的bit如下：

// refBegin VkBufferUsageFlagBits Bitmask specifying allowed usage of a buffer
include::../api/enums/VkBufferUsageFlagBits.txt[]

  * ename:VK_BUFFER_USAGE_TRANSFER_SRC_BIT 表明缓冲区可以被用作  _transfer command_ 的源
   (参看 <<synchronization-pipeline-stages-transfer,
    ename:VK_PIPELINE_STAGE_TRANSFER_BIT>>的定义).
  * ename:VK_BUFFER_USAGE_TRANSFER_DST_BIT 表明缓冲区可以被用作  转移名利的目标。
  * ename:VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT 表明缓冲区可以被用于创建一个 sname:VkBufferView，其适于
    占用一个 ename:VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER类型的
    sname:VkDescriptorSet槽。
  * ename:VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT  表明缓冲区可以被用于创建一个 sname:VkBufferView，其适于
    占用一个ename:VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER类型的  sname:VkDescriptorSet槽。
  * ename:VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT 表明缓冲区可以被用在一个 sname:VkDescriptorBufferInfo中 ，其适于占用一个
    类型为    ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER 或者
    ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC的  sname:VkDescriptorSet 槽 。
  * ename:VK_BUFFER_USAGE_STORAGE_BUFFER_BIT 表明缓冲区可以被用于sname:VkDescriptorBufferInfo中，其适于占用一个类型为
    ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER 或者
    ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC sname:VkDescriptorSet  槽。
  * ename:VK_BUFFER_USAGE_INDEX_BUFFER_BIT 表明此缓冲区适于被用作参数传递给
    fname:vkCmdBindIndexBuffer.
  * ename:VK_BUFFER_USAGE_VERTEX_BUFFER_BIT 表明此缓冲区适于被当作 pname:pBuffers 数组的一个元素 传递给
    fname:vkCmdBindVertexBuffers.
  * ename:VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT 表明此缓冲区适于被当作 pname:buffer 参数被传递给
    fname:vkCmdDrawIndirect, fname:vkCmdDrawIndexedIndirect, 或者
    fname:vkCmdDispatchIndirect.
ifdef::VK_NVX_device_generated_commands[]
    It is也 suitable for passing as the pname:buffer member of
    sname:VkIndirectCommandsTokenNVX,或 pname:sequencesCountBuffer或
    pname:sequencesIndexBuffer member of sname:VkCmdProcessCommandsInfoNVX
endif::VK_NVX_device_generated_commands[]

任何bit的组合 可以: 指定 pname:usage，但是至少其中一个必须被设置用于创建一个有效的缓冲区。

 pname:flags可以被设置的bit如下：

// refBegin VkBufferCreateFlagBits Bitmask specifying additional parameters of a buffer
include::../api/enums/VkBufferCreateFlagBits.txt[]

这些bit的意义如下：

  * ename:VK_BUFFER_CREATE_SPARSE_BINDING_BIT 表示缓冲区将使用稀疏内存绑定来实现。
  * ename:VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT 表示缓冲区可以部分使用稀疏内存绑定实现。使用此flag创建的缓冲区也可以通过
     ename:VK_BUFFER_CREATE_SPARSE_BINDING_BIT flag来创建。
  * ename:VK_BUFFER_CREATE_SPARSE_ALIASED_BIT 表示缓冲区将使用稀疏内存绑定来实现，内存区间可能也同时存储其他缓冲区的内容
     或者同一个缓冲区的其他部分。使用此flag创建的缓冲区也可以使用 ename:VK_BUFFER_CREATE_SPARSE_BINDING_BIT flag来创建。

参看 <<sparsememory-sparseresourcefeatures,Sparse Resource Features>> 和 <<features-features,Physical Device Features>> 来
获取设备支持的稀疏内存特性的其他细节。

.Valid Usage
****
  * pname:size 必须: 比 `0` 要大
  * 若 pname:sharingMode 是 ename:VK_SHARING_MODE_CONCURRENT，
    pname:pQueueFamilyIndices 必须: 是一个指针，指向一个类型为basetype:uint32_t 的 pname:queueFamilyIndexCount  值。
  * 若 pname:sharingMode 是 ename:VK_SHARING_MODE_CONCURRENT，
    pname:queueFamilyIndexCount 必须: 大于`1`
  * 若<<features-features-sparseBinding,sparse bindings>> 特征没有被启用，pname:flags 不能: 包含
    ename:VK_BUFFER_CREATE_SPARSE_BINDING_BIT
  * 若 <<features-features-sparseResidencyBuffer,sparse buffer
    residency>> 特征没有被启用， pname:flags 不能: 包含
    ename:VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT
  * 若 <<features-features-sparseResidencyAliased,sparse aliased
    residency>> 特征没有被启用，pname:flags 不能: 包含
    ename:VK_BUFFER_CREATE_SPARSE_ALIASED_BIT
  * 若 pname:flags 包含 ename:VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT 或者
    ename:VK_BUFFER_CREATE_SPARSE_ALIASED_BIT，它 必须: 也包含 ename:VK_BUFFER_CREATE_SPARSE_BINDING_BIT
****

include::../validity/structs/VkBufferCreateInfo.txt[]

ifdef::VK_NV_dedicated_allocation[]

// refBegin VkDedicatedAllocationBufferCreateInfoNV Specify that a buffer is bound to a dedicated memory resource

若pname:pNext 列表包含一个sname:VkDedicatedAllocationBufferCreateInfoNV 数据结构，那么该数据结构包含一个使用控制开关，
控制缓冲区是否将有专用的内存绑定给它。

sname:VkDedicatedAllocationBufferCreateInfoNV 数据结构定义如下：

include::../api/structs/VkDedicatedAllocationBufferCreateInfoNV.txt[]

  * pname:sType 是这个数据结构的类型。
  * pname:pNext 是 `NULL` 或者一个指向 拓展特定的数据结构的指针。
  * pname:dedicatedAllocation 表示缓冲区是否将有专门分配的内存绑定到它。

.Valid Usage
****
  * 若 pname:dedicatedAllocation 为 ename:VK_TRUE，
    sname:VkBufferCreateInfo::pname:flags 不能: 包含
    ename:VK_BUFFER_CREATE_SPARSE_BINDING_BIT,
    ename:VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT, 或者
    ename:VK_BUFFER_CREATE_SPARSE_ALIASED_BIT
****

include::../validity/structs/VkDedicatedAllocationBufferCreateInfoNV.txt[]

endif::VK_NV_dedicated_allocation[]

// refBegin vkDestroyBuffer Destroy a buffer object

可调用下面的命令来销毁缓冲区：

include::../api/protos/vkDestroyBuffer.txt[]

  * pname:device 是销毁缓冲区的逻辑设备。
  * pname:buffer 是需要被销毁的缓冲区。
  * pname:pAllocator 控制CPU端内存分配，如 <<memory-allocation, 内存分配 >> 一章详述。

.Valid Usage
****
  * 所有涉及到 pname:buffer的被提交的命令，要么直接，要么通过 sname:VkBufferView，必须: 已经完成了执行。
  * 若创建pname:buffer 时，提供了 sname:VkAllocationCallbacks，那么此处必须提供兼容的 callbacks 。
  * 若创建pname:buffer 时， 没有提供 sname:VkAllocationCallbacks，那么 pname:pAllocator 必须: 为 `NULL`
****

include::../validity/protos/vkDestroyBuffer.txt[]


[[resources-buffer-views]]
== 缓冲区视图

// refBegin VkBufferView Opaque handle to a buffer view object

一个 _缓冲区视图_ 代表 连续范围的一个缓冲区和用来解释数据的特定格式。
缓冲区视图被用来让着色器能访问按照某种格式解释的缓冲区内容。
为了创建一个有效的缓冲区视图，缓冲区必须已经被创建好了，且带有下面的至少一个使用方式标志位：

  * ename:VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT
  * ename:VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT

缓冲区视图通过 sname:VkBufferView 类型handle表示：

include::../api/handles/VkBufferView.txt[]

// refEnd VkBufferView

// refBegin vkCreateBufferView Create a new buffer view object

可调用下列命令来创建缓冲区视图：

include::../api/protos/vkCreateBufferView.txt[]

  * pname:device 是创建给缓冲区视图的逻辑设备。
  * pname:pCreateInfo 是一个指向 sname:VkBufferViewCreateInfo类型实例的指针，包含用来创建缓冲区对象的参数。
  * pname:pAllocator 控制CPU端内存分配，如 <<memory-allocation, 内存分配 >> 一章详述。
  * pname:pView 指向一个 sname:VkBufferView handle，它就是生成并被返回的缓冲区视图对象。

include::../validity/protos/vkCreateBufferView.txt[]

// refBegin VkBufferViewCreateInfo Structure specifying parameters of a newly created buffer view

sname:VkBufferViewCreateInfo 类型定义如下：

include::../api/structs/VkBufferViewCreateInfo.txt[]

  * pname:sType 是数据结构的类型。
  * pname:pNext 是 `NULL` 或者一个指向 拓展特定的数据结构的指针。
  * pname:flags 被保留使用。
  * pname:buffer 是视图创建所在的 sname:VkBuffer。
  * pname:format 是一个 elink:VkFormat，描述了缓冲区中数据元素的格式。
  * pname:offset 是一个偏移值，字节单位，从缓冲区的基础地址开始。着色器中访问缓冲区视图的地址都是对于起始偏移值的相对值。
  * pname:range 是缓冲区视图的字节大小。
	若 pname:range 等于 ename:VK_WHOLE_SIZE, 从  pname:offset 开始到缓冲区结束的区间就被使用。
    若 ename:VK_WHOLE_SIZE 被使用，且缓冲区剩余的大小并不是 pname:format格式的元素的大小的倍数，
	那么就会使用最接近的较小的倍数。

.Valid Usage
****
  * pname:offset 必须: 小于 pname:buffer的大小
  * pname:offset 必须: 是 sname:VkPhysicalDeviceLimits::pname:minTexelBufferOffsetAlignment的倍数。
  * 若 pname:range 不等于 ename:VK_WHOLE_SIZE:
  ** pname:range 必须: 大于 `0`
  ** pname:range 必须: 是  pname:format格式元素大小的整数倍。
  ** pname:range 除以 pname:format格式元素的大小， 必须小于等于
     sname:VkPhysicalDeviceLimits::pname:maxTexelBufferElements
  **  pname:offset 与 pname:range 之和，必须: 小于等于 pname:buffer的大小
  * pname:buffer 必须: 在被创建时 pname:usage 值包含至少一个  ename:VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT 或者
    ename:VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT
  * 若创建 pname:buffer 时 pname:usage 包含
    ename:VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT， pname:format 必须: 被统一纹素缓冲区所支持， 如被
    ename:VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT flag所指定，该flag在
    fname:vkGetPhysicalDeviceFormatProperties返回的sname:VkFormatProperties::pname:bufferFeatures中。
  * 若创建 pname:buffer时，pname:usage 包含
    ename:VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT， pname:format 必须: 受统一纹素缓冲区所支持，如被
    ename:VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT flag 所指定，该flag在
     fname:vkGetPhysicalDeviceFormatProperties返回的sname:VkFormatProperties::pname:bufferFeatures 中。
  * 若 pname:buffer 是非稀疏的，那么它  必须: 被完全且连续的绑定到单个sname:VkDeviceMemory 对象。
****

include::../validity/structs/VkBufferViewCreateInfo.txt[]

// refBegin vkDestroyBufferView Destroy a buffer view object

可调用如下函数以销毁缓冲区视图：

include::../api/protos/vkDestroyBufferView.txt[]

  * pname:device 是销毁缓冲区视图的逻辑设备。
  * pname:bufferView 需要被销毁的缓冲区视图。
  * pname:pAllocator 控制CPU端内存分配，如 <<memory-allocation, 内存分配 >> 一章详述。

.Valid Usage
****
  * 所有涉及到name:bufferView的被提交的命令，必须: 已经完成执行。
  * 若创建pname:bufferView 时，提供了 sname:VkAllocationCallbacks，那么此处必须提供兼容的 callbacks 。
  * 若创建pname:bufferView 时，没有提供 sname:VkAllocationCallbacks，那么 pname:pAllocator 必须: 为 `NULL`。
****

include::../validity/protos/vkDestroyBufferView.txt[]


[[resources-images]]
== 图像

// refBegin VkImage Opaque handle to a image object

图像表示多维（最多3维）的数组数据，可用于各种目的（比如：附件，纹理），通过描述符集合把它们绑定到一个图形或者计算管线，
或者直接当作参数直接传递个某些命令。

图像通过sname:VkImage类型的handle表示：

include::../api/handles/VkImage.txt[]

// refEnd VkImage

// refBegin vkCreateImage Create a new image object

可调用下列命令来创建图像：

include::../api/protos/vkCreateImage.txt[]

  * pname:device 是创建图像的逻辑设备。
  * pname:pCreateInfo 是一个指针，指向一个 sname:VkImageCreateInfo 数据结构实例，它包含了创建图像所需的信息。
  * pname:pAllocator 控制CPU端内存分配，如 <<memory-allocation, 内存分配 >> 一章详述。
  * pname:pImage 指向已创建并返回的 sname:VkImage handle。

.Valid Usage
****
  * 若 pname:pCreateInfo的成员pname:flags 包含
    ename:VK_IMAGE_CREATE_SPARSE_BINDING_BIT，创建这个sname:VkImage 不能导致当前有效稀疏资源
	在总体需求的稀疏内存超过 sname:VkPhysicalDeviceLimits::pname:sparseAddressSpaceSize
****

include::../validity/protos/vkCreateImage.txt[]

// refBegin VkImageCreateInfo Structure specifying the parameters of a newly created image object

sname:VkImageCreateInfo 类型数据结构定义如下：

include::../api/structs/VkImageCreateInfo.txt[]

  * pname:sType 是数据结构的类型。
  * pname:pNext 是 `NULL` 或者一个指向 拓展特定的数据结构的指针。
  * pname:flags 是一个位掩码，描述了图像的附加参数。参考 如下elink:VkImageCreateFlagBits 关于受支持的bit描述。
  * pname:imageType 是一个 elink:VkImageType，指定了图像的基础维度，如下所描述。数组纹理的层次作为图像类别时并不能算作维度
  * pname:format  是一个 elink:VkFormat ，描述了数据元素的格式与类型，数据包含在图像中。
  * pname:extent 是一个slink:VkExtent3D，描述了基础层次中每一个维度的元素的个数。
  * pname:mipLevels 描述了图向下采样的细节层次的个数。
  * pname:arrayLayers 是图像中的层数。
  * pname:samples 是图像中sub-data 元素采样的个数，其在elink:VkSampleCountFlagBits 中被定义。
    参考<<primsrast-multisampling,Multisampling>>。
  * pname:tiling是一个 elink:VkImageTiling，指定了内存中数据元素的tiling组织方式，如下所描述。
  * pname:usage 是一个 bitmask，描述图像的目标使用方式。参考如下的 elink:VkImageUsageFlagBits 支持的bit。
  * pname:sharingMode 是当多个队列族的访问时图像的共享模式， 且 必须: 是下一节的 <<resources-sharing,Resource
    Sharing>> 的elink:VkSharingMode 描述的值之一。
  * pname:queueFamilyIndexCount 是    pname:pQueueFamilyIndices 数组元素的个数。
  * pname:pQueueFamilyIndices 是一个队列族的列表，该队列族将访问此图像 (ignored if pname:sharingMode is not
    ename:VK_SHARING_MODE_CONCURRENT)。
  * pname:initialLayout 选择  此图像的所有图像子资源的  初始 elink:VkImageLayout 状态。
    参看 <<resources-image-layouts,Image Layouts>>。
    pname:initialLayout 必须: 是 ename:VK_IMAGE_LAYOUT_UNDEFINED 或者
    ename:VK_IMAGE_LAYOUT_PREINITIALIZED。

使用pname:tiling值为ename:VK_IMAGE_TILING_LINEAR 创建的图像，比使用pname:tiling值为ename:VK_IMAGE_TILING_OPTIMAL创建的图像由更多的限制。
使用 ename:VK_IMAGE_TILING_LINEAR 创建的图像可能不被支持，除非其他参数满足如下限制：


  * pname:imageType 是 ename:VK_IMAGE_TYPE_2D
  * pname:format 不是 depth/stencil 格式
  * pname:mipLevels 是 1
  * pname:arrayLayers 是 1
  * pname:samples 是 ename:VK_SAMPLE_COUNT_1_BIT
  * pname:usage 只包含 ename:VK_IMAGE_USAGE_TRANSFER_SRC_BIT 和/或    ename:VK_IMAGE_USAGE_TRANSFER_DST_BIT

除了上面表格所列，Vulkan实现可能支持附加的限制条件和功能。

对于给定的 pname:format, pname:type, pname:tiling, pname:usage, and pname:flags组合方式的能力，可以通过调用 flink:vkGetPhysicalDeviceImageFormatProperties来
向Vulkan实现查询。
返回值可表示对于图像的该种组合方式是否受支持。
若支持， sname:VkImageFormatProperties 输出参数表示有效的 pname:samples bits和  pname:extent参数的限制的集合。

可调用如下函数来获知对于给定格式有效的标志位集合：

.Valid Usage
****
  * pname:format， pname:type，pname:tiling，pname:usage，和pname:flags 的组合 必须: 被支持，
	若把对应的值传递到相对应的参数里，并调用fname:vkGetPhysicalDeviceImageFormatProperties ，其返回值为VK_SUCCESS 可表明支持。
  * 若 pname:sharingMode 是 ename:VK_SHARING_MODE_CONCURRENT，
    pname:pQueueFamilyIndices 必须: 是一个指向 a pointer to an array of元素类型为basetype:uint32_t ，元素个数为
	pname:queueFamilyIndexCount 的数组的指针。
  * 若 pname:sharingMode 是 ename:VK_SHARING_MODE_CONCURRENT，
    pname:queueFamilyIndexCount 必须: 大于 `1`
  * pname:format 不能: 是 ename:VK_FORMAT_UNDEFINED
  *  pname:extent的成员pname:width, pname:height, 和 pname:depth  不能: 全大于`0`
  * pname:mipLevels 必须: 大于 `0`
  * pname:arrayLayers 必须: 大于 `0`
  * 若 pname:flags 包含 ename:VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT，
    pname:imageType 必须是 ename:VK_IMAGE_TYPE_2D
ifdef::VK_KHR_maintenance1[]
  * 若pname:flags包含s
    ename:VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT_KHR, pname:imageType must
    be ename:VK_IMAGE_TYPE_3D
endif::VK_KHR_maintenance1[]
  * 若 pname:imageType 是 ename:VK_IMAGE_TYPE_1D，pname:extent.width 必须:
    小于等于
    sname:VkPhysicalDeviceLimits::pname:maxImageDimension1D 或者
    sname:VkImageFormatProperties::pname:maxExtent.width (as returned by
    fname:vkGetPhysicalDeviceImageFormatProperties with pname:format,
    pname:type, pname:tiling, pname:usage, and pname:flags 等于 those in
    this structure) - 与值大的比较。
  * 若 pname:imageType 是 ename:VK_IMAGE_TYPE_2D 且 pname:flags 不包含
    ename:VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT，pname:extent.width
    和 pname:extent.height 必须: 小于等于
    sname:VkPhysicalDeviceLimits::pname:maxImageDimension2D, 或者
    sname:VkImageFormatProperties::pname:maxExtent.width/height (as returned
    by fname:vkGetPhysicalDeviceImageFormatProperties with pname:format,
    pname:type, pname:tiling, pname:usage, and pname:flags 等于 those in
    this structure) - 与值大的比较。
  * 若 pname:imageType 是 ename:VK_IMAGE_TYPE_2D 且 pname:flags 包含
    ename:VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT，pname:extent.width 且
    pname:extent.height 必须: 小于等于
    sname:VkPhysicalDeviceLimits::pname:maxImageDimensionCube, 或者
    sname:VkImageFormatProperties::pname:maxExtent.width/height (as returned
    by fname:vkGetPhysicalDeviceImageFormatProperties with pname:format,
    pname:type, pname:tiling, pname:usage, and pname:flags 等于 those in
    this structure) - 与值大的比较。
  * 若 pname:imageType 是 ename:VK_IMAGE_TYPE_2D 且 pname:flags 包含
    ename:VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT， pname:extent.width 且
    pname:extent.height 必须: 相等 且 pname:arrayLayers 必须: 大于等于 6
  * 若 pname:imageType 是 ename:VK_IMAGE_TYPE_3D，pname:extent.width,
    pname:extent.height 且 pname:extent.depth 必须: 小于等于 sname:VkPhysicalDeviceLimits::pname:maxImageDimension3D, 或者
    sname:VkImageFormatProperties::pname:maxExtent.width/height/depth (as
    returned by fname:vkGetPhysicalDeviceImageFormatProperties with
    pname:format, pname:type, pname:tiling, pname:usage, and pname:flags
    等于 those in this structure) - 与值大的比较。
  * 若 pname:imageType 是 ename:VK_IMAGE_TYPE_1D，  pname:extent.height
    和 pname:extent.depth 都 必须: 等于`1`
  * 若 pname:imageType 是 ename:VK_IMAGE_TYPE_2D， pname:extent.depth 必须: 等于 `1`
  * pname:mipLevels 必须: 小于等于
    [eq]#{lfloor}log~2~(max(pname:extent.width, pname:extent.height,
    pname:extent.depth)){rfloor} + 1#.
  * 若 pname:extent.width, pname:extent.height, 或者 pname:extent.depth 之中任意一个大于
    sname:VkPhysicalDeviceLimits::pname:maxImageDimension3D 中对等的名字的成员的数量， pname:mipLevels
    必须: 小于等于
    sname:VkImageFormatProperties::pname:maxMipLevels (as returned by
    fname:vkGetPhysicalDeviceImageFormatProperties with pname:format,
    pname:type, pname:tiling, pname:usage, and pname:flags 等于 those in
    this structure)
  * pname:arrayLayers 必须小于等于 sname:VkImageFormatProperties::pname:maxArrayLayers (as returned by
    fname:vkGetPhysicalDeviceImageFormatProperties with pname:format,
    pname:type, pname:tiling, pname:usage, and pname:flags 等于 those in
    this structure)
  * 若 pname:imageType 是 ename:VK_IMAGE_TYPE_3D， pname:arrayLayers 必须: 等于    `1`.
  * 若pname:samples 不是 ename:VK_SAMPLE_COUNT_1_BIT, pname:imageType
    必须 是 ename:VK_IMAGE_TYPE_2D, pname:flags 必须不能包含
    ename:VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT, pname:tiling 必须 be
    ename:VK_IMAGE_TILING_OPTIMAL, and pname:mipLevels 必须 be 等于 `1`
  * 若pname:usage 包含 ename:VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT,
    then bits other than ename:VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT,
    ename:VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT, and
    ename:VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT 必须 not be set
  * 若pname:usage 包含 ename:VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT,
    ename:VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT,
    ename:VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT,或
    ename:VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT, pname:extent.width 必须 be
   小于或 等于
    sname:VkPhysicalDeviceLimits::pname:maxFramebufferWidth
  * 若pname:usage 包含 ename:VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT,
    ename:VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT,
    ename:VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT,或
    ename:VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT, pname:extent.height 必须 be
   小于或 等于
    sname:VkPhysicalDeviceLimits::pname:maxFramebufferHeight
  * 若pname:usage 包含 ename:VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT,
    pname:usage 必须也包含至少
    ename:VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT,
    ename:VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT,或
    ename:VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT中的一个。
  * pname:samples 必须是一个bit value，被设置到
    sname:VkImageFormatProperties::pname:sampleCounts，该数值可通过
    以等于此数据集结构中的 pname:format,
    pname:type, pname:tiling, pname:usage, and pname:flags  参数来调用
	   fname:vkGetPhysicalDeviceImageFormatProperties 返回。
  * 若 <<features-features-textureCompressionETC2, ETC2 texture
    compression>> 特征没有被启用，pname:format 必须不能是
    ename:VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK,
    ename:VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK,
    ename:VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK,
    ename:VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK,
    ename:VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK,
    ename:VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK,
    ename:VK_FORMAT_EAC_R11_UNORM_BLOCK,
    ename:VK_FORMAT_EAC_R11_SNORM_BLOCK,
    ename:VK_FORMAT_EAC_R11G11_UNORM_BLOCK,或
    ename:VK_FORMAT_EAC_R11G11_SNORM_BLOCK
  * 若<<features-features-textureCompressionASTC_LDR,ASTC LDR texture
    compression>> 特征没有被启用，pname:format 必须不能是
    ename:VK_FORMAT_ASTC_4x4_UNORM_BLOCK,
    ename:VK_FORMAT_ASTC_4x4_SRGB_BLOCK,
    ename:VK_FORMAT_ASTC_5x4_UNORM_BLOCK,
    ename:VK_FORMAT_ASTC_5x4_SRGB_BLOCK,
    ename:VK_FORMAT_ASTC_5x5_UNORM_BLOCK,
    ename:VK_FORMAT_ASTC_5x5_SRGB_BLOCK,
    ename:VK_FORMAT_ASTC_6x5_UNORM_BLOCK,
    ename:VK_FORMAT_ASTC_6x5_SRGB_BLOCK,
    ename:VK_FORMAT_ASTC_6x6_UNORM_BLOCK,
    ename:VK_FORMAT_ASTC_6x6_SRGB_BLOCK,
    ename:VK_FORMAT_ASTC_8x5_UNORM_BLOCK,
    ename:VK_FORMAT_ASTC_8x5_SRGB_BLOCK,
    ename:VK_FORMAT_ASTC_8x6_UNORM_BLOCK,
    ename:VK_FORMAT_ASTC_8x6_SRGB_BLOCK,
    ename:VK_FORMAT_ASTC_8x8_UNORM_BLOCK,
    ename:VK_FORMAT_ASTC_8x8_SRGB_BLOCK,
    ename:VK_FORMAT_ASTC_10x5_UNORM_BLOCK,
    ename:VK_FORMAT_ASTC_10x5_SRGB_BLOCK,
    ename:VK_FORMAT_ASTC_10x6_UNORM_BLOCK,
    ename:VK_FORMAT_ASTC_10x6_SRGB_BLOCK,
    ename:VK_FORMAT_ASTC_10x8_UNORM_BLOCK,
    ename:VK_FORMAT_ASTC_10x8_SRGB_BLOCK,
    ename:VK_FORMAT_ASTC_10x10_UNORM_BLOCK,
    ename:VK_FORMAT_ASTC_10x10_SRGB_BLOCK,
    ename:VK_FORMAT_ASTC_12x10_UNORM_BLOCK,
    ename:VK_FORMAT_ASTC_12x10_SRGB_BLOCK,
    ename:VK_FORMAT_ASTC_12x12_UNORM_BLOCK,或
    ename:VK_FORMAT_ASTC_12x12_SRGB_BLOCK
  * 若 <<features-features-textureCompressionBC,BC texture compression>>
    特征没有被启用，pname:format 必须不能是
    ename:VK_FORMAT_BC1_RGB_UNORM_BLOCK, ename:VK_FORMAT_BC1_RGB_SRGB_BLOCK,
    ename:VK_FORMAT_BC1_RGBA_UNORM_BLOCK,
    ename:VK_FORMAT_BC1_RGBA_SRGB_BLOCK, ename:VK_FORMAT_BC2_UNORM_BLOCK,
    ename:VK_FORMAT_BC2_SRGB_BLOCK, ename:VK_FORMAT_BC3_UNORM_BLOCK,
    ename:VK_FORMAT_BC3_SRGB_BLOCK, ename:VK_FORMAT_BC4_UNORM_BLOCK,
    ename:VK_FORMAT_BC4_SNORM_BLOCK, ename:VK_FORMAT_BC5_UNORM_BLOCK,
    ename:VK_FORMAT_BC5_SNORM_BLOCK, ename:VK_FORMAT_BC6H_UFLOAT_BLOCK,
    ename:VK_FORMAT_BC6H_SFLOAT_BLOCK, ename:VK_FORMAT_BC7_UNORM_BLOCK,或
    ename:VK_FORMAT_BC7_SRGB_BLOCK
  * 若<<features-features-shaderStorageImageMultisample,multisampled
    storage images>> 特征没有被启用，且pname:usage包含
    ename:VK_IMAGE_USAGE_STORAGE_BIT, pname:samples 必须是
    ename:VK_SAMPLE_COUNT_1_BIT
  * 若<<features-features-sparseBinding,sparse bindings>> 特征没有被启用，pname:flags 必须 不能包含
    ename:VK_IMAGE_CREATE_SPARSE_BINDING_BIT
  * 若pname:imageType is ename:VK_IMAGE_TYPE_1D, pname:flags 必须 不能
   包含 ename:VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT
  * 若 <<features-features-sparseResidencyImage2D,sparse residency for
    2D images>>特征没有被启用， 且 pname:imageType 是
    ename:VK_IMAGE_TYPE_2D, pname:flags 必须 不能包含
    ename:VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT
  * 若<<features-features-sparseResidencyImage3D,sparse residency for
    3D images>>特征没有被启用， 且 pname:imageType is
    ename:VK_IMAGE_TYPE_3D, pname:flags 必须不能包含
    ename:VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT
  * 若the <<features-features-sparseResidency2Samples,sparse residency for
    images with 2 samples>>特征没有被启用， pname:imageType 是
    ename:VK_IMAGE_TYPE_2D, 且 pname:samples  是
    ename:VK_SAMPLE_COUNT_2_BIT, pname:flags 必须 不能包含
    ename:VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT
  * 若<<features-features-sparseResidency4Samples,sparse residency for
    images with 4 samples>>特征没有被启用， pname:imageType  是
    ename:VK_IMAGE_TYPE_2D, 且 pname:samples  是
    ename:VK_SAMPLE_COUNT_4_BIT, pname:flags 必须 不能包含
    ename:VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT
  * 若 <<features-features-sparseResidency8Samples,sparse residency for
    images with 8 samples>>特征没有被启用， pname:imageType  是
    ename:VK_IMAGE_TYPE_2D, 且 pname:samples  是
    ename:VK_SAMPLE_COUNT_8_BIT, pname:flags 必须 不能包含
    ename:VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT
  * 若<<features-features-sparseResidency16Samples,sparse residency for
    images with 16 samples>>特征没有被启用， pname:imageType  是
    ename:VK_IMAGE_TYPE_2D, 且 pname:samples  是
    ename:VK_SAMPLE_COUNT_16_BIT, pname:flags 必须 不能包含
    ename:VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT
  * 若pname:tiling is ename:VK_IMAGE_TILING_LINEAR, pname:format 必须是一个
    sname:VkFormatProperties::pname:linearTilingFeatures数据中的一个特征bit的格式，该数据是通过以pname:format相同值为参数 调用
    fname:vkGetPhysicalDeviceFormatProperties获取的。
  * 若pname:tiling is ename:VK_IMAGE_TILING_LINEAR, 和
    sname:VkFormatProperties::pname:linearTilingFeatures (as returned by
    fname:vkGetPhysicalDeviceFormatProperties with the same value of
    pname:format) 不包含
    ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT, pname:usage 必须不能包含
    ename:VK_IMAGE_USAGE_SAMPLED_BIT
  * 若pname:tiling is ename:VK_IMAGE_TILING_LINEAR, 和
    sname:VkFormatProperties::pname:linearTilingFeatures (as returned by
    fname:vkGetPhysicalDeviceFormatProperties with the same value of
    pname:format) 不包含
    ename:VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT, pname:usage 必须不能包含
    ename:VK_IMAGE_USAGE_STORAGE_BIT
  * 若pname:tiling is ename:VK_IMAGE_TILING_LINEAR, 和
    sname:VkFormatProperties::pname:linearTilingFeatures (as returned by
    fname:vkGetPhysicalDeviceFormatProperties with the same value of
    pname:format) 不包含
    ename:VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT, pname:usage 必须不能
   包含 ename:VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT
  * 若pname:tiling is ename:VK_IMAGE_TILING_LINEAR, 和
    sname:VkFormatProperties::pname:linearTilingFeatures (as returned by
    fname:vkGetPhysicalDeviceFormatProperties with the same value of
    pname:format) 不包含
    ename:VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT, pname:usage must:
    not包含 ename:VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT
  * 若pname:tiling 是 ename:VK_IMAGE_TILING_OPTIMAL, pname:format 必须 是
    value of sname:VkFormatProperties::pname:optimalTilingFeatures 其中一个受支持的特征bit的格式 ，该数据是通过以pname:format相同值为参数 调用
    fname:vkGetPhysicalDeviceFormatProperties  获取的。
  * 若pname:tiling 是 ename:VK_IMAGE_TILING_OPTIMAL, 且
    sname:VkFormatProperties::pname:optimalTilingFeatures (as returned by
    fname:vkGetPhysicalDeviceFormatProperties with the same value of
    pname:format) 不包含
    ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT, pname:usage 必须不能包含
    ename:VK_IMAGE_USAGE_SAMPLED_BIT
  * 若pname:tiling 是 ename:VK_IMAGE_TILING_OPTIMAL, 且
    sname:VkFormatProperties::pname:optimalTilingFeatures (as returned by
    fname:vkGetPhysicalDeviceFormatProperties with the same value of
    pname:format) 不包含
    ename:VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT, pname:usage 必须不能包含
    ename:VK_IMAGE_USAGE_STORAGE_BIT
  * 若pname:tiling 是 ename:VK_IMAGE_TILING_OPTIMAL, 且
    sname:VkFormatProperties::pname:optimalTilingFeatures (as returned by
    fname:vkGetPhysicalDeviceFormatProperties with the same value of
    pname:format) 不包含
    ename:VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT, pname:usage 必须不能
   包含 ename:VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT
  * 若pname:tiling 是 ename:VK_IMAGE_TILING_OPTIMAL, 且
    sname:VkFormatProperties::pname:optimalTilingFeatures (as returned by
    fname:vkGetPhysicalDeviceFormatProperties with the same value of
    pname:format) 不包含
    ename:VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT, pname:usage 不能
	包含 ename:VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT
  * 若pname:flags包含 ename:VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT或
    ename:VK_IMAGE_CREATE_SPARSE_ALIASED_BIT, 它必须也包含
    ename:VK_IMAGE_CREATE_SPARSE_BINDING_BIT
****

include::../validity/structs/VkImageCreateInfo.txt[]

ifdef::VK_NV_dedicated_allocation[]

// refBegin VkDedicatedAllocationImageCreateInfoNV Specify that an image is bound to a dedicated memory resource

若 pname:pNext 列表包含一个sname:VkDedicatedAllocationImageCreateInfoNV 数据结构，那么该数据结构包含一个控制开关，控制图像是否使用为它专门分配的内存。


 sname:VkDedicatedAllocationImageCreateInfoNV 数据结构定义如下：

include::../api/structs/VkDedicatedAllocationImageCreateInfoNV.txt[]

  * pname:sType是这个数据结构的类型。
  * pname:pNext 是 `NULL` 或者一个指向 拓展特定的数据结构的指针。
  * pname:dedicatedAllocation 表示图像是否将拥有专用的绑定的内存。

[NOTE]
.注意
====
在一些设备上使用为颜色、depth/stencil附件或 其他大图像 专用分配的内存将会提升性能。
====

.Valid Usage
****
  * 若 pname:dedicatedAllocation 为 ename:VK_TRUE，
    sname:VkImageCreateInfo::pname:flags 不能: 包括
    ename:VK_IMAGE_CREATE_SPARSE_BINDING_BIT，
    ename:VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT，或者
    ename:VK_IMAGE_CREATE_SPARSE_ALIASED_BIT
****

include::../validity/structs/VkDedicatedAllocationImageCreateInfoNV.txt[]

endif::VK_NV_dedicated_allocation[]

ifdef::VK_NV_external_memory[]

// refBegin VkExternalMemoryImageCreateInfoNV Specify that an image may be backed by external memory

若pname:pNext 列表包括一个 sname:VkExternalMemoryImageCreateInfoNV 数据结构，那么该数据结构定义了一些外部内存handle类型，
它们可用于存储图像。

sname:VkExternalMemoryImageCreateInfoNV 类型数据结构定义如下：

include::../api/structs/VkExternalMemoryImageCreateInfoNV.txt[]

  * pname:sType 是这个数据结构的类型。
  * pname:pNext 是 `NULL` 或者一个指向拓展特定的数据结构的指针。
  * pname:handleTypes 是一个
    elink:VkExternalMemoryHandleTypeFlagBitsNV 类型的 位掩码，指定了一个或多个外部内存handle类型。
	这些类型必须相互兼容，且其他图像创建参数相兼容，参数如 flink:vkGetPhysicalDeviceExternalImageFormatPropertiesNV 去取出的那样。

include::../validity/structs/VkExternalMemoryImageCreateInfoNV.txt[]

endif::VK_NV_external_memory[]

// refBegin VkImageUsageFlagBits Bitmask specifying intended usage of an image

图像的目标使用方式由 slink:VkImageCreateInfo::pname:usage 掩码表示。
可用标志位如下：

include::../api/enums/VkImageUsageFlagBits.txt[]

这些bit 有如下的意义：

  * ename:VK_IMAGE_USAGE_TRANSFER_SRC_BIT 表示图像 可以 被用作 转移命令的源。
  * ename:VK_IMAGE_USAGE_TRANSFER_DST_BIT 表示图像 可以 被用作 转移命令的目标。
  * ename:VK_IMAGE_USAGE_SAMPLED_BIT 表示图像 可以 被用于创建 适于占用
      ename:VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE 或
    ename:VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER类型，且可被着色器采样的sname:VkDescriptorSet槽的 sname:VkImageView 。
  * ename:VK_IMAGE_USAGE_STORAGE_BIT 表示 图像可以被用于创建适于占用
    ename:VK_DESCRIPTOR_TYPE_STORAGE_IMAGE类型的 sname:VkDescriptorSet 槽。
  * ename:VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT表示 该图像可以
   被用于创建  sname:VkImageView，其适于被用作 sname:VkFramebuffer中的 一个颜色 或  resolve 附件。
  * ename:VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT表示 该图像可以被用于创建 sname:VkImageView，
    其适于被用作sname:VkFramebuffer中的 depth/stencil 附件。
  * ename:VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT表示 绑定到此图像的内存使用
    ename:VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT (参考 <<memory>> 获取详细内容) 标志位被创建的。
    这个bit可以 设置给任何图像，该图像必须可以被用于创建 一个适于用作颜色、resolve、depth/stencil 或 输入附件。
  * ename:VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT表示 that该图像可以
   被用于创建 一个 sname:VkImageView，其适于占用一个
    ename:VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT 类型的 sname:VkDescriptorSet 槽;
	可从着色器中作为 输入附件 被读取；且可在缓冲区中被用作一个输入附件。

// refEnd VkImageUsageFlagBits

// refBegin VkImageCreateFlagBits Bitmask specifying additional parameters of an image

图像的其他参数可以通过
slink:VkImageCreateInfo::pname:flags  指定。
可以设置的 Bits 包括:

include::../api/enums/VkImageCreateFlagBits.txt[]

这些bit的含义如下：

  * ename:VK_IMAGE_CREATE_SPARSE_BINDING_BIT 表示图像将使用稀疏内存绑定来存储。
  * ename:VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT 表示图像可部分的使用稀疏内存绑定来存储。
	 使用此flog创建的图像也可以使用
    ename:VK_IMAGE_CREATE_SPARSE_BINDING_BIT flag创建。
  * ename:VK_IMAGE_CREATE_SPARSE_ALIASED_BIT表示 该图像 将使用稀疏内存绑定来存储，内存区间可能同时存储其他图像（或者同一图像的其他部分）。
    带有此flag被创建的图像 必须也带有 ename:VK_IMAGE_CREATE_SPARSE_BINDING_BIT 标志位。
  * ename:VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT表示 该图像可以
   被用于创建与此图像格式不同的格式的 sname:VkImageView。
  * ename:VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT表示 该图像可以
   被用于创建 ename:VK_IMAGE_VIEW_TYPE_CUBE或 ename:VK_IMAGE_VIEW_TYPE_CUBE_ARRAY类型的sname:VkImageView 。
ifdef::VK_KHR_maintenance1[]
  * ename:VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT_KHR表示该图像可以被用于创建
    ename:VK_IMAGE_VIEW_TYPE_2D或 ename:VK_IMAGE_VIEW_TYPE_2D_ARRAY类型的 sname:VkImageView。
endif::VK_KHR_maintenance1[]

如果ename:VK_IMAGE_CREATE_SPARSE_BINDING_BIT, ename:VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT, 或者 ename:VK_IMAGE_CREATE_SPARSE_ALIASED_BIT 之一被设置过了，
ename:VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT 就不能被设置了。

参考 <<sparsememory-sparseresourcefeatures,Sparse Resource Features>> 和
<<sparsememory-physicalfeatures,Sparse Physical Device Features>> 来获取更多细节。

// refEnd VkImageCreateFlagBits

// refBegin VkImageType Specifies the type of an image object

图像的基础维度是通过slink:VkImageCreateInfo::pname:imageType 指定的，必须是如下值之一：

include::../api/enums/VkImageType.txt[]

这些值各自指定了一维-，二维-或者三维- 图像。

// refEnd VkImageType

// refBegin VkImageTiling Specifies the tiling arrangement of data in an image

The tiling arrangement of data elements in an image is specified by
slink:VkImageCreateInfo::pname:tiling, which 必须 be one of the values

include::../api/enums/VkImageTiling.txt[]

ename:VK_IMAGE_TILING_OPTIMAL specifies optimal tiling (texels are laid out
in an implementation-dependent arrangement, for more optimal memory access),
and ename:VK_IMAGE_TILING_LINEAR specifies linear tiling (texels are laid
out in memory in row-major或der, possibly with some padding on each row).

// refEnd VkImageTiling

// refBegin vkGetImageSubresourceLayout Retrieve information about an image subresource

对于以线性tiling 创建的图像，可调用如下命令来查询图像子资源的主机端访问布局：

include::../api/protos/vkGetImageSubresourceLayout.txt[]

  * pname:device 是拥有该图像的逻辑设备。
  * pname:image 被查询布局的图像。
  * pname:pSubresource 是一个指向 slink:VkImageSubresource 数据结构的指针，为图像子资源选择了指定的图像。
  * pname:pLayout 指向一个 slink:VkSubresourceLayout 数据结构，存储被返回的布局。

flink:vkGetImageSubresourceLayout 对于单个图像的生命周期来说是不变的。

.Valid Usage
****
  * pname:image 必须: 是使用 pname:tiling 为  ename:VK_IMAGE_TILING_LINEAR的参数创建的。
  * pname:pSubresource的pname:aspectMask 成员 必须: 只能让其一个bit 被设置。
****

include::../validity/protos/vkGetImageSubresourceLayout.txt[]

// refBegin VkImageSubresource Structure specifying a image subresource

sname:VkImageSubresource 数据结构定义如下：

include::../api/structs/VkImageSubresource.txt[]

  * pname:aspectMask 是一个 elink:VkImageAspectFlags ，筛选图像的 _aspect_。
  * pname:mipLevel 选择了mipmap层级。
  * pname:arrayLayer 选择了array layer。

.Valid Usage
****
  * pname:mipLevel 必须: 小于 pname:mipLevels，由图像被创建时的slink:VkImageCreateInfo 所指定。
  * pname:arrayLayer 必须: 小于 pname:arrayLayers，由图像被创建时的  slink:VkImageCreateInfo 所指定。
****

include::../validity/structs/VkImageSubresource.txt[]

// refBegin VkSubresourceLayout Structure specifying subresource layout

该图像子资源的布局的信息 被封装在sname:VkSubresourceLayout 数据结构中被返回：

include::../api/structs/VkSubresourceLayout.txt[]

  * pname:offset 是该图像子资源起始的偏移字节数。
  * pname:size  该图像子资源的字节大小。
    pname:size 包含 要求基于pname:rowPitch的 任何 额外内存。
  * pname:rowPitch 描述了一个图像内每行纹素的字节数。
  * pname:arrayPitch 描述了一个图像内每个array layer 的字节数。
  * pname:depthPitch 描述了3D图像的每个切分的字节数。

对于线性排列创建的图像，pname:rowPitch, pname:arrayPitch 和
pname:depthPitch 描述 该图像子资源再线性内存中的布局。
对于未压缩的格式， pname:rowPitch 是相邻行（y坐标相差1）之间相同x坐标的纹素之间的字节数。
pname:arrayPitch 是该图像的相邻array layer 的同x、y坐标纹素之间的字节数。
pname:depthPitch 是3D图像相邻切片（z坐标相差1）内同x、y坐标之间纹素之间的字节数。
通过一个寻址表达式来表示，一个图像子资源的纹素的起始字节 地址为：

[source,c]
---------------------------------------------------
// (x,y,z,layer) are in texel coordinates
address(x,y,z,layer) = layer*arrayPitch + z*depthPitch + y*rowPitch + x*elementSize + offset
---------------------------------------------------

对于压缩格式，pname:rowPitch 是相邻行的压缩的纹素块的字节数。
pname:arrayPitch 是相邻array layers的压缩纹素块之间的字节数。
pname:depthPitch 是相邻的3D图像的切片的压缩纹素块之间的字节数。

[source,c]
---------------------------------------------------
// (x,y,z,layer) are in compressed texel block coordinates
address(x,y,z,layer) = layer*arrayPitch + z*depthPitch + y*rowPitch + x*compressedTexelBlockByteSize + offset;
---------------------------------------------------

pname:arrayPitch is undefined for images that were not created as arrays.
pname:depthPitch is defined only for 3D images.

对于颜色格式， sname:VkImageSubresource的pname:aspectMask 成员
必须 是 ename:VK_IMAGE_ASPECT_COLOR_BIT.
对于depth/stencil 格式，pname:aspectMask 必须是
ename:VK_IMAGE_ASPECT_DEPTH_BIT或 ename:VK_IMAGE_ASPECT_STENCIL_BIT 二者其一。
On implementations that store depth and stencil aspects separately, querying
each of these image subresource layouts will return a different pname:offset
and pname:size representing the region of memory used for that aspect.
On implementations that store depth and stencil aspects interleaved, the
same pname:offset and pname:size are returned and represent the interleaved
memory allocation.

include::../validity/structs/VkSubresourceLayout.txt[]

// refBegin vkDestroyImage Destroy an image object

可调用如下命令来销毁图像：

include::../api/protos/vkDestroyImage.txt[]

  * pname:device 是拥有需被销毁图像的逻辑设备。
  * pname:image 是需被销毁的图像。
  * pname:pAllocator 控制CPU端内存分配，如 <<memory-allocation, 内存分配 >> 一章详述。

.Valid Usage
****
  * 所有直接或 通过一个sname:VkImageView引用pname:image的已提交的命令，必须已经完成执行。
  * 若创建图像时 提供了sname:VkAllocationCallbacks，那么在此处必须提供兼容的回调。
  * 若创建图像时没有提供sname:VkAllocationCallbacks，那么pname:pAllocator 必须为 `NULL`
****

include::../validity/protos/vkDestroyImage.txt[]


[[resources-image-layouts]]
== 图像布局

图像被存储在依赖于Vulkan实现的不透明内存布局。Vulkan实现能能支持多种不透明布局，某个给定时刻使用的布局由
图像子资源的elink:VkImageLayout 状态决定。
每一个布局都有限制条件，如使用该布局可对图像子资源做何种操作。
Applications have control over which layout each image subresource uses, and
can: transition an image subresource from one layout to another.
Transitions可以 happen with an image memory barrier, included as part of a
fname:vkCmdPipelineBarrier或 a fname:vkCmdWaitEvents command buffer command
(see <<synchronization-image-memory-barriers>>),或 as part of a subpass
dependency within a render pass (see sname:VkSubpassDependency).
The image layout state is per-image subresource, and separate image
subresources of the same image可以 be in different layouts at the same time
with one exception - depth and stencil aspects of a given image subresource
必须 always be in the same layout.

[NOTE]
.注意
====
Each layout may: offer optimal performance for a specific usage of image
memory.
For example, an image with a layout of
ename:VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL may: provide optimal
performance for use as a color attachment, but be unsupported for use in
transfer commands.
Applications可以 transition an image subresource from one layout to another
in或der to achieve optimal performance when该图像 subresource is used
for multiple kinds of operations.
After initialization, applications need not use any layout other than the
general layout, though this may: produce suboptimal performance on some
implementations.
====

创建完成后，一个图像的所有图像子资源初始状态都处于相同的布局，该布局由
sname:VkImageCreateInfo::pname:initialLayout 成员选择。
pname:initialLayout 必须 为 ename:VK_IMAGE_LAYOUT_UNDEFINED或
ename:VK_IMAGE_LAYOUT_PREINITIALIZED 二者其一。
若为 ename:VK_IMAGE_LAYOUT_PREINITIALIZED, 那么该图像数据可以被host使用该布局预初始化，且布局转换可以保持数据。
若为 ename:VK_IMAGE_LAYOUT_UNDEFINED, 那么数据的内容被认为是未定义的，布局转换并不保证保持原有数据。
对于这任一初始布局，任何图像子资源 必须在device 访问它们之前转换到另一个布局。

Host access to image memory is only well-defined for images created with
ename:VK_IMAGE_TILING_LINEAR tiling and for image subresources of those
images which are currently in either the
ename:VK_IMAGE_LAYOUT_PREINITIALIZED或 ename:VK_IMAGE_LAYOUT_GENERAL
layout.
Calling flink:vkGetImageSubresourceLayout for a linear image returns a
subresource layout mapping that is valid for either of those image layouts.

// refBegin VkImageLayout Layout of image and image subresources

The set of image layouts consists of:

include::../api/enums/VkImageLayout.txt[]

The type(s) of device access supported by each layout are:

  * ename:VK_IMAGE_LAYOUT_UNDEFINED: 不支持设备访问。此布局 必须 仅被用作
    sname:VkImageCreateInfo或 sname:VkAttachmentDescription的pname:initialLayout成员，或用于图像转换的 pname:oldLayout。
	当从此布局转换为其他布局时，内存的内容不被保证保留。
  * ename:VK_IMAGE_LAYOUT_PREINITIALIZED: 不支持设备访问。
    此布局必须 仅被用于
    sname:VkImageCreateInfo或 sname:VkAttachmentDescription的pname:initialLayout 成员，或用于图像转换的pname:oldLayout 。
	当从此布局转换为其他布局时，内存的内容被保证保留。
    此布局 专门被用于 host端写入的图像，其数据可以被立即写入内存，而不需要先执行布局转换。
    当前，ename:VK_IMAGE_LAYOUT_PREINITIALIZED 只对
    ename:VK_IMAGE_TILING_LINEAR 图像有效，因为并没有为ename:VK_IMAGE_TILING_OPTIMAL 图像定义的标准布局。
  * ename:VK_IMAGE_LAYOUT_GENERAL: 支持所有类型的设备访问。
  * ename:VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL: 必须 仅被用于sname:VkFramebuffer中的颜色或 resolve 附件。
    此布局仅针对 以带有ename:VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT bit位被启用来创建的图像子资源来说有效。
  * ename:VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL: 必须 仅被用于sname:VkFramebuffer的 depth/stencil 附件。
    此布局仅针对 以带有 ename:VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT bit位被启用来创建的图像子资源来说有效。
  * ename:VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL: 必须 仅被用于sname:VkFramebuffer的只读 depth/stencil 附件，
     且/或 被用于 着色器中只读的图像 (可以当作采样图像，combined image/sampler and/or 输入附件 被读取).
	 此布局仅针对 以带有 ename:VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT bit位被启用来创建的图像子资源来说有效。
    以ename:VK_IMAGE_USAGE_SAMPLED_BIT 被创建的图像的图像子资源 可以在着色器中 被用作采样图像或combined image/sampler。
    同样，, only image subresources of images created with
    以ename:VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT 被创建的图像的图像子资源 可以在着色器中被用作 输入附件。
  * ename:VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL: 必须 仅被用作 着色器内只读图像 (可以被当作 采样图像、combined image/sampler 或 输入附件 只读采样)。
	此布局仅针对 以带有 ename:VK_IMAGE_USAGE_SAMPLED_BIT 或    ename:VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT   bit位被启用来创建的图像子资源来说有效。
  * ename:VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL: 必须 仅被用作 转移命令的源图像 (参考<<synchronization-pipeline-stages-transfer,  ename:VK_PIPELINE_STAGE_TRANSFER_BIT>>的定义).
	此布局仅针对 以带有 ename:VK_IMAGE_USAGE_TRANSFER_SRC_BIT bit位被启用来创建的图像子资源来说有效。
  * ename:VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL: 必须 仅被用作 转移命令的目标图像。
	此布局仅针对 以带有 ename:VK_IMAGE_USAGE_TRANSFER_DST_BIT bit位被启用来创建的图像子资源来说有效。
ifdef::VK_KHR_swapchain[]
  * ename:VK_IMAGE_LAYOUT_PRESENT_SRC_KHR: 必须 only被用于 for presenting
    a presentable image for display.
    A swapchain's image 必须 be transitioned to this layout before calling
    flink:vkQueuePresentKHR, and 必须 be transitioned away from this layout
    after calling flink:vkAcquireNextImageKHR.
endif::VK_KHR_swapchain[]

在API中每种方位图像的机制，都有一个参数 或 数据结构成员 来控制 访问该图像的布局。
对于转移命令，这是命令的一个参数 (参考 <<clears>> 和 <<copies>>)。
对于用作 帧缓冲区附件，这是 sname:VkRenderPassCreateInfo 数据结构的一个成员 (参考 <<renderpass,Render Pass>>)。
对于描述符集合中的使用，这是sname:VkDescriptorImageInfo数据结构的一个成员 (参考 <<descriptorsets-updates>>)。
在任何队列上 任何命令缓冲区命令访问图像的任何时刻，被访问该图像子资源的布局必须都匹配 API控制访问所指定的布局。

每个图像子资源的图像布局必须在该图像子资源的生命周期的每个时刻都是良好定义的。
这意味这在 该图像上操作 布局转换，老的布局值必须 等同于当前 图像子资源的布局 (在转换执行过程中), 或者是
ename:VK_IMAGE_LAYOUT_UNDEFINED ( 意味着该图像子资源的内容不需要被保留)。
转移中使用的新布局 不能是 ename:VK_IMAGE_LAYOUT_UNDEFINED或 ename:VK_IMAGE_LAYOUT_PREINITIALIZED。

// refEnd VkImageLayout


[[resources-image-views]]
== 图像视图

// refBegin VkImageView Opaque handle to a image view object

图像对象不会被管线着色器直接读写访问。作为替代，_图像视图_，表示图像资源连续的一部分，带有附加的元信息，可用作上述目的。
视图必须以与图像兼容的类型来被创建，必须表示图像资源的一个有效子集合。

图像视图通过sname:VkImageView 类型的handle表示：

include::../api/handles/VkImageView.txt[]

// refEnd VkImageView

// refBegin VkImageViewType Image view types

可以被创建的 图像视图的类型：

include::../api/enums/VkImageViewType.txt[]

图像视图的准确类型部分是隐式的，基于图像的类型、采样数量，和 <<resources-image-views-compatibility, 下表>>
描述的视图创建参数。这个表格也展示了每一个图像视图类型在SPIR-V中对应的OpTypeImage Dim 和 Arrayed等参数。

// refEnd VkImageViewType

// refBegin vkCreateImageView Create an image view from an existing image

可调用下面命令来创建图像视图：

include::../api/protos/vkCreateImageView.txt[]

  * pname:device 是创建图像视图的逻辑设备。
  * pname:pCreateInfo 是一个指针，指向一个 sname:VkImageViewCreateInfo 数据结构实例，它包含了创建图像视图所需的信息。
  * pname:pAllocator 控制CPU端内存分配，如 <<memory-allocation, 内存分配 >> 一章详述。
  * pname:pView 指向一个 sname:VkImageView handle，它是被返回的新生成的图像视图对象。

图像创建参数的一部分被视图所继承，剩余的参数被包含在pname:pCreateInfo中。

include::../validity/protos/vkCreateImageView.txt[]

// refBegin VkImageViewCreateInfo Structure specifying parameters of a newly created image view

sname:VkImageViewCreateInfo类型定义如下：

include::../api/structs/VkImageViewCreateInfo.txt[]

  * pname:sType 是这个数据结构的类型。
  * pname:pNext 是`NULL` 或者一个指向拓展特定的数据结构的指针。
  * pname:flags 被保留使用。
  * pname:image is a sname:VkImage on which the view will be created.
  * pname:viewType 是图像视图的类型。
  * pname:format 是一个 elink:VkFormat 类型数据，描述了用于结束图像中数据元素的格式和类型。
  * pname:components 指定了颜色成员(或深度成员，或转换到颜色成员之后的 stencil 成员)重映射。
    参考 slink:VkComponentMapping。
  * pname:subresourceRange 是一个 slink:VkImageSubresourceRange，选择来view可访问的mipmap levels和array layers。

若以ename:VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT 创建 pname:image，pname:format可以与该图像的格式不同， 但是若它们不等同，
那么它们必须是兼容的。
图像格式兼容性在 <<features-formats-compatibility-classes,Format Compatibility Classes>>
小节中定义。

[[resources-image-views-compatibility]]
.Image and image view parameter compatibility requirements
[cols="15%h,35%,50%",options="header"]
|====
| Dim, Arrayed, MS | Image parameters | View parameters
| | pname:imageType = ci.pname:imageType +
    pname:width = ci.pname:extent.width +
    pname:height = ci.pname:extent.height +
    pname:depth = ci.pname:extent.depth +
    pname:arrayLayers = ci.pname:arrayLayers +
    pname:samples = ci.pname:samples +
    where ci is the slink:VkImageCreateInfo used创建 pname:image.
  | pname:baseArrayLayer and pname:layerCount are members of the
    pname:subresourceRange member.
| 1D, 0, 0 |
pname:imageType = ename:VK_IMAGE_TYPE_1D +
pname:width {geq} 1 +
pname:height = 1 +
pname:depth = 1 +
pname:arrayLayers {geq} 1 +
pname:samples = 1 |
pname:viewType = ename:VK_VIEW_TYPE_1D +
pname:baseArrayLayer {geq} 0 +
pname:layerCount = 1
| 1D, 1, 0 |
pname:imageType = ename:VK_IMAGE_TYPE_1D +
pname:width {geq} 1 +
pname:height = 1 +
pname:depth = 1 +
pname:arrayLayers {geq} 1 +
pname:samples = 1 |
pname:viewType = ename:VK_VIEW_TYPE_1D_ARRAY +
pname:baseArrayLayer {geq} 0 +
pname:layerCount {geq} 1
| 2D, 0, 0 |
pname:imageType = ename:VK_IMAGE_TYPE_2D +
pname:width {geq} 1 +
pname:height {geq} 1 +
pname:depth = 1 +
pname:arrayLayers {geq} 1 +
pname:samples = 1 |
pname:viewType = ename:VK_VIEW_TYPE_2D +
pname:baseArrayLayer {geq} 0 +
pname:layerCount = 1
| 2D, 1, 0 |
pname:imageType = ename:VK_IMAGE_TYPE_2D +
pname:width {geq} 1 +
pname:height {geq} 1 +
pname:depth = 1 +
pname:arrayLayers {geq} 1 +
pname:samples = 1 |
pname:viewType = ename:VK_VIEW_TYPE_2D_ARRAY +
pname:baseArrayLayer {geq} 0 +
pname:layerCount {geq} 1
| 2D, 0, 1 |
pname:imageType = ename:VK_IMAGE_TYPE_2D +
pname:width {geq} 1 +
pname:height {geq} 1 +
pname:depth = 1 +
pname:arrayLayers {geq} 1 +
pname:samples > 1 |
pname:viewType = ename:VK_VIEW_TYPE_2D +
pname:baseArrayLayer {geq} 0 +
pname:layerCount = 1
| 2D, 1, 1 |
pname:imageType = ename:VK_IMAGE_TYPE_2D +
pname:width {geq} 1 +
pname:height {geq} 1 +
pname:depth = 1 +
pname:arrayLayers {geq} 1 +
pname:samples > 1 |
pname:viewType = ename:VK_VIEW_TYPE_2D_ARRAY +
pname:baseArrayLayer {geq} 0 +
pname:layerCount {geq} 1
| CUBE, 0, 0 |
pname:imageType = ename:VK_IMAGE_TYPE_2D +
pname:width {geq} 1 +
pname:height = pname:width +
pname:depth = 1 +
pname:arrayLayers {geq} 6 +
pname:samples = 1 +
pname:flags 包含 ename:VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT |
pname:viewType = ename:VK_VIEW_TYPE_CUBE +
pname:baseArrayLayer {geq} 0 +
pname:layerCount = 6
| CUBE, 1, 0 |
pname:imageType = ename:VK_IMAGE_TYPE_2D +
pname:width {geq} 1 +
pname:height = width +
pname:depth = 1 +
_N_ {geq} 1 +
pname:arrayLayers {geq} 6 {times} _N_ +
pname:samples = 1 +
pname:flags 包含 ename:VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT |
pname:viewType = ename:VK_VIEW_TYPE_CUBE_ARRAY +
pname:baseArrayLayer {geq} 0 +
pname:layerCount = 6 {times} _N_, _N_ {geq} 1
| 3D, 0, 0 |
pname:imageType = ename:VK_IMAGE_TYPE_3D +
pname:width {geq} 1 +
pname:height {geq} 1 +
pname:depth {geq} 1 +
pname:arrayLayers = 1 +
pname:samples = 1 |
pname:viewType = ename:VK_VIEW_TYPE_3D +
pname:baseArrayLayer = 0 +
pname:layerCount = 1
ifdef::VK_KHR_maintenance1[]
| 3D, 0, 0 |
pname:imageType = ename:VK_IMAGE_TYPE_3D +
pname:width {geq} 1 +
pname:height {geq} 1 +
pname:depth {geq} 1 +
pname:arrayLayers = 1 +
pname:samples = 1 +
pname:flags 包含 ename:VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT +
pname:flags 不包含 VK_IMAGE_CREATE_SPARSE_BINDING_BIT, VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT, and VK_IMAGE_CREATE_SPARSE_ALIASED_BIT |
pname:viewType = ename:VK_VIEW_TYPE_2D +
pname:levelCount = 1 +
pname:baseArrayLayer {geq} 0 +
pname:layerCount = 1
| 3D, 0, 0 |
pname:imageType = ename:VK_IMAGE_TYPE_3D +
pname:width {geq} 1 +
pname:height {geq} 1 +
pname:depth {geq} 1 +
pname:arrayLayers = 1 +
pname:samples = 1 +
pname:flags 包含 ename:VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT +
pname:flags 不包含 VK_IMAGE_CREATE_SPARSE_BINDING_BIT, VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT, and VK_IMAGE_CREATE_SPARSE_ALIASED_BIT |
pname:viewType = ename:VK_VIEW_TYPE_2D_ARRAY +
pname:levelCount = 1 +
pname:baseArrayLayer {geq} 0 +
pname:layerCount {geq} 1
endif::VK_KHR_maintenance1[]
|====

.Valid Usage
****
  * 若创建pname:image时没有带有 ename:VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT，那么 pname:viewType 不能是
     ename:VK_IMAGE_VIEW_TYPE_CUBE或 ename:VK_IMAGE_VIEW_TYPE_CUBE_ARRAY
  * 若 <<features-features-imageCubeArray,image cubemap arrays>> 特征没有被启用，pname:viewType 不能是
    ename:VK_IMAGE_VIEW_TYPE_CUBE_ARRAY
ifdef::VK_KHR_maintenance1[]
  * 若创建 pname:image时带有 ename:VK_IMAGE_TYPE_3D 但未带有 ename:VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT_KHR，
   那么 pname:viewType 不能是 ename:VK_IMAGE_VIEW_TYPE_2D或
    ename:VK_IMAGE_VIEW_TYPE_2D_ARRAY
endif::VK_KHR_maintenance1[]
  * 若 <<features-features-textureCompressionETC2,ETC2 texture
    compression>>特征没有被启用， pname:format 不能是
    ename:VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK,
    ename:VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK,
    ename:VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK,
    ename:VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK,
    ename:VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK,
    ename:VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK,
    ename:VK_FORMAT_EAC_R11_UNORM_BLOCK,
    ename:VK_FORMAT_EAC_R11_SNORM_BLOCK,
    ename:VK_FORMAT_EAC_R11G11_UNORM_BLOCK,或
    ename:VK_FORMAT_EAC_R11G11_SNORM_BLOCK
  * 若<<features-features-textureCompressionASTC_LDR,ASTC LDR texture
    compression>>特征没有被启用， pname:format 不能是
    ename:VK_FORMAT_ASTC_4x4_UNORM_BLOCK,
    ename:VK_FORMAT_ASTC_4x4_SRGB_BLOCK,
    ename:VK_FORMAT_ASTC_5x4_UNORM_BLOCK,
    ename:VK_FORMAT_ASTC_5x4_SRGB_BLOCK,
    ename:VK_FORMAT_ASTC_5x5_UNORM_BLOCK,
    ename:VK_FORMAT_ASTC_5x5_SRGB_BLOCK,
    ename:VK_FORMAT_ASTC_6x5_UNORM_BLOCK,
    ename:VK_FORMAT_ASTC_6x5_SRGB_BLOCK,
    ename:VK_FORMAT_ASTC_6x6_UNORM_BLOCK,
    ename:VK_FORMAT_ASTC_6x6_SRGB_BLOCK,
    ename:VK_FORMAT_ASTC_8x5_UNORM_BLOCK,
    ename:VK_FORMAT_ASTC_8x5_SRGB_BLOCK,
    ename:VK_FORMAT_ASTC_8x6_UNORM_BLOCK,
    ename:VK_FORMAT_ASTC_8x6_SRGB_BLOCK,
    ename:VK_FORMAT_ASTC_8x8_UNORM_BLOCK,
    ename:VK_FORMAT_ASTC_8x8_SRGB_BLOCK,
    ename:VK_FORMAT_ASTC_10x5_UNORM_BLOCK,
    ename:VK_FORMAT_ASTC_10x5_SRGB_BLOCK,
    ename:VK_FORMAT_ASTC_10x6_UNORM_BLOCK,
    ename:VK_FORMAT_ASTC_10x6_SRGB_BLOCK,
    ename:VK_FORMAT_ASTC_10x8_UNORM_BLOCK,
    ename:VK_FORMAT_ASTC_10x8_SRGB_BLOCK,
    ename:VK_FORMAT_ASTC_10x10_UNORM_BLOCK,
    ename:VK_FORMAT_ASTC_10x10_SRGB_BLOCK,
    ename:VK_FORMAT_ASTC_12x10_UNORM_BLOCK,
    ename:VK_FORMAT_ASTC_12x10_SRGB_BLOCK,
    ename:VK_FORMAT_ASTC_12x12_UNORM_BLOCK,或
    ename:VK_FORMAT_ASTC_12x12_SRGB_BLOCK
  * 若 <<features-features-textureCompressionBC,BC texture compression>>
   特征没有被启用， pname:format 不能是
    ename:VK_FORMAT_BC1_RGB_UNORM_BLOCK, ename:VK_FORMAT_BC1_RGB_SRGB_BLOCK,
    ename:VK_FORMAT_BC1_RGBA_UNORM_BLOCK,
    ename:VK_FORMAT_BC1_RGBA_SRGB_BLOCK, ename:VK_FORMAT_BC2_UNORM_BLOCK,
    ename:VK_FORMAT_BC2_SRGB_BLOCK, ename:VK_FORMAT_BC3_UNORM_BLOCK,
    ename:VK_FORMAT_BC3_SRGB_BLOCK, ename:VK_FORMAT_BC4_UNORM_BLOCK,
    ename:VK_FORMAT_BC4_SNORM_BLOCK, ename:VK_FORMAT_BC5_UNORM_BLOCK,
    ename:VK_FORMAT_BC5_SNORM_BLOCK, ename:VK_FORMAT_BC6H_UFLOAT_BLOCK,
    ename:VK_FORMAT_BC6H_SFLOAT_BLOCK, ename:VK_FORMAT_BC7_UNORM_BLOCK,或
    ename:VK_FORMAT_BC7_SRGB_BLOCK
  * 若创建pname:image 时带有 ename:VK_IMAGE_TILING_LINEAR，
    pname:format 必须是 一种格式，至少有一个受支持的bit 是
    通过以相同值的pname:format调用fname:vkGetPhysicalDeviceFormatProperties  返回的sname:VkFormatProperties::pname:linearTilingFeatures
	其中的一个bit值。
  * 创建pname:image时 必须让 pname:usage value包含 至少 ename:VK_IMAGE_USAGE_SAMPLED_BIT,
    ename:VK_IMAGE_USAGE_STORAGE_BIT,
    ename:VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT,
    ename:VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT,或
    ename:VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT 其中的一个
  * 若创建pname:image时带有 ename:VK_IMAGE_TILING_LINEAR 且
    pname:usage包含 ename:VK_IMAGE_USAGE_SAMPLED_BIT, pname:format
    必须 被采样图像支持，
    通过以相同值的pname:format调用fname:vkGetPhysicalDeviceFormatProperties 返回的sname:VkFormatProperties::pname:linearTilingFeatures
    的ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT 指定的值。
  * 若创建pname:image 时带有ename:VK_IMAGE_TILING_LINEAR 且
    pname:usage包含 ename:VK_IMAGE_USAGE_STORAGE_BIT, pname:format
    必须 被存储图像所支持，如
    sname:VkFormatProperties::pname:linearTilingFeatures中ename:VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT 标识位所指定，
    该数据结构通过以相同的 pname:format参数调用fname:vkGetPhysicalDeviceFormatProperties 返回，
  * 若创建pname:image时 带有 ename:VK_IMAGE_TILING_LINEAR，且
    pname:usage包含 ename:VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT,
    pname:format 必须被颜色附件所支持， 如
    sname:VkFormatProperties::pname:linearTilingFeatures中的 ename:VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT 标识位所指定，
    该数据结构通过调用 fname:vkGetPhysicalDeviceFormatProperties 返回，得到相同的 pname:format。
  * 若创建pname:image 时带有ename:VK_IMAGE_TILING_LINEAR 且
    pname:usage包含    ename:VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT, pname:format 必须 被depth/stencil附件所支持，如
    sname:VkFormatProperties::pname:linearTilingFeatures中的 ename:VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT 标识位所指定，
    该数据结构通过以相同的 pname:format参数调用 fname:vkGetPhysicalDeviceFormatProperties返回
  * 若创建pname:image 时带有ename:VK_IMAGE_TILING_OPTIMAL,
    pname:format 中至少有一个bit位，出现在
    通过以相同的 pname:format参数调用fname:vkGetPhysicalDeviceFormatProperties 返回的 sname:VkFormatProperties::pname:optimalTilingFeatures的值当中，
  * 若创建 pname:image 时带有 ename:VK_IMAGE_TILING_OPTIMAL，且
    pname:usage包含 ename:VK_IMAGE_USAGE_SAMPLED_BIT, pname:format
    必须 被采样图像所支持，如
    sname:VkFormatProperties::pname:optimalTilingFeatures中的  ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT 标识位所指定，
    该数据结构通过以相同的 pname:format参数调用 fname:vkGetPhysicalDeviceFormatProperties返回
  * 若创建pname:image 时带有ename:VK_IMAGE_TILING_OPTIMAL 且
    pname:usage包含 ename:VK_IMAGE_USAGE_STORAGE_BIT, pname:format
    必须 被存储图像所支持，如
    sname:VkFormatProperties::pname:optimalTilingFeatures中ename:VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT标识位所指定，
    该数据结构通过以相同的 pname:format参数调用 fname:vkGetPhysicalDeviceFormatProperties 返回
  * 若创建pname:image 时带有ename:VK_IMAGE_TILING_OPTIMAL 且
    pname:usage包含 ename:VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT,
    pname:format 必须被颜色附件所支持，如
    sname:VkFormatProperties::pname:optimalTilingFeatures中的ename:VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT 标识位所指定，
    该数据结构通过以相同的 pname:format参数调用 fname:vkGetPhysicalDeviceFormatProperties 返回
  * 若创建pname:image 时带有 ename:VK_IMAGE_TILING_OPTIMAL 且
    pname:usage包含    ename:VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT, pname:format 必须不为 depth/stencil 附件所支持，如
    sname:VkFormatProperties::pname:optimalTilingFeatures 中的    ename:VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT标识位所指定，
    该数据结构通过以相同的 pname:format参数调用 fname:vkGetPhysicalDeviceFormatProperties 返回
  * pname:subresourceRange 必须时一个对pname:image来说有效的图像子资源区间 (参考 <<resources-image-views>>)
  * 若创建pname:image 时带有 ename:VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT 标识位, pname:format 必须与
    用来创建 pname:image的 pname:format相兼容， 如 <<features-formats-compatibility-classes,Format Compatibility
    Classes>>
  * 若创建pname:image 时没有带有
    ename:VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT 标识位， pname:format 必须与
    创建 pname:image的pname:format 完全相同
  * 若pname:image 是 非-稀疏的，那么它必须与单个sname:VkDeviceMemory 对象完全并连续绑定。
  * pname:subResourceRange 和 pname:viewType 必须 与图像兼容，如
    <<resources-image-views-compatibility,compatibility table>>所描述。
****

include::../validity/structs/VkImageViewCreateInfo.txt[]

// refBegin VkImageSubresourceRange Structure specifying a image subresource range

sname:VkImageSubresourceRange类型数据结构定义如下：

include::../api/structs/VkImageSubresourceRange.txt[]

  * pname:aspectMask 是一个位掩码，表明该图像的哪个（些）aspect被视图所包含。参考 elink:VkImageAspectFlagBits.
  * pname:baseMipLevel 是视图可以访问的第一个mipmap层级。
  * pname:levelCount 是视图可以访问的mipmap层级的数量（从pname:baseMipLevel开始）。
  * pname:baseArrayLayer 是视图可以访问的第一个array layer。
  * pname:layerCount 是视图可以访问的array layers 的数量（从 pname:baseArrayLayer开始）。

mipmap 层数和array layers的数量必须是图像中图像资源的子集。
如果一个应用程序想要使用在pname:baseMipLevel 或 pname:baseArrayLayer之后的所有的mipmap层或者图像的layer，
它可以设置pname:levelCount 和 pname:layerCount为特殊值 ename:VK_REMAINING_MIP_LEVELS 和
ename:VK_REMAINING_ARRAY_LAYERS，而不用知道mipmap层和layer的准确大小。

对于立方和cube array视图，图像视图的layer从pname:baseArrayLayer开始，依序分别对应+X, -X, +Y, -Y, +Z, -Z 面。
对于立方体 arrays，六个连续层级的每一个都是单独的一个立方体，所以立方体map数组视图中的 立方体maps个数是 _pname:layerCount / 6_, 且
图像数组层级 _pname:baseArrayLayer + i_ 是立方体 _i / 6_ 的 _i mod 6_ 个面的索引。
若不管pname:layerCount中显式设置的值或者ename:VK_REMAINING_ARRAY_LAYERS指定的值，视图中层级的数量不是6的倍数，
索引最后一个立方体的行为是未定义的。

pname:aspectMask 是一个位掩码，表明了被使用的格式。bit位包括如下：

// refBegin VkImageAspectFlagBits Bitmask specifying which aspects of an image are included in a view
include::../api/enums/VkImageAspectFlagBits.txt[]

若pname:format 是一个颜色，depth-only或 stencil-only 格式，那么此掩码必须对应的是 ename:VK_IMAGE_ASPECT_COLOR_BIT,
ename:VK_IMAGE_ASPECT_DEPTH_BIT或 ename:VK_IMAGE_ASPECT_STENCIL_BIT。
若使用一个 depth/stencil 格式的 depth 和 stencil 成员，pname:aspectMask 必须至少包含
ename:VK_IMAGE_ASPECT_DEPTH_BIT 和 ename:VK_IMAGE_ASPECT_STENCIL_BIT其中一个，或全都包含。

When using an imageView of a depth/stencil image to populate a descriptor
set (e.g. for sampling in the shader,或 for use as an input attachment),
the pname:aspectMask 必须 only include one bit and selects whether the
imageView is used for depth reads (i.e. using a floating-point sampler或
input attachment in the shader)或 stencil reads (i.e. using an unsigned
integer sampler或 input attachment in the shader).
When an imageView of a depth/stencil image is used as a depth/stencil
framebuffer attachment, the pname:aspectMask is ignored and both depth and
stencil image subresources are used.

pname:components 成员是slink:VkComponentMapping类型的，且描述了
从该图像的成员 重映射到 着色器图像指令返回的数组的成员。

这个重映射必须对storage image descriptors, input
attachment descriptors, 和 framebuffer attachments来说是完全一致的。

.Valid Usage
****
  * 若pname:levelCount is not ename:VK_REMAINING_MIP_LEVELS,
    [eq]#pname:levelCount# 必须 be non-zero and [eq]#(pname:baseMipLevel
    {plus} pname:levelCount)# 必须 be小于或 等于 the
    pname:mipLevels specified in slink:VkImageCreateInfo when该图像 was
    created
ifndef::VK_KHR_maintenance1[]
  * 若pname:layerCount is not ename:VK_REMAINING_ARRAY_LAYERS,
    [eq]#pname:layerCount# 必须 be non-zero and [eq]#(pname:baseArrayLayer
    + pname:layerCount)# 必须 be小于或 等于 the
    pname:arrayLayers specified in slink:VkImageCreateInfo when该图像
    was created
endif::VK_KHR_maintenance1[]
ifdef::VK_KHR_maintenance1[]
  * 若the pname:imageType specified in slink:VkImageCreateInfo when the
    image was created was ename:VK_IMAGE_TYPE_3D and该图像 view is
    created with the pname:viewType of slink:VkImageViewCreateInfo set to
    ename:VK_VIEW_TYPE_2D_ARRAY then pname:layerCount 必须 be
    ename:VK_REMAINING_ARRAY_LAYERS,或 [eq]#pname:layerCount# 必须 be
    non-zero and [eq]#(pname:baseArrayLayer + pname:layerCount)# 必须 be
   小于或 等于 the pname:extent.depth specified in
    slink:VkImageCreateInfo when该图像 was created
  * 若the pname:imageType specified in slink:VkImageCreateInfo when the
    image was created was not ename:VK_IMAGE_TYPE_3D或该图像 view is
    not created with the pname:viewType of slink:VkImageViewCreateInfo set
    to ename:VK_VIEW_TYPE_2D_ARRAY then pname:layerCount 必须 be
    ename:VK_REMAINING_ARRAY_LAYERS,或 [eq]#pname:layerCount# 必须 be
    non-zero and [eq]#(pname:baseArrayLayer + pname:layerCount)# 必须 be
   小于或 等于 the pname:arrayLayers specified in
    slink:VkImageCreateInfo when该图像 was created
endif::VK_KHR_maintenance1[]


****

include::../validity/structs/VkImageSubresourceRange.txt[]

// refBegin VkComponentMapping Structure specifying a color component mapping

sname:VkComponentMapping 类型数据结构定义如下：

include::../api/structs/VkComponentMapping.txt[]

  * pname:r 决定了输出向量中R成员的值。
  * pname:g 决定了输出向量中G成员的值。
  * pname:b 决定了输出向量中B成员的值。
  * pname:a 决定了输出向量中A成员的值。

pname:r, pname:g, pname:b, and pname:a 其一的值都是如下的一个:

// refBegin VkComponentSwizzle Specify how a component is swizzled
include::../api/enums/VkComponentSwizzle.txt[]

  * ename:VK_COMPONENT_SWIZZLE_IDENTITY: 此成员被设置为各自的值。
  * ename:VK_COMPONENT_SWIZZLE_ZERO: 此成员被设置为0。
  * ename:VK_COMPONENT_SWIZZLE_ONE: t此成员被设置为 1或 1.0，取决于该图像视图格式的类型是整型还是浮点型，如
    <<features-formats-definition,Format Definition>> 小节中每种 elink:VkFormat所描述。
  * ename:VK_COMPONENT_SWIZZLE_R: 此成员被设置到该图像的R成员。
  * ename:VK_COMPONENT_SWIZZLE_G: 此成员被设置到该图像的G成员。
  * ename:VK_COMPONENT_SWIZZLE_B: 此成员被设置到该图像的B成员。
  * ename:VK_COMPONENT_SWIZZLE_A: 此成员被设置到该图像的A成员。


Setting the identity swizzle on a component is equivalent to setting the
identity mapping on that component.
That is:

[[resources-image-views-identity-mappings]]
.Component Mappings Equivalent To ename:VK_COMPONENT_SWIZZLE_IDENTITY
[options="header"]
|====
| Component          | Identity Mapping
| pname:components.r | ename:VK_COMPONENT_SWIZZLE_R
| pname:components.g | ename:VK_COMPONENT_SWIZZLE_G
| pname:components.b | ename:VK_COMPONENT_SWIZZLE_B
| pname:components.a | ename:VK_COMPONENT_SWIZZLE_A
|====

include::../validity/structs/VkComponentMapping.txt[]

// refBegin vkDestroyImageView Destroy an image view object

可调用下列命令来销毁图像视图：

include::../api/protos/vkDestroyImageView.txt[]

  * pname:device 是销毁图像视图的逻辑设备。
  * pname:imageView 是需要被销毁的图像视图。
  * pname:pAllocator 控制CPU端内存分配，如 <<memory-allocation, 内存分配 >> 一章详述。

.Valid Usage
****
  * 所有指向pname:imageView 的被提交的命令 必须已经完成执行。
  * 若当创建 pname:imageView 时提供了 sname:VkAllocationCallbacks，那么此处必须提供兼容的回调函数。
  * 若当创建  pname:imageView时没有提供sname:VkAllocationCallbacks ，那么此处 pname:pAllocator 必须为 `NULL`
****

include::../validity/protos/vkDestroyImageView.txt[]


[[resources-association]]
== 资源内存关联

资源初始都是以_虚拟分配_ 的方式创建的，并不占内存。
设备内存被单独分配（参看<<memory-device>>），然后再和资源关联上。
这个关联操作对于稀疏、非稀疏资源来说是不同的。

任何以稀疏标志创建资源都被认为是稀疏资源。
以这些标志之外的标志创建的资源被认为是非稀疏资源。
关于稀疏资源的内存关联在 <<sparsememory>>中有描述。

在资源被当作参数传递到以下任何一个操作之前，非稀疏资源必须完全并连续的绑定到一个sname:VkDeviceMemory 对象：

  * 创建图像或者缓冲区视图
  * 更新描述符集合
  * 在命令缓冲区中记录命令

一旦绑定了，内存绑定在资源的生命周期内就是不变的。

// refBegin vkGetBufferMemoryRequirements Returns the memory requirements for specified Vulkan object

想要知道一个缓冲区资源的内存限制条件，可调用：

include::../api/protos/vkGetBufferMemoryRequirements.txt[]

  * pname:device 是持有缓冲区的逻辑设备。
  * pname:buffer 被查询的缓冲区。
  * pname:pMemoryRequirements 指向一个 slink:VkMemoryRequirements实例，装载了被返回的内存限制条件信息。

include::../validity/protos/vkGetBufferMemoryRequirements.txt[]

// refBegin vkGetImageMemoryRequirements Returns the memory requirements for specified Vulkan object

想要知道图像资源内存限制条件，可调用：

include::../api/protos/vkGetImageMemoryRequirements.txt[]

  * pname:device 是拥有该图像的逻辑设备。
  * pname:image 是被查询的图像。
  * pname:pMemoryRequirements 指向了一个slink:VkMemoryRequirements是列，装载了该图像对象内存限制条件信息。

include::../validity/protos/vkGetImageMemoryRequirements.txt[]

// refBegin VkMemoryRequirements Structure specifying memory requirements

sname:VkMemoryRequirements类型数据结构定义如下：

include::../api/structs/VkMemoryRequirements.txt[]

  * pname:size 该资源所需的内存分配的大小，以字节为单位。
  * pname:alignment 是资源所要求的内存分配的对齐大小，以字节为单位。
  * pname:memoryTypeBits 是一个标志位，每一bit表示每一个受支持的内存类型。但是，
  只有当 `i` 在物理设备支持的内存类型 sname:VkPhysicalDeviceMemoryProperties中的时候，`i` 才会被设置。

include::../validity/structs/VkMemoryRequirements.txt[]

Vulkan实现保证关于内存限制条件的某些属性通过flink:vkGetBufferMemoryRequirements 和
flink:vkGetImageMemoryRequirements返回：

  * pname:memoryTypeBits 成员总是至少包含一个被设置的bit位。
  * 若pname:buffer 是一个在创建时没有带有
    ename:VK_BUFFER_CREATE_SPARSE_BINDING_BIT 的sname:VkBuffer，或者若pname:image是在创建时
    sname:VkImageCreateInfo的pname:tiling 成员带有 ename:VK_IMAGE_TILING_LINEAR
    的sname:VkImage，那么此pname:memoryTypeBits成员总是至少包含一个被设置的bit位，对应一个带有pname:propertyFlags的
    sname:VkMemoryType，该pname:propertyFlags的
    ename:VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT bit 和 ename:VK_MEMORY_PROPERTY_HOST_COHERENT_BIT bit 都被设置。
    换言之，可映射的一致性内存可以总是被附着到这些对象上。
  * pname:memoryTypeBits 成员总是至少包含一个被设置的bit位，对应着带有一个pname:propertyFlags的sname:VkMemoryType ，
    该pname:propertyFlags 的ename:VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT bit 被设置。
  * pname:memoryTypeBits 成员和所有的 创建时传递给fname:vkCreateBuffer的 sname:VkBufferCreateInfo中
    带有相同 pname:flags and pname:usage的sname:VkBuffer 对象相同，
    Further, if code:usage1 and code:usage2 of type elink:VkBufferUsageFlags
    are such that the bits set in code:usage2 are a subset of the bits set
    in code:usage1, and they have the same pname:flags, then the bits set in
    pname:memoryTypeBits returned for code:usage1 必须 be a subset of the
    bits set in pname:memoryTypeBits returned for code:usage2, for all
    values of pname:flags.
  * pname:alignment 成员值是2的幂。
  * pname:alignment 成员与 传递给name:vkCreateBuffer的sname:VkBufferCreateInfo数据结构的成员pname:usage 和
    pname:flags 的相同bit组合 而创建的所有 sname:VkBuffer 对象 相同。
  * 对于被创建时带有一个颜色格式的图像， pname:memoryTypeBits 成员与
    创建时传递给fname:vkCreateImage的sname:VkImageCreateInfo 数据结构中的pname:tiling成员，
    pname:flags成员的ename:VK_IMAGE_CREATE_SPARSE_BINDING_BIT bit和 name:usage成员的 ename:VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT
    的组合相同 所有的sname:VkImage 对象完全一致。
  * 对于被创建时带有一个depth/stencil 格式的图像， pname:memoryTypeBits
    成员与 创建时传递给 fname:vkCreateImage函数的sname:VkImageCreateInfo数据结构的 pname:format 成员、pname:tiling成员，  pname:flags 成员的
    ename:VK_IMAGE_CREATE_SPARSE_BINDING_BIT bit、pname:usage 成员的ename:VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT 的组合值相同的
    所有 sname:VkImage 对象。
  * 若内存要求是为sname:VkImage准备的，pname:memoryTypeBits 成员必须不能指代一个 pname:propertyFlags的
    ename:VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT bit 被设置的sname:VkMemoryType，若传递给fname:vkCreateImage的数据结构的 sname:VkImageCreateInfo的
    flink:vkGetImageMemoryRequirements::pname:image的成员pname:usage的
    ename:VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT bit  没有被设置。
  * 若内存要求是为sname:VkBuffer准备的，
    pname:memoryTypeBits 成员必须不能指代一个pname:propertyFlags中ename:VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT bit被设置的 sname:VkMemoryType。
+
--
[NOTE]
.注意
====
此要求的隐藏含义是 该惰性分配的内存不适用于所有情形的缓冲区。
====
--

// refBegin vkBindBufferMemory Bind device memory to a buffer object

把内存附着在一个缓冲区对象，可调用：

include::../api/protos/vkBindBufferMemory.txt[]

  * pname:device 是拥有该缓冲区和内存的逻辑设备。
  * pname:buffer 是缓冲区。
  * pname:memory 是一个 sname:VkDeviceMemory 类型对象，描述了需附着的设备内存。
  * pname:memoryOffset 是  pname:memory区域的起始偏移，该内存被绑定到缓冲区上。
    被返回的pname:memory的成员sname:VkMemoryRequirements::pname:size 带有的字节数，从pname:memoryOffset 开始的字节数，
	将被绑定到特定的缓冲区。

.Valid Usage
****
  * pname:buffer 本身不能是内存对象。
  * pname:buffer 被创建时不能带有稀疏内存绑定标识位。
  * pname:memoryOffset 必须小于pname:memory的大小。
  * 若创建pname:buffer 时带有
    ename:VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT或
    ename:VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT, pname:memoryOffset 必须是
    sname:VkPhysicalDeviceLimits::pname:minTexelBufferOffsetAlignment的倍数。
  * 若创建pname:buffer 时带有
    ename:VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT, pname:memoryOffset 必须是
    sname:VkPhysicalDeviceLimits::pname:minUniformBufferOffsetAlignment的倍数。
  * 若创建pname:buffer 时带有
    ename:VK_BUFFER_USAGE_STORAGE_BUFFER_BIT, pname:memoryOffset 必须是
    sname:VkPhysicalDeviceLimits::pname:minStorageBufferOffsetAlignment的倍数。
  * pname:memory 被分配时必须使用
    以pname:buffer为参数调用fname:vkGetBufferMemoryRequirements而返回的 sname:VkMemoryRequirements 数据结构的pname:memoryTypeBits成员中被允许的内存类型。
  * pname:memoryOffset 必须是一个
    以 pname:buffer为参数调用 fname:vkGetBufferMemoryRequirements 而返回的 sname:VkMemoryRequirements 数据结构pname:alignment成员 的倍数的正整数。
  * 以pname:buffer为参数调用fname:vkGetBufferMemoryRequirements 而返回的 sname:VkMemoryRequirements 数据结构的pname:size 成员
     必须 小于或 等于 pname:memory减去 pname:memoryOffset之差。
ifdef::VK_NV_dedicated_allocation[]
  * 若创建pname:buffer 时带有
    sname:VkDedicatedAllocationBufferCreateInfoNV::pname:dedicatedAllocation
    为 ename:VK_TRUE, pname:memory 必须在创建时
    sname:VkDedicatedAllocationMemoryAllocateInfoNV::pname:buffer 等于
    pname:buffer 且 pname:memoryOffset 必须为0
  * 若pname:buffer 被创建时
    sname:VkDedicatedAllocationBufferCreateInfoNV::pname:dedicatedAllocation
    等于 ename:VK_TRUE, pname:memory 不能为特定的 缓冲区或图像而分配。
endif::VK_NV_dedicated_allocation[]
****

include::../validity/protos/vkBindBufferMemory.txt[]

// refBegin vkBindImageMemory Bind device memory to an image object

把内存附着到一个图像对象上，可调用：

include::../api/protos/vkBindImageMemory.txt[]

  * pname:device 是拥有该图像和内存的逻辑设备。
  * pname:image 是图像。
  * pname:memory 是一个sname:VkDeviceMemory对象，描述了需被附着的设备内存。
  * pname:memoryOffset 绑定到该图像的内存的区域的起始偏移。
    pname:memory的sname:VkMemoryRequirements::pname:size 成员里被返回的字节数量，从pname:memoryOffset 字节开始，
    将被绑定到特定的图像。

.Valid Usage
****
  * pname:image 实际内存不能是内存对象。
  * pname:image 被创建是不能带有稀疏内存绑定flags。
  * pname:memoryOffset 必须小于 pname:memory的大小。
  * pname:memory 必须在创建时使用
    以 pname:image为参数调用 fname:vkGetImageMemoryRequirements 而返回的 sname:VkMemoryRequirements数据结构的pname:memoryTypeBits成员中被允许的内存类型之一。
  * pname:memoryOffset 必须是
    以 pname:image为参数调用 fname:vkGetImageMemoryRequirements 而返回的 sname:VkMemoryRequirements数据结构的 pname:alignment成员的正整数倍。
  * 以pname:image为参数调用fname:vkGetImageMemoryRequirements 而返回的 sname:VkMemoryRequirements数据结构的pname:size 成员
     必须 小于或 等于  pname:memory 减去 pname:memoryOffset之差。
ifdef::VK_NV_dedicated_allocation[]
  * 若pname:image 被创建时
    sname:VkDedicatedAllocationImageCreateInfoNV::pname:dedicatedAllocation
    等于 ename:VK_TRUE, pname:memory 在创建时必须 满足
    sname:VkDedicatedAllocationMemoryAllocateInfoNV::pname:image 等于
    pname:image 且 pname:memoryOffset 必须为0
  * 若pname:image 被创建时满足
    sname:VkDedicatedAllocationImageCreateInfoNV::pname:dedicatedAllocation
    等于 ename:VK_TRUE, pname:memory 在创建时必须是专为特定的缓冲区 或 图像准备的。
endif::VK_NV_dedicated_allocation[]
****

include::../validity/protos/vkBindImageMemory.txt[]

[[resources-bufferimagegranularity,Buffer-Image Granularity]]
.Buffer-Image Granularity
There is an implementation-dependent limit, pname:bufferImageGranularity,
which specifies a page-like granularity at which buffer, linear image and
optimal image resources 必须 be placed in adjacent memory locations to
avoid aliasing.
Two resources which do not satisfy this granularity requirement are said to
<<resources-memory-aliasing,alias>>.
Linear image resource are images created with ename:VK_IMAGE_TILING_LINEAR
and optimal image resources are those created with
ename:VK_IMAGE_TILING_OPTIMAL.
pname:bufferImageGranularity is specified in bytes, and 必须 be a power of
two.
Implementations which do not require such an additional granularity may:
report a value of one.

[NOTE]
.注意
====
pname:bufferImageGranularity is really a granularity between "linear"
resources, including buffers and images with linear tiling, vs.
"optimal" resources, i.e. images with optimal tiling.
It would have been better named "linearOptimalGranularity".
====

Given resourceA at the lower memory offset and resourceB at the higher
memory offset in the same sname:VkDeviceMemory object, where one of the
resources is a buffer或 a linear image and the other is an optimal image,
and the following:

[source,c]
---------------------------------------------------
resourceA.end       = resourceA.memoryOffset + resourceA.size - 1
resourceA.endPage   = resourceA.end & ~(bufferImageGranularity-1)
resourceB.start     = resourceB.memoryOffset
resourceB.startPage = resourceB.start & ~(bufferImageGranularity-1)
---------------------------------------------------

The following property 必须 hold:

[source,c]
---------------------------------------------------
resourceA.endPage < resourceB.startPage
---------------------------------------------------

That is, the end of the first resource (A) and the beginning of the second
resource (B) 必须 be on separate "`pages`" of size
pname:bufferImageGranularity.
pname:bufferImageGranularity may: be different than the physical page size
of the memory heap.
This restriction is only needed when a buffer或 a linear image is at
adjacent memory location with an optimal image and both will被用于
simultaneously.
Adjacent buffers'或 adjacent images' memory ranges可以 be closer than
pname:bufferImageGranularity, provided they meet the pname:alignment
requirement for the objects in question.

Sparse block size in bytes and sparse image and buffer memory alignments
必须 all be multiples of the pname:bufferImageGranularity.
Therefore, memory bound to sparse resources naturally satisfies the
pname:bufferImageGranularity.

[[resources-sharing]]
== 资源共享模式

// refBegin VkSharingMode Buffer and image sharing modes

缓冲区和图像对象能以 _共享模式_ 被创建，控制它们如何被队列访问。
受支持的共享模式如下：

include::../api/enums/VkSharingMode.txt[]

  * ename:VK_SHARING_MODE_EXCLUSIVE specifies that access to any range或
    image subresource of the object will be exclusive to a single queue
    family at a time.
  * ename:VK_SHARING_MODE_CONCURRENT specifies that concurrent access to any
    range或 image subresource of the object from multiple queue families is
    supported.

[NOTE]
.注意
====
与ename:VK_SHARING_MODE_EXCLUSIVE相比，ename:VK_SHARING_MODE_CONCURRENT 也许会导致访问缓冲区或者图像时效率较低。
====

Ranges of buffers and image subresources of image objects created using
ename:VK_SHARING_MODE_EXCLUSIVE 必须 only be accessed by queues in the same
queue family at any given time.
In或der for a different queue family to be able to interpret the memory
contents of a range或 image subresource, the application 必须 perform a
<<synchronization-queue-transfers,queue family ownership transfer>>.

Upon creation, resources using ename:VK_SHARING_MODE_EXCLUSIVE are not owned
by any queue family.
A buffer或 image memory barrier is not required to acquire _ownership_ when
no queue family owns the resource - it is implicitly acquired upon first use
within a queue.

[NOTE]
.注意
====
Images still require a <<resources-image-layouts, layout transition>> from
ename:VK_IMAGE_LAYOUT_UNDEFINED或 ename:VK_IMAGE_LAYOUT_PREINITIALIZED
before being used on the first queue.
====

A queue family可以 take ownership of an image subresource或 buffer range
of a resource created with ename:VK_SHARING_MODE_EXCLUSIVE, without an
ownership transfer, in the same way as for a resource that was just created;
however, taking ownership in this way has the effect that the contents of
the image subresource或 buffer range are undefined.

Ranges of buffers and image subresources of image objects created using
ename:VK_SHARING_MODE_CONCURRENT 必须 only be accessed by queues from the
queue families specified through the pname:queueFamilyIndexCount and
pname:pQueueFamilyIndices members of the corresponding create info
structures.

// refEnd VkSharingMode


[[resources-memory-aliasing]]
== 内存别名

sname:VkDeviceMemory 内存的一段区间可以被称为 _aliased_（被别名），若它通过 flink:vkBindImageMemory，
flink:vkBindBufferMemory，或者通过<<sparsememory-resource-binding,稀疏内存绑定>>，被同时绑定到多个资源上。
在两个图像或者两个缓冲区之间的 一段别名内存区间，其定义是：在绑定到两个资源上的内存的一段内存区间。
在两个资源之间（一个是缓冲区或者线性图像，另一个是优化图像）的 一个内存区间别名，其他定义是 绑定到两个资源的内存区间的
相交区域。每个区间首先被填补并按照pname:bufferImageGranularity 对齐。
应用程序可以给内存起别名，但是使用多个别名需要遵循多个限制条件。


[NOTE]
.注意
====
如果一些大型的资源被用于不连续的阶段，内存别名可以有效的减少应用程序中设备内存使用痕迹。
====

当一个不透明，非 ename:VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT 图像被绑定到一个别名区间，图像所有的
图像子资源 在区间上重叠。
当一个线性图像被绑定到一个别名区间，包含 别名区间的图像子资源（遵顼图像被建议的布局方式）将重叠该区域。
当一个 ename:VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT 图像有稀疏图像块被绑定一个别名区间上，
只有包含这些稀疏图像块的图像子资源会重叠该区间，且当内存被绑定到图像的mip tail与别名区间重叠时，mip tail中的图像子资源
将重叠该区间。

在ename:VK_IMAGE_LAYOUT_PREINITIALIZED 或者 ename:VK_IMAGE_LAYOUT_GENERAL
布局的缓冲区，线性图像子资源，都是  _host-accessible subresources_。
亦即，只有host端能够正确的寻址，并解释其内容，故若这些别名时是host-accessible 子资源，内存中数据的布局可以通过别名被一致性的解释。
其他布局下的不透明图像和图像子资源，不是host-accessible。

若两个别名都是both host-accessible，那么它们使用一致的方式去解读内存的内容，且写入到别名内的数据可以被另外一个别名读取。


若两个别名都不是host-accessible，那么别名依不同的方式解读内存的内容，通过一个别名写入的内容对于另外一个别名来说也是部分或全未定义的。
若第一个别名是 host-accessible 子资源，那么受影响的字节，是那些通过它的寻址方式内存操作写入的部分。
若第一个别名不能被主机端访问，那么被影响的字节是那些被写入的图像子资源重叠的部分。
若第二个别名是不能被主机端访问的子资源，那么被影响的字节将变得未定义。
若第二个别名不能被主机端访问，所有的稀疏图像块（为稀疏部分驻留图像）或者所有的图像子资源（为非稀疏图像和全驻留稀疏图像）重叠的字节将变得未定义。

若因为写入alias而导致任何图像子资源变成未定义的，那么
图像子资源的每一个必须让它被使用之前从它的布局从
ename:VK_IMAGE_LAYOUT_UNDEFINED 转换到一个有效的布局， 或者若内存已经被host端写入，需要从
ename:VK_IMAGE_LAYOUT_PREINITIALIZED 转换到一个有效布局。
若稀疏图像的任何稀疏块已经变成未定义的，那么只有包含它们的图像子资源 必须被转换。

两个alias使用一分重叠区间 必须通过使用合适的 <<synchronization-access-types, access
types>>的内存依赖 来分割，若至少 其中一个使用操作写入，不管alias持续终端内存与否。
若缓冲区或 图像内存屏障被使用来，屏障的周期必须包含整个区间，和/或 重叠的图像子资源的集合。 

若在同一个缓冲区中使用两个别名图像视图，那么render pass 必须使用 <<renderpass-aliasing,ename:VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT>>
声明附件，且必须符合该节中其他的规则。

在着色器中使用 code:Coherent修饰的变量来访问别名内存的资源，将不会自动保持一致性。

[NOTE]
.注意
====
Memory recycled via an application suballocator (i.e. without freeing and
reallocating the memory objects) is not substantially different from memory
aliasing.
However, a suballocator usually waits on a fence before recycling a region
of memory, and signaling a fence involves sufficient implicit dependencies
to satisfy all the above requirements.
====
