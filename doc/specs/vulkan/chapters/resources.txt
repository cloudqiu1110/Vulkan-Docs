// Copyright (c) 2015-2017 The Khronos Group Inc.
// Copyright notice at https://www.khronos.org/registry/speccopyright.html

[[resources]]
= 资源的创建

Vulkan支持两种主要的资源类型： _缓冲区_ 和 _图像_。
资源是带有关联格式、维度信息的内存视图。
缓冲区是未格式化字节数组，图像包含格式化信息，可以是多维的，也能有关联的元数据。


[[resources-buffers]]
== 缓冲区

// refBegin VkBuffer Opaque handle to a buffer object

缓冲区表示线性数组数据，通过描述符集合或特定命令或直接指定它们作为特定命令的参数
绑定到图形或者计算管线被用于各种目的。

缓冲区由 sname:VkBuffer 类型handle表示：

include::../api/handles/VkBuffer.txt[]

// refEnd VkBuffer

// refBegin vkCreateBuffer Create a new buffer object

可调用如下命令来创建缓冲区：

include::../api/protos/vkCreateBuffer.txt[]

  * pname:device 是创建缓冲区对象的逻辑设备。
  * pname:pCreateInfo 是一个指向 sname:VkBufferCreateInfo 类型实例的指针，包含了影响创建缓冲区的参数。
  * pname:pAllocator 控制主机端内存分配，如 <<memory-allocation, 内存分配>>章所讲。
  * pname:pBuffer 指向一个 sname:VkBuffer handle，生成的缓冲区对象以此被返回。

.Valid Usage
****
  * 若 pname:pCreateInfo 的成员pname:flags 包含 ename:VK_BUFFER_CREATE_SPARSE_BINDING_BIT，创建这个 sname:VkBuffer
	不能导致在设备上当前有效的稀疏资源总体需求的稀疏内存  超过
    sname:VkPhysicalDeviceLimits::pname:sparseAddressSpaceSize
****

include::../validity/protos/vkCreateBuffer.txt[]

// refBegin VkBufferCreateInfo Structure specifying the parameters of a newly created buffer object

sname:VkBufferCreateInfo 数据结构定义如下：

include::../api/structs/VkBufferCreateInfo.txt[]

  * pname:sType 是这个数据结构的类型。
  * pname:pNext 是 `NULL` 或者一个  extension-specific 数据结构的指针。
  * pname:flags 是一个位掩码，描述了缓冲区的附加参数。参看下方受支持的 elink:VkBufferCreateFlagBits 描述。
  * pname:size 是将被创建的缓冲区的字节数。
  * pname:usage  是一个 bitmask，描述了缓冲区被允许的使用方式。
    参考 如下 elink:VkBufferUsageFlagBits 受支持的bit。
  * pname:sharingMode 是缓冲区被多个队列族访问时的共享模式，参考
    <<resources-sharing,Resource Sharing>> 小节中 elink:VkSharingMode 给出的受支持的值。
  * pname:queueFamilyIndexCount 是 pname:pQueueFamilyIndices 数组中的元素个数。
  * pname:pQueueFamilyIndices 是一些队列族，它们将访问这个缓冲区 (ignored if pname:sharingMode is not
    ename:VK_SHARING_MODE_CONCURRENT)。

pname:usage 中可以设置的bit如下：

// refBegin VkBufferUsageFlagBits Bitmask specifying allowed usage of a buffer
include::../api/enums/VkBufferUsageFlagBits.txt[]

  * ename:VK_BUFFER_USAGE_TRANSFER_SRC_BIT 表明缓冲区可以被用作  _transfer command_ 的源 
   (参看 <<synchronization-pipeline-stages-transfer,
    ename:VK_PIPELINE_STAGE_TRANSFER_BIT>>的定义).
  * ename:VK_BUFFER_USAGE_TRANSFER_DST_BIT 表明缓冲区可以被用作  转移名利的目标。    
  * ename:VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT 表明缓冲区可以被用于创建一个 sname:VkBufferView，其适于
    占用一个 ename:VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER类型的
    sname:VkDescriptorSet槽。   
  * ename:VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT  表明缓冲区可以被用于创建一个 sname:VkBufferView，其适于
    占用一个ename:VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER类型的  sname:VkDescriptorSet槽。    
  * ename:VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT 表明缓冲区可以被用在一个 sname:VkDescriptorBufferInfo中 ，其适于占用一个
    类型为    ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER 或者
    ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC的  sname:VkDescriptorSet 槽 。
  * ename:VK_BUFFER_USAGE_STORAGE_BUFFER_BIT 表明缓冲区可以被用于sname:VkDescriptorBufferInfo中，其适于占用一个类型为 
    ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER 或者
    ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC sname:VkDescriptorSet  槽。
  * ename:VK_BUFFER_USAGE_INDEX_BUFFER_BIT 表明此缓冲区适于被用作参数传递给
    fname:vkCmdBindIndexBuffer.
  * ename:VK_BUFFER_USAGE_VERTEX_BUFFER_BIT 表明此缓冲区适于被当作 pname:pBuffers 数组的一个元素 传递给
    fname:vkCmdBindVertexBuffers.
  * ename:VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT 表明此缓冲区适于被当作 pname:buffer 参数被传递给
    fname:vkCmdDrawIndirect, fname:vkCmdDrawIndexedIndirect, 或者
    fname:vkCmdDispatchIndirect.
ifdef::VK_NVX_device_generated_commands[]
    It is也 suitable for passing as the pname:buffer member of
    sname:VkIndirectCommandsTokenNVX,或 pname:sequencesCountBuffer或
    pname:sequencesIndexBuffer member of sname:VkCmdProcessCommandsInfoNVX
endif::VK_NVX_device_generated_commands[]

任何bit的组合 可以: 指定 pname:usage，但是至少其中一个必须被设置用于创建一个有效的缓冲区。

 pname:flags可以被设置的bit如下：

// refBegin VkBufferCreateFlagBits Bitmask specifying additional parameters of a buffer
include::../api/enums/VkBufferCreateFlagBits.txt[]

这些bit的意义如下：

  * ename:VK_BUFFER_CREATE_SPARSE_BINDING_BIT 表示缓冲区将使用稀疏内存绑定来实现。    
  * ename:VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT 表示缓冲区可以部分使用稀疏内存绑定实现。使用此flag创建的缓冲区也可以通过
     ename:VK_BUFFER_CREATE_SPARSE_BINDING_BIT flag来创建。
  * ename:VK_BUFFER_CREATE_SPARSE_ALIASED_BIT 表示缓冲区将使用稀疏内存绑定来实现，内存区间可能也同时存储其他缓冲区的内容
     或者同一个缓冲区的其他部分。使用此flag创建的缓冲区也可以使用 ename:VK_BUFFER_CREATE_SPARSE_BINDING_BIT flag来创建。

参看 <<sparsememory-sparseresourcefeatures,Sparse Resource Features>> 和 <<features-features,Physical Device Features>> 来
获取设备支持的稀疏内存特性的其他细节。

.Valid Usage
****
  * pname:size 必须: 比 `0` 要大
  * 若 pname:sharingMode 是 ename:VK_SHARING_MODE_CONCURRENT，
    pname:pQueueFamilyIndices 必须: 是一个指针，指向一个类型为basetype:uint32_t 的 pname:queueFamilyIndexCount  值。
  * 若 pname:sharingMode 是 ename:VK_SHARING_MODE_CONCURRENT，
    pname:queueFamilyIndexCount 必须: 大于`1`
  * 若<<features-features-sparseBinding,sparse bindings>> 特征没有被启用，pname:flags 不能: 包含
    ename:VK_BUFFER_CREATE_SPARSE_BINDING_BIT
  * 若 <<features-features-sparseResidencyBuffer,sparse buffer
    residency>> 特征没有被启用， pname:flags 不能: 包含
    ename:VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT
  * 若 <<features-features-sparseResidencyAliased,sparse aliased
    residency>> 特征没有被启用，pname:flags 不能: 包含
    ename:VK_BUFFER_CREATE_SPARSE_ALIASED_BIT
  * 若 pname:flags 包含 ename:VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT 或者
    ename:VK_BUFFER_CREATE_SPARSE_ALIASED_BIT，它 必须: 也包含 ename:VK_BUFFER_CREATE_SPARSE_BINDING_BIT
****

include::../validity/structs/VkBufferCreateInfo.txt[]

ifdef::VK_NV_dedicated_allocation[]

// refBegin VkDedicatedAllocationBufferCreateInfoNV Specify that a buffer is bound to a dedicated memory resource

若pname:pNext 列表包含一个sname:VkDedicatedAllocationBufferCreateInfoNV 数据结构，那么该数据结构包含一个使用控制开关，
控制缓冲区是否将有专用的内存绑定给它。

sname:VkDedicatedAllocationBufferCreateInfoNV 数据结构定义如下：

include::../api/structs/VkDedicatedAllocationBufferCreateInfoNV.txt[]

  * pname:sType 是这个数据结构的类型。
  * pname:pNext 是 `NULL` 或者一个指向 拓展特定的数据结构的指针。
  * pname:dedicatedAllocation 表示缓冲区是否将有专门分配的内存绑定到它。

.Valid Usage
****
  * 若 pname:dedicatedAllocation 为 ename:VK_TRUE，
    sname:VkBufferCreateInfo::pname:flags 不能: 包含
    ename:VK_BUFFER_CREATE_SPARSE_BINDING_BIT,
    ename:VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT, 或者
    ename:VK_BUFFER_CREATE_SPARSE_ALIASED_BIT
****

include::../validity/structs/VkDedicatedAllocationBufferCreateInfoNV.txt[]

endif::VK_NV_dedicated_allocation[]

// refBegin vkDestroyBuffer Destroy a buffer object

可调用下面的命令来销毁缓冲区：

include::../api/protos/vkDestroyBuffer.txt[]

  * pname:device 是销毁缓冲区的逻辑设备。
  * pname:buffer 是需要被销毁的缓冲区。
  * pname:pAllocator 控制CPU端内存分配，如 <<memory-allocation, 内存分配 >> 一章详述。

.Valid Usage
****
  * 所有涉及到 pname:buffer的被提交的命令，要么直接，要么通过 sname:VkBufferView，必须: 已经完成了执行。
  * 若创建pname:buffer 时，提供了 sname:VkAllocationCallbacks，那么此处必须提供兼容的 callbacks 。
  * 若创建pname:buffer 时， 没有提供 sname:VkAllocationCallbacks，那么 pname:pAllocator 必须: 为 `NULL`
****

include::../validity/protos/vkDestroyBuffer.txt[]


[[resources-buffer-views]]
== 缓冲区视图

// refBegin VkBufferView Opaque handle to a buffer view object

一个 _缓冲区视图_ 代表 连续范围的一个缓冲区和用来解释数据的特定格式。
缓冲区视图被用来让着色器能访问按照某种格式解释的缓冲区内容。
为了创建一个有效的缓冲区视图，缓冲区必须已经被创建好了，且带有下面的至少一个使用方式标志位：

  * ename:VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT
  * ename:VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT

缓冲区视图通过 sname:VkBufferView 类型handle表示：

include::../api/handles/VkBufferView.txt[]

// refEnd VkBufferView

// refBegin vkCreateBufferView Create a new buffer view object

可调用下列命令来创建缓冲区视图：

include::../api/protos/vkCreateBufferView.txt[]

  * pname:device 是创建给缓冲区视图的逻辑设备。
  * pname:pCreateInfo 是一个指向 sname:VkBufferViewCreateInfo类型实例的指针，包含用来创建缓冲区对象的参数。
  * pname:pAllocator 控制CPU端内存分配，如 <<memory-allocation, 内存分配 >> 一章详述。
  * pname:pView 指向一个 sname:VkBufferView handle，它就是生成并被返回的缓冲区视图对象。

include::../validity/protos/vkCreateBufferView.txt[]

// refBegin VkBufferViewCreateInfo Structure specifying parameters of a newly created buffer view

sname:VkBufferViewCreateInfo 类型定义如下：

include::../api/structs/VkBufferViewCreateInfo.txt[]

  * pname:sType 是数据结构的类型。
  * pname:pNext 是 `NULL` 或者一个指向 拓展特定的数据结构的指针。
  * pname:flags 被保留使用。
  * pname:buffer 是视图创建所在的 sname:VkBuffer。
  * pname:format 是一个 elink:VkFormat，描述了缓冲区中数据元素的格式。
  * pname:offset 是一个偏移值，字节单位，从缓冲区的基础地址开始。着色器中访问缓冲区视图的地址都是对于起始偏移值的相对值。    
  * pname:range 是缓冲区视图的字节大小。
	若 pname:range 等于 ename:VK_WHOLE_SIZE, 从  pname:offset 开始到缓冲区结束的区间就被使用。
    若 ename:VK_WHOLE_SIZE 被使用，且缓冲区剩余的大小并不是 pname:format格式的元素的大小的倍数，
	那么就会使用最接近的较小的倍数。

.Valid Usage
****
  * pname:offset 必须: 小于 pname:buffer的大小
  * pname:offset 必须: 是 sname:VkPhysicalDeviceLimits::pname:minTexelBufferOffsetAlignment的倍数。
  * 若 pname:range 不等于 ename:VK_WHOLE_SIZE:
  ** pname:range 必须: 大于 `0`
  ** pname:range 必须: 是  pname:format格式元素大小的整数倍。
  ** pname:range 除以 pname:format格式元素的大小， 必须小于等于
     sname:VkPhysicalDeviceLimits::pname:maxTexelBufferElements
  **  pname:offset 与 pname:range 之和，必须: 小于等于 pname:buffer的大小
  * pname:buffer 必须: 在被创建时 pname:usage 值包含至少一个  ename:VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT 或者
    ename:VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT
  * 若创建 pname:buffer 时 pname:usage 包含
    ename:VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT， pname:format 必须: 被统一纹素缓冲区所支持， 如被
    ename:VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT flag所指定，该flag在
    fname:vkGetPhysicalDeviceFormatProperties返回的sname:VkFormatProperties::pname:bufferFeatures中。
  * 若创建 pname:buffer时，pname:usage 包含
    ename:VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT， pname:format 必须: 受统一纹素缓冲区所支持，如被    
    ename:VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT flag 所指定，该flag在
     fname:vkGetPhysicalDeviceFormatProperties返回的sname:VkFormatProperties::pname:bufferFeatures 中。   
  * 若 pname:buffer 是非稀疏的，那么它  必须: 被完全且连续的绑定到单个sname:VkDeviceMemory 对象。
****

include::../validity/structs/VkBufferViewCreateInfo.txt[]

// refBegin vkDestroyBufferView Destroy a buffer view object

可调用如下函数以销毁缓冲区视图：

include::../api/protos/vkDestroyBufferView.txt[]

  * pname:device 是销毁缓冲区视图的逻辑设备。
  * pname:bufferView 需要被销毁的缓冲区视图。
  * pname:pAllocator 控制CPU端内存分配，如 <<memory-allocation, 内存分配 >> 一章详述。

.Valid Usage
****
  * 所有涉及到name:bufferView的被提交的命令，必须: 已经完成执行。
  * 若创建pname:bufferView 时，提供了 sname:VkAllocationCallbacks，那么此处必须提供兼容的 callbacks 。    
  * 若创建pname:bufferView 时，没有提供 sname:VkAllocationCallbacks，那么 pname:pAllocator 必须: 为 `NULL`。 
****

include::../validity/protos/vkDestroyBufferView.txt[]


[[resources-images]]
== 图像

// refBegin VkImage Opaque handle to a image object

图像表示多维（最多3维）的数组数据，可用于各种目的（比如：附件，纹理），通过描述符集合把它们绑定到一个图形或者计算管线，
或者直接当作参数直接传递个某些命令。

图像通过sname:VkImage类型的handle表示：

include::../api/handles/VkImage.txt[]

// refEnd VkImage

// refBegin vkCreateImage Create a new image object

可调用下列命令来创建图像：

include::../api/protos/vkCreateImage.txt[]

  * pname:device 是创建图像的逻辑设备。
  * pname:pCreateInfo 是一个指针，指向一个 sname:VkImageCreateInfo 数据结构实例，它包含了创建图像所需的信息。
  * pname:pAllocator 控制CPU端内存分配，如 <<memory-allocation, 内存分配 >> 一章详述。
  * pname:pImage 指向已创建并返回的 sname:VkImage handle。

.Valid Usage
****
  * 若 pname:pCreateInfo的成员pname:flags 包含
    ename:VK_IMAGE_CREATE_SPARSE_BINDING_BIT，创建这个sname:VkImage 不能导致当前有效稀疏资源
	在总体需求的稀疏内存超过 sname:VkPhysicalDeviceLimits::pname:sparseAddressSpaceSize
****

include::../validity/protos/vkCreateImage.txt[]

// refBegin VkImageCreateInfo Structure specifying the parameters of a newly created image object

sname:VkImageCreateInfo 类型数据结构定义如下：

include::../api/structs/VkImageCreateInfo.txt[]

  * pname:sType 是数据结构的类型。
  * pname:pNext 是 `NULL` 或者一个指向 拓展特定的数据结构的指针。
  * pname:flags 是一个位掩码，描述了图像的附加参数。参考 如下elink:VkImageCreateFlagBits 关于受支持的bit描述。
  * pname:imageType 是一个 elink:VkImageType，指定了图像的基础维度，如下所描述。数组纹理的层次作为图像类别时并不能算作维度    
  * pname:format  是一个 elink:VkFormat ，描述了数据元素的格式与类型，数据包含在图像中。
  * pname:extent 是一个slink:VkExtent3D，描述了基础层次中每一个维度的元素的个数。
  * pname:mipLevels 描述了图向下采样的细节层次的个数。
  * pname:arrayLayers 是图像中的层数。
  * pname:samples 是图像中sub-data 元素采样的个数，其在elink:VkSampleCountFlagBits 中被定义。
    参考<<primsrast-multisampling,Multisampling>>。
  * pname:tiling是一个 elink:VkImageTiling，指定了内存中数据元素的tiling组织方式，如下所描述。
  * pname:usage 是一个 bitmask，描述图像的目标使用方式。参考如下的 elink:VkImageUsageFlagBits 支持的bit。
  * pname:sharingMode 是当多个队列族的访问时图像的共享模式， 且 必须: 是下一节的 <<resources-sharing,Resource
    Sharing>> 的elink:VkSharingMode 描述的值之一。
  * pname:queueFamilyIndexCount 是    pname:pQueueFamilyIndices 数组元素的个数。
  * pname:pQueueFamilyIndices 是一个队列族的列表，该队列族将访问此图像 (ignored if pname:sharingMode is not
    ename:VK_SHARING_MODE_CONCURRENT)。
  * pname:initialLayout 选择  此图像的所有图像子资源的  初始 elink:VkImageLayout 状态。
    参看 <<resources-image-layouts,Image Layouts>>。
    pname:initialLayout 必须: 是 ename:VK_IMAGE_LAYOUT_UNDEFINED 或者
    ename:VK_IMAGE_LAYOUT_PREINITIALIZED。

使用pname:tiling值为ename:VK_IMAGE_TILING_LINEAR 创建的图像，比使用pname:tiling值为ename:VK_IMAGE_TILING_OPTIMAL创建的图像由更多的限制。
使用 ename:VK_IMAGE_TILING_LINEAR 创建的图像可能不被支持，除非其他参数满足如下限制：


  * pname:imageType 是 ename:VK_IMAGE_TYPE_2D  
  * pname:format 不是 depth/stencil 格式
  * pname:mipLevels 是 1
  * pname:arrayLayers 是 1
  * pname:samples 是 ename:VK_SAMPLE_COUNT_1_BIT
  * pname:usage 只包含 ename:VK_IMAGE_USAGE_TRANSFER_SRC_BIT 和/或    ename:VK_IMAGE_USAGE_TRANSFER_DST_BIT

除了上面表格所列，Vulkan实现可能支持附加的限制条件和功能。

对于给定的 pname:format, pname:type, pname:tiling, pname:usage, and pname:flags组合方式的能力，可以通过调用 flink:vkGetPhysicalDeviceImageFormatProperties来
向Vulkan实现查询。
返回值可表示对于图像的该种组合方式是否受支持。
若支持， sname:VkImageFormatProperties 输出参数表示有效的 pname:samples bits和  pname:extent参数的限制的集合。

可调用如下函数来获知对于给定格式有效的标志位集合：

.Valid Usage
****
  * pname:format， pname:type，pname:tiling，pname:usage，和pname:flags 的组合 必须: 被支持，	
	若把对应的值传递到相对应的参数里，并调用fname:vkGetPhysicalDeviceImageFormatProperties ，其返回值为VK_SUCCESS 可表明支持。
  * 若 pname:sharingMode 是 ename:VK_SHARING_MODE_CONCURRENT，
    pname:pQueueFamilyIndices 必须: 是一个指向 a pointer to an array of元素类型为basetype:uint32_t ，元素个数为
	pname:queueFamilyIndexCount 的数组的指针。    
  * 若 pname:sharingMode 是 ename:VK_SHARING_MODE_CONCURRENT，
    pname:queueFamilyIndexCount 必须: 大于 `1`
  * pname:format 不能: 是 ename:VK_FORMAT_UNDEFINED
  *  pname:extent的成员pname:width, pname:height, 和 pname:depth  不能: 全大于`0`
  * pname:mipLevels 必须: 大于 `0`
  * pname:arrayLayers 必须: 大于 `0`
  * 若 pname:flags 包含 ename:VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT，
    pname:imageType 必须是 ename:VK_IMAGE_TYPE_2D
ifdef::VK_KHR_maintenance1[]
  * 若pname:flags包含s
    ename:VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT_KHR, pname:imageType must
    be ename:VK_IMAGE_TYPE_3D
endif::VK_KHR_maintenance1[]
  * 若 pname:imageType 是 ename:VK_IMAGE_TYPE_1D，pname:extent.width 必须:
    小于等于
    sname:VkPhysicalDeviceLimits::pname:maxImageDimension1D 或者
    sname:VkImageFormatProperties::pname:maxExtent.width (as returned by
    fname:vkGetPhysicalDeviceImageFormatProperties with pname:format,
    pname:type, pname:tiling, pname:usage, and pname:flags 等于 those in
    this structure) - 与值大的比较。
  * 若 pname:imageType 是 ename:VK_IMAGE_TYPE_2D 且 pname:flags 不包含
    ename:VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT，pname:extent.width
    和 pname:extent.height 必须: 小于等于
    sname:VkPhysicalDeviceLimits::pname:maxImageDimension2D, 或者
    sname:VkImageFormatProperties::pname:maxExtent.width/height (as returned
    by fname:vkGetPhysicalDeviceImageFormatProperties with pname:format,
    pname:type, pname:tiling, pname:usage, and pname:flags 等于 those in
    this structure) - 与值大的比较。
  * 若 pname:imageType 是 ename:VK_IMAGE_TYPE_2D 且 pname:flags 包含
    ename:VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT，pname:extent.width 且
    pname:extent.height 必须: 小于等于
    sname:VkPhysicalDeviceLimits::pname:maxImageDimensionCube, 或者
    sname:VkImageFormatProperties::pname:maxExtent.width/height (as returned
    by fname:vkGetPhysicalDeviceImageFormatProperties with pname:format,
    pname:type, pname:tiling, pname:usage, and pname:flags 等于 those in
    this structure) - 与值大的比较。
  * 若 pname:imageType 是 ename:VK_IMAGE_TYPE_2D 且 pname:flags 包含
    ename:VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT， pname:extent.width 且
    pname:extent.height 必须: 相等 且 pname:arrayLayers 必须: 大于等于 6
  * 若 pname:imageType 是 ename:VK_IMAGE_TYPE_3D，pname:extent.width,
    pname:extent.height 且 pname:extent.depth 必须: 小于等于 sname:VkPhysicalDeviceLimits::pname:maxImageDimension3D, 或者
    sname:VkImageFormatProperties::pname:maxExtent.width/height/depth (as
    returned by fname:vkGetPhysicalDeviceImageFormatProperties with
    pname:format, pname:type, pname:tiling, pname:usage, and pname:flags
    等于 those in this structure) - 与值大的比较。
  * 若 pname:imageType 是 ename:VK_IMAGE_TYPE_1D，  pname:extent.height
    和 pname:extent.depth 都 必须: 等于`1`
  * 若 pname:imageType 是 ename:VK_IMAGE_TYPE_2D， pname:extent.depth 必须: 等于 `1`
  * pname:mipLevels 必须: 小于等于
    [eq]#{lfloor}log~2~(max(pname:extent.width, pname:extent.height,
    pname:extent.depth)){rfloor} + 1#.
  * 若 pname:extent.width, pname:extent.height, 或者 pname:extent.depth 之中任意一个大于	  
    sname:VkPhysicalDeviceLimits::pname:maxImageDimension3D 中对等的名字的成员的数量， pname:mipLevels
    必须: 小于等于
    sname:VkImageFormatProperties::pname:maxMipLevels (as returned by
    fname:vkGetPhysicalDeviceImageFormatProperties with pname:format,
    pname:type, pname:tiling, pname:usage, and pname:flags 等于 those in
    this structure)
  * pname:arrayLayers 必须小于等于 sname:VkImageFormatProperties::pname:maxArrayLayers (as returned by
    fname:vkGetPhysicalDeviceImageFormatProperties with pname:format,
    pname:type, pname:tiling, pname:usage, and pname:flags 等于 those in
    this structure)
  * 若 pname:imageType 是 ename:VK_IMAGE_TYPE_3D， pname:arrayLayers 必须: 等于    `1`.
  * 若pname:samples 不是 ename:VK_SAMPLE_COUNT_1_BIT, pname:imageType
    必须 是 ename:VK_IMAGE_TYPE_2D, pname:flags 必须不能包含
    ename:VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT, pname:tiling 必须 be
    ename:VK_IMAGE_TILING_OPTIMAL, and pname:mipLevels 必须 be 等于 `1`
  * 若pname:usage 包含 ename:VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT,
    then bits other than ename:VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT,
    ename:VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT, and
    ename:VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT 必须 not be set
  * 若pname:usage 包含 ename:VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT,
    ename:VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT,
    ename:VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT,或
    ename:VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT, pname:extent.width 必须 be
   小于或 等于
    sname:VkPhysicalDeviceLimits::pname:maxFramebufferWidth
  * 若pname:usage 包含 ename:VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT,
    ename:VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT,
    ename:VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT,或
    ename:VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT, pname:extent.height 必须 be
   小于或 等于
    sname:VkPhysicalDeviceLimits::pname:maxFramebufferHeight
  * 若pname:usage 包含 ename:VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT,
    pname:usage 必须也包含至少 
    ename:VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT,
    ename:VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT,或
    ename:VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT中的一个。
  * pname:samples 必须是一个bit value，被设置到
    sname:VkImageFormatProperties::pname:sampleCounts，该数值可通过
    以等于此数据集结构中的 pname:format,
    pname:type, pname:tiling, pname:usage, and pname:flags  参数来调用
	   fname:vkGetPhysicalDeviceImageFormatProperties 返回。    
  * 若 <<features-features-textureCompressionETC2, ETC2 texture
    compression>> 特征没有被启用，pname:format 必须不能是
    ename:VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK,
    ename:VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK,
    ename:VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK,
    ename:VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK,
    ename:VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK,
    ename:VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK,
    ename:VK_FORMAT_EAC_R11_UNORM_BLOCK,
    ename:VK_FORMAT_EAC_R11_SNORM_BLOCK,
    ename:VK_FORMAT_EAC_R11G11_UNORM_BLOCK,或
    ename:VK_FORMAT_EAC_R11G11_SNORM_BLOCK
  * 若<<features-features-textureCompressionASTC_LDR,ASTC LDR texture
    compression>> 特征没有被启用，pname:format 必须不能是
    ename:VK_FORMAT_ASTC_4x4_UNORM_BLOCK,
    ename:VK_FORMAT_ASTC_4x4_SRGB_BLOCK,
    ename:VK_FORMAT_ASTC_5x4_UNORM_BLOCK,
    ename:VK_FORMAT_ASTC_5x4_SRGB_BLOCK,
    ename:VK_FORMAT_ASTC_5x5_UNORM_BLOCK,
    ename:VK_FORMAT_ASTC_5x5_SRGB_BLOCK,
    ename:VK_FORMAT_ASTC_6x5_UNORM_BLOCK,
    ename:VK_FORMAT_ASTC_6x5_SRGB_BLOCK,
    ename:VK_FORMAT_ASTC_6x6_UNORM_BLOCK,
    ename:VK_FORMAT_ASTC_6x6_SRGB_BLOCK,
    ename:VK_FORMAT_ASTC_8x5_UNORM_BLOCK,
    ename:VK_FORMAT_ASTC_8x5_SRGB_BLOCK,
    ename:VK_FORMAT_ASTC_8x6_UNORM_BLOCK,
    ename:VK_FORMAT_ASTC_8x6_SRGB_BLOCK,
    ename:VK_FORMAT_ASTC_8x8_UNORM_BLOCK,
    ename:VK_FORMAT_ASTC_8x8_SRGB_BLOCK,
    ename:VK_FORMAT_ASTC_10x5_UNORM_BLOCK,
    ename:VK_FORMAT_ASTC_10x5_SRGB_BLOCK,
    ename:VK_FORMAT_ASTC_10x6_UNORM_BLOCK,
    ename:VK_FORMAT_ASTC_10x6_SRGB_BLOCK,
    ename:VK_FORMAT_ASTC_10x8_UNORM_BLOCK,
    ename:VK_FORMAT_ASTC_10x8_SRGB_BLOCK,
    ename:VK_FORMAT_ASTC_10x10_UNORM_BLOCK,
    ename:VK_FORMAT_ASTC_10x10_SRGB_BLOCK,
    ename:VK_FORMAT_ASTC_12x10_UNORM_BLOCK,
    ename:VK_FORMAT_ASTC_12x10_SRGB_BLOCK,
    ename:VK_FORMAT_ASTC_12x12_UNORM_BLOCK,或
    ename:VK_FORMAT_ASTC_12x12_SRGB_BLOCK
  * 若 <<features-features-textureCompressionBC,BC texture compression>>
    特征没有被启用，pname:format 必须不能是
    ename:VK_FORMAT_BC1_RGB_UNORM_BLOCK, ename:VK_FORMAT_BC1_RGB_SRGB_BLOCK,
    ename:VK_FORMAT_BC1_RGBA_UNORM_BLOCK,
    ename:VK_FORMAT_BC1_RGBA_SRGB_BLOCK, ename:VK_FORMAT_BC2_UNORM_BLOCK,
    ename:VK_FORMAT_BC2_SRGB_BLOCK, ename:VK_FORMAT_BC3_UNORM_BLOCK,
    ename:VK_FORMAT_BC3_SRGB_BLOCK, ename:VK_FORMAT_BC4_UNORM_BLOCK,
    ename:VK_FORMAT_BC4_SNORM_BLOCK, ename:VK_FORMAT_BC5_UNORM_BLOCK,
    ename:VK_FORMAT_BC5_SNORM_BLOCK, ename:VK_FORMAT_BC6H_UFLOAT_BLOCK,
    ename:VK_FORMAT_BC6H_SFLOAT_BLOCK, ename:VK_FORMAT_BC7_UNORM_BLOCK,或
    ename:VK_FORMAT_BC7_SRGB_BLOCK
  * 若<<features-features-shaderStorageImageMultisample,multisampled
    storage images>> 特征没有被启用，且pname:usage包含
    ename:VK_IMAGE_USAGE_STORAGE_BIT, pname:samples 必须是
    ename:VK_SAMPLE_COUNT_1_BIT
  * 若<<features-features-sparseBinding,sparse bindings>> 特征没有被启用，pname:flags 必须 不能包含
    ename:VK_IMAGE_CREATE_SPARSE_BINDING_BIT
  * 若pname:imageType is ename:VK_IMAGE_TYPE_1D, pname:flags 必须 不能
   包含 ename:VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT
  * 若 <<features-features-sparseResidencyImage2D,sparse residency for
    2D images>>特征没有被启用， 且 pname:imageType 是
    ename:VK_IMAGE_TYPE_2D, pname:flags 必须 不能包含
    ename:VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT
  * 若<<features-features-sparseResidencyImage3D,sparse residency for
    3D images>>特征没有被启用， 且 pname:imageType is
    ename:VK_IMAGE_TYPE_3D, pname:flags 必须不能包含
    ename:VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT
  * 若the <<features-features-sparseResidency2Samples,sparse residency for
    images with 2 samples>>特征没有被启用， pname:imageType 是
    ename:VK_IMAGE_TYPE_2D, 且 pname:samples  是
    ename:VK_SAMPLE_COUNT_2_BIT, pname:flags 必须 不能包含
    ename:VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT
  * 若<<features-features-sparseResidency4Samples,sparse residency for
    images with 4 samples>>特征没有被启用， pname:imageType  是
    ename:VK_IMAGE_TYPE_2D, 且 pname:samples  是
    ename:VK_SAMPLE_COUNT_4_BIT, pname:flags 必须 不能包含
    ename:VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT
  * 若 <<features-features-sparseResidency8Samples,sparse residency for
    images with 8 samples>>特征没有被启用， pname:imageType  是
    ename:VK_IMAGE_TYPE_2D, 且 pname:samples  是
    ename:VK_SAMPLE_COUNT_8_BIT, pname:flags 必须 不能包含
    ename:VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT
  * 若<<features-features-sparseResidency16Samples,sparse residency for
    images with 16 samples>>特征没有被启用， pname:imageType  是
    ename:VK_IMAGE_TYPE_2D, 且 pname:samples  是
    ename:VK_SAMPLE_COUNT_16_BIT, pname:flags 必须 不能包含
    ename:VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT
  * 若pname:tiling is ename:VK_IMAGE_TILING_LINEAR, pname:format 必须是一个     
    sname:VkFormatProperties::pname:linearTilingFeatures数据中的一个特征bit的格式，该数据是通过以pname:format相同值为参数 调用
    fname:vkGetPhysicalDeviceFormatProperties获取的。    
  * 若pname:tiling is ename:VK_IMAGE_TILING_LINEAR, 和
    sname:VkFormatProperties::pname:linearTilingFeatures (as returned by
    fname:vkGetPhysicalDeviceFormatProperties with the same value of
    pname:format) 不包含
    ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT, pname:usage 必须不能包含
    ename:VK_IMAGE_USAGE_SAMPLED_BIT
  * 若pname:tiling is ename:VK_IMAGE_TILING_LINEAR, 和
    sname:VkFormatProperties::pname:linearTilingFeatures (as returned by
    fname:vkGetPhysicalDeviceFormatProperties with the same value of
    pname:format) 不包含
    ename:VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT, pname:usage 必须不能包含
    ename:VK_IMAGE_USAGE_STORAGE_BIT
  * 若pname:tiling is ename:VK_IMAGE_TILING_LINEAR, 和
    sname:VkFormatProperties::pname:linearTilingFeatures (as returned by
    fname:vkGetPhysicalDeviceFormatProperties with the same value of
    pname:format) 不包含
    ename:VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT, pname:usage 必须不能
   包含 ename:VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT
  * 若pname:tiling is ename:VK_IMAGE_TILING_LINEAR, 和
    sname:VkFormatProperties::pname:linearTilingFeatures (as returned by
    fname:vkGetPhysicalDeviceFormatProperties with the same value of
    pname:format) 不包含
    ename:VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT, pname:usage must:
    not包含 ename:VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT
  * 若pname:tiling 是 ename:VK_IMAGE_TILING_OPTIMAL, pname:format 必须 是    
    value of sname:VkFormatProperties::pname:optimalTilingFeatures 其中一个受支持的特征bit的格式 ，该数据是通过以pname:format相同值为参数 调用
    fname:vkGetPhysicalDeviceFormatProperties  获取的。  
  * 若pname:tiling 是 ename:VK_IMAGE_TILING_OPTIMAL, 且
    sname:VkFormatProperties::pname:optimalTilingFeatures (as returned by
    fname:vkGetPhysicalDeviceFormatProperties with the same value of
    pname:format) 不包含
    ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT, pname:usage 必须不能包含
    ename:VK_IMAGE_USAGE_SAMPLED_BIT
  * 若pname:tiling 是 ename:VK_IMAGE_TILING_OPTIMAL, 且
    sname:VkFormatProperties::pname:optimalTilingFeatures (as returned by
    fname:vkGetPhysicalDeviceFormatProperties with the same value of
    pname:format) 不包含
    ename:VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT, pname:usage 必须不能包含
    ename:VK_IMAGE_USAGE_STORAGE_BIT
  * 若pname:tiling 是 ename:VK_IMAGE_TILING_OPTIMAL, 且
    sname:VkFormatProperties::pname:optimalTilingFeatures (as returned by
    fname:vkGetPhysicalDeviceFormatProperties with the same value of
    pname:format) 不包含
    ename:VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT, pname:usage 必须不能
   包含 ename:VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT
  * 若pname:tiling 是 ename:VK_IMAGE_TILING_OPTIMAL, 且
    sname:VkFormatProperties::pname:optimalTilingFeatures (as returned by
    fname:vkGetPhysicalDeviceFormatProperties with the same value of
    pname:format) 不包含
    ename:VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT, pname:usage 不能
	包含 ename:VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT
  * 若pname:flags包含 ename:VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT或
    ename:VK_IMAGE_CREATE_SPARSE_ALIASED_BIT, 它必须也包含
    ename:VK_IMAGE_CREATE_SPARSE_BINDING_BIT
****

include::../validity/structs/VkImageCreateInfo.txt[]

ifdef::VK_NV_dedicated_allocation[]

// refBegin VkDedicatedAllocationImageCreateInfoNV Specify that an image is bound to a dedicated memory resource

若 pname:pNext 列表包含一个sname:VkDedicatedAllocationImageCreateInfoNV 数据结构，那么该数据结构包含一个控制开关，控制图像是否使用为它专门分配的内存。


 sname:VkDedicatedAllocationImageCreateInfoNV 数据结构定义如下：

include::../api/structs/VkDedicatedAllocationImageCreateInfoNV.txt[]

  * pname:sType是这个数据结构的类型。
  * pname:pNext 是 `NULL` 或者一个指向 拓展特定的数据结构的指针。
  * pname:dedicatedAllocation 表示图像是否将拥有专用的绑定的内存。

[NOTE]
.注意
====
在一些设备上使用为颜色、depth/stencil附件或 其他大图像 专用分配的内存将会提升性能。
====

.Valid Usage
****
  * 若 pname:dedicatedAllocation 为 ename:VK_TRUE，
    sname:VkImageCreateInfo::pname:flags 不能: 包括
    ename:VK_IMAGE_CREATE_SPARSE_BINDING_BIT，
    ename:VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT，或者
    ename:VK_IMAGE_CREATE_SPARSE_ALIASED_BIT
****

include::../validity/structs/VkDedicatedAllocationImageCreateInfoNV.txt[]

endif::VK_NV_dedicated_allocation[]

ifdef::VK_NV_external_memory[]

// refBegin VkExternalMemoryImageCreateInfoNV Specify that an image may be backed by external memory

若pname:pNext 列表包括一个 sname:VkExternalMemoryImageCreateInfoNV 数据结构，那么该数据结构定义了一些外部内存handle类型，
它们可用于存储图像。

sname:VkExternalMemoryImageCreateInfoNV 类型数据结构定义如下：

include::../api/structs/VkExternalMemoryImageCreateInfoNV.txt[]

  * pname:sType 是这个数据结构的类型。
  * pname:pNext 是 `NULL` 或者一个指向拓展特定的数据结构的指针。
  * pname:handleTypes 是一个 
    elink:VkExternalMemoryHandleTypeFlagBitsNV 类型的 位掩码，指定了一个或多个外部内存handle类型。
	这些类型必须相互兼容，且其他图像创建参数相兼容，参数如 flink:vkGetPhysicalDeviceExternalImageFormatPropertiesNV 去取出的那样。    

include::../validity/structs/VkExternalMemoryImageCreateInfoNV.txt[]

endif::VK_NV_external_memory[]

// refBegin VkImageUsageFlagBits Bitmask specifying intended usage of an image

图像的目标使用方式由 slink:VkImageCreateInfo::pname:usage 掩码表示。
可用标志位如下：

include::../api/enums/VkImageUsageFlagBits.txt[]

这些bit 有如下的意义：

  * ename:VK_IMAGE_USAGE_TRANSFER_SRC_BIT 表示图像 可以 被用作 转移命令的源。
  * ename:VK_IMAGE_USAGE_TRANSFER_DST_BIT 表示图像 可以 被用作 转移命令的目标。
  * ename:VK_IMAGE_USAGE_SAMPLED_BIT 表示图像 可以 被用于创建 适于占用
      ename:VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE 或
    ename:VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER类型，且可被着色器采样的sname:VkDescriptorSet槽的 sname:VkImageView 。
  * ename:VK_IMAGE_USAGE_STORAGE_BIT 表示 图像可以被用于创建适于占用
    ename:VK_DESCRIPTOR_TYPE_STORAGE_IMAGE类型的 sname:VkDescriptorSet 槽。
  * ename:VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT表示 该图像可以
   被用于创建  sname:VkImageView，其适于被用作 sname:VkFramebuffer中的 一个颜色 或  resolve 附件。
  * ename:VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT表示 该图像可以被用于创建 sname:VkImageView，
    其适于被用作sname:VkFramebuffer中的 depth/stencil 附件。 
  * ename:VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT表示 绑定到此图像的内存使用    
    ename:VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT (参考 <<memory>> 获取详细内容) 标志位被创建的。
    这个bit可以 设置给任何图像，该图像必须可以被用于创建 一个适于用作颜色、resolve、depth/stencil 或 输入附件。    
  * ename:VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT表示 that该图像可以
   被用于创建 一个 sname:VkImageView，其适于占用一个
    ename:VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT 类型的 sname:VkDescriptorSet 槽; 
	可从着色器中作为 输入附件 被读取；且可在缓冲区中被用作一个输入附件。

// refEnd VkImageUsageFlagBits

// refBegin VkImageCreateFlagBits Bitmask specifying additional parameters of an image

图像的其他参数可以通过
slink:VkImageCreateInfo::pname:flags  指定。
可以设置的 Bits 包括:

include::../api/enums/VkImageCreateFlagBits.txt[]

这些bit的含义如下：

  * ename:VK_IMAGE_CREATE_SPARSE_BINDING_BIT 表示图像将使用稀疏内存绑定来存储。
  * ename:VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT 表示图像可部分的使用稀疏内存绑定来存储。
	 使用此flog创建的图像也可以使用
    ename:VK_IMAGE_CREATE_SPARSE_BINDING_BIT flag创建。
  * ename:VK_IMAGE_CREATE_SPARSE_ALIASED_BIT表示 该图像 将使用稀疏内存绑定来存储，内存区间可能同时存储其他图像（或者同一图像的其他部分）。
    带有此flag被创建的图像 必须也带有 ename:VK_IMAGE_CREATE_SPARSE_BINDING_BIT 标志位。
  * ename:VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT表示 该图像可以
   被用于创建与此图像格式不同的格式的 sname:VkImageView。
  * ename:VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT表示 该图像可以
   被用于创建 ename:VK_IMAGE_VIEW_TYPE_CUBE或 ename:VK_IMAGE_VIEW_TYPE_CUBE_ARRAY类型的sname:VkImageView 。
ifdef::VK_KHR_maintenance1[]
  * ename:VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT_KHR表示该图像可以被用于创建 
    ename:VK_IMAGE_VIEW_TYPE_2D或 ename:VK_IMAGE_VIEW_TYPE_2D_ARRAY类型的 sname:VkImageView。
endif::VK_KHR_maintenance1[]

如果ename:VK_IMAGE_CREATE_SPARSE_BINDING_BIT, ename:VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT, 或者 ename:VK_IMAGE_CREATE_SPARSE_ALIASED_BIT 之一被设置过了，
ename:VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT 就不能被设置了。

参考 <<sparsememory-sparseresourcefeatures,Sparse Resource Features>> 和
<<sparsememory-physicalfeatures,Sparse Physical Device Features>> 来获取更多细节。

// refEnd VkImageCreateFlagBits

// refBegin VkImageType Specifies the type of an image object

图像的基础维度是通过slink:VkImageCreateInfo::pname:imageType 指定的，必须是如下值之一：

include::../api/enums/VkImageType.txt[]

这些值各自指定了一维-，二维-或者三维- 图像。

// refEnd VkImageType

// refBegin VkImageTiling Specifies the tiling arrangement of data in an image

The tiling arrangement of data elements in an image is specified by
slink:VkImageCreateInfo::pname:tiling, which 必须 be one of the values

include::../api/enums/VkImageTiling.txt[]

ename:VK_IMAGE_TILING_OPTIMAL specifies optimal tiling (texels are laid out
in an implementation-dependent arrangement, for more optimal memory access),
and ename:VK_IMAGE_TILING_LINEAR specifies linear tiling (texels are laid
out in memory in row-major或der, possibly with some padding on each row).

// refEnd VkImageTiling

// refBegin vkGetImageSubresourceLayout Retrieve information about an image subresource

对于以线性tiling 创建的图像，可调用如下命令来查询图像子资源的主机端访问布局：

include::../api/protos/vkGetImageSubresourceLayout.txt[]

  * pname:device 是拥有该图像的逻辑设备。
  * pname:image 被查询布局的图像。
  * pname:pSubresource 是一个指向 slink:VkImageSubresource 数据结构的指针，为图像子资源选择了指定的图像。    
  * pname:pLayout 指向一个 slink:VkSubresourceLayout 数据结构，存储被返回的布局。

flink:vkGetImageSubresourceLayout 对于单个图像的生命周期来说是不变的。

.Valid Usage
****
  * pname:image 必须: 是使用 pname:tiling 为  ename:VK_IMAGE_TILING_LINEAR的参数创建的。
  * pname:pSubresource的pname:aspectMask 成员 必须: 只能让其一个bit 被设置。
****

include::../validity/protos/vkGetImageSubresourceLayout.txt[]

// refBegin VkImageSubresource Structure specifying a image subresource

sname:VkImageSubresource 数据结构定义如下：

include::../api/structs/VkImageSubresource.txt[]

  * pname:aspectMask 是一个 elink:VkImageAspectFlags ，筛选图像的 _aspect_。
  * pname:mipLevel 选择了mipmap层级。
  * pname:arrayLayer 选择了array layer。

.Valid Usage
****
  * pname:mipLevel 必须: 小于 pname:mipLevels，由图像被创建时的slink:VkImageCreateInfo 所指定。
  * pname:arrayLayer 必须: 小于 pname:arrayLayers，由图像被创建时的  slink:VkImageCreateInfo 所指定。
****

include::../validity/structs/VkImageSubresource.txt[]

// refBegin VkSubresourceLayout Structure specifying subresource layout

该图像子资源的布局的信息 被封装在sname:VkSubresourceLayout 数据结构中被返回：

include::../api/structs/VkSubresourceLayout.txt[]

  * pname:offset 是该图像子资源起始的偏移字节数。
  * pname:size  该图像子资源的字节大小。
    pname:size 包含 要求基于pname:rowPitch的 任何 额外内存。
  * pname:rowPitch 描述了一个图像内每行纹素的字节数。
  * pname:arrayPitch 描述了一个图像内每个array layer 的字节数。 
  * pname:depthPitch 描述了3D图像的每个切分的字节数。

对于线性排列创建的图像，pname:rowPitch, pname:arrayPitch 和
pname:depthPitch 描述 该图像子资源再线性内存中的布局。
对于未压缩的格式， pname:rowPitch 是相邻行（y坐标相差1）之间相同x坐标的纹素之间的字节数。
pname:arrayPitch 是该图像的相邻array layer 的同x、y坐标纹素之间的字节数。
pname:depthPitch 是3D图像相邻切片（z坐标相差1）内同x、y坐标之间纹素之间的字节数。
通过一个寻址表达式来表示，一个图像子资源的纹素的起始字节 地址为：

[source,c]
---------------------------------------------------
// (x,y,z,layer) are in texel coordinates
address(x,y,z,layer) = layer*arrayPitch + z*depthPitch + y*rowPitch + x*elementSize + offset
---------------------------------------------------

对于压缩格式，pname:rowPitch 是相邻行的压缩的纹素块的字节数。 
pname:arrayPitch 是相邻array layers的压缩纹素块之间的字节数。
pname:depthPitch 是相邻的3D图像的切片的压缩纹素块之间的字节数。

[source,c]
---------------------------------------------------
// (x,y,z,layer) are in compressed texel block coordinates
address(x,y,z,layer) = layer*arrayPitch + z*depthPitch + y*rowPitch + x*compressedTexelBlockByteSize + offset;
---------------------------------------------------

pname:arrayPitch is undefined for images that were not created as arrays.
pname:depthPitch is defined only for 3D images.

对于颜色格式， sname:VkImageSubresource的pname:aspectMask 成员
必须 是 ename:VK_IMAGE_ASPECT_COLOR_BIT.
对于depth/stencil 格式，pname:aspectMask 必须是
ename:VK_IMAGE_ASPECT_DEPTH_BIT或 ename:VK_IMAGE_ASPECT_STENCIL_BIT 二者其一。
On implementations that store depth and stencil aspects separately, querying
each of these image subresource layouts will return a different pname:offset
and pname:size representing the region of memory used for that aspect.
On implementations that store depth and stencil aspects interleaved, the
same pname:offset and pname:size are returned and represent the interleaved
memory allocation.

include::../validity/structs/VkSubresourceLayout.txt[]

// refBegin vkDestroyImage Destroy an image object

可调用如下命令来销毁图像：

include::../api/protos/vkDestroyImage.txt[]

  * pname:device 是拥有需被销毁图像的逻辑设备。
  * pname:image 是需被销毁的图像。
  * pname:pAllocator 控制CPU端内存分配，如 <<memory-allocation, 内存分配 >> 一章详述。

.Valid Usage
****
  * 所有直接或 通过一个sname:VkImageView引用pname:image的已提交的命令，必须已经完成执行。
  * 若创建图像时 提供了sname:VkAllocationCallbacks，那么在此处必须提供兼容的回调。
  * 若创建图像时没有提供sname:VkAllocationCallbacks，那么pname:pAllocator 必须为 `NULL`
****

include::../validity/protos/vkDestroyImage.txt[]


[[resources-image-layouts]]
== 图像布局

图像被存储在依赖于Vulkan实现的不透明内存布局。Vulkan实现能能支持多种不透明布局，某个给定时刻使用的布局由
图像子资源的elink:VkImageLayout 状态决定。
每一个布局都有限制条件，如使用该布局可对图像子资源做何种操作。
Applications have control over which layout each image subresource uses, and
can: transition an image subresource from one layout to another.
Transitions可以 happen with an image memory barrier, included as part of a
fname:vkCmdPipelineBarrier或 a fname:vkCmdWaitEvents command buffer command
(see <<synchronization-image-memory-barriers>>),或 as part of a subpass
dependency within a render pass (see sname:VkSubpassDependency).
The image layout state is per-image subresource, and separate image
subresources of the same image可以 be in different layouts at the same time
with one exception - depth and stencil aspects of a given image subresource
必须 always be in the same layout.

[NOTE]
.注意
====
Each layout may: offer optimal performance for a specific usage of image
memory.
For example, an image with a layout of
ename:VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL may: provide optimal
performance for use as a color attachment, but be unsupported for use in
transfer commands.
Applications可以 transition an image subresource from one layout to another
in或der to achieve optimal performance when该图像 subresource is used
for multiple kinds of operations.
After initialization, applications need not use any layout other than the
general layout, though this may: produce suboptimal performance on some
implementations.
====

创建完成后，一个图像的所有图像子资源初始状态都处于相同的布局，该布局由
sname:VkImageCreateInfo::pname:initialLayout 成员选择。
pname:initialLayout 必须 为 ename:VK_IMAGE_LAYOUT_UNDEFINED或
ename:VK_IMAGE_LAYOUT_PREINITIALIZED 二者其一。
若为 ename:VK_IMAGE_LAYOUT_PREINITIALIZED, 那么该图像数据可以被host使用该布局预初始化，且布局转换可以保持数据。
若为 ename:VK_IMAGE_LAYOUT_UNDEFINED, 那么数据的内容被认为是未定义的，布局转换并不保证保持原有数据。
对于这任一初始布局，任何图像子资源 必须在device 访问它们之前转换到另一个布局。

Host access to image memory is only well-defined for images created with
ename:VK_IMAGE_TILING_LINEAR tiling and for image subresources of those
images which are currently in either the
ename:VK_IMAGE_LAYOUT_PREINITIALIZED或 ename:VK_IMAGE_LAYOUT_GENERAL
layout.
Calling flink:vkGetImageSubresourceLayout for a linear image returns a
subresource layout mapping that is valid for either of those image layouts.

// refBegin VkImageLayout Layout of image and image subresources

The set of image layouts consists of:

include::../api/enums/VkImageLayout.txt[]

The type(s) of device access supported by each layout are:

  * ename:VK_IMAGE_LAYOUT_UNDEFINED: 不支持设备访问。此布局 必须 仅被用作
    sname:VkImageCreateInfo或 sname:VkAttachmentDescription的pname:initialLayout成员，或用于图像转换的 pname:oldLayout。
	当从此布局转换为其他布局时，内存的内容不被保证保留。    
  * ename:VK_IMAGE_LAYOUT_PREINITIALIZED: 不支持设备访问。
    此布局必须 仅被用于 
    sname:VkImageCreateInfo或 sname:VkAttachmentDescription的pname:initialLayout 成员，或用于图像转换的pname:oldLayout 。
	当从此布局转换为其他布局时，内存的内容被保证保留。
    此布局 专门被用于 host端写入的图像，其数据可以被立即写入内存，而不需要先执行布局转换。    
    当前，ename:VK_IMAGE_LAYOUT_PREINITIALIZED 只对
    ename:VK_IMAGE_TILING_LINEAR 图像有效，因为并没有为ename:VK_IMAGE_TILING_OPTIMAL 图像定义的标准布局。
  * ename:VK_IMAGE_LAYOUT_GENERAL: 支持所有类型的设备访问。
  * ename:VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL: 必须 仅被用于sname:VkFramebuffer中的颜色或 resolve 附件。
    此布局仅针对 以带有ename:VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT bit位被启用来创建的图像子资源来说有效。
  * ename:VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL: 必须 仅被用于sname:VkFramebuffer的 depth/stencil 附件。
    此布局仅针对 以带有 ename:VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT bit位被启用来创建的图像子资源来说有效。
  * ename:VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL: 必须 仅被用于sname:VkFramebuffer的只读 depth/stencil 附件，
     且/或 被用于 着色器中只读的图像 (可以当作采样图像，combined image/sampler and/or 输入附件 被读取).
	 此布局仅针对 以带有 ename:VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT bit位被启用来创建的图像子资源来说有效。    
    以ename:VK_IMAGE_USAGE_SAMPLED_BIT 被创建的图像的图像子资源 可以在着色器中 被用作采样图像或combined image/sampler。
    同样，, only image subresources of images created with
    以ename:VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT 被创建的图像的图像子资源 可以在着色器中被用作 输入附件。    
  * ename:VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL: 必须 仅被用作 着色器内只读图像 (可以被当作 采样图像、combined image/sampler 或 输入附件 只读采样)。
	此布局仅针对 以带有 ename:VK_IMAGE_USAGE_SAMPLED_BIT 或    ename:VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT   bit位被启用来创建的图像子资源来说有效。
  * ename:VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL: 必须 仅被用作 转移命令的源图像 (参考<<synchronization-pipeline-stages-transfer,  ename:VK_PIPELINE_STAGE_TRANSFER_BIT>>的定义).
	此布局仅针对 以带有 ename:VK_IMAGE_USAGE_TRANSFER_SRC_BIT bit位被启用来创建的图像子资源来说有效。
  * ename:VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL: 必须 仅被用作 转移命令的目标图像。
	此布局仅针对 以带有 ename:VK_IMAGE_USAGE_TRANSFER_DST_BIT bit位被启用来创建的图像子资源来说有效。
ifdef::VK_KHR_swapchain[]
  * ename:VK_IMAGE_LAYOUT_PRESENT_SRC_KHR: 必须 only被用于 for presenting
    a presentable image for display.
    A swapchain's image 必须 be transitioned to this layout before calling
    flink:vkQueuePresentKHR, and 必须 be transitioned away from this layout
    after calling flink:vkAcquireNextImageKHR.
endif::VK_KHR_swapchain[]

在API中每种方位图像的机制，都有一个参数 或 数据结构成员 来控制 访问该图像的布局。
对于转移命令，这是命令的一个参数 (参考 <<clears>> 和 <<copies>>)。
对于用作 帧缓冲区附件，这是 sname:VkRenderPassCreateInfo 数据结构的一个成员 (参考 <<renderpass,Render Pass>>)。
对于描述符集合中的使用，这是sname:VkDescriptorImageInfo数据结构的一个成员 (参考 <<descriptorsets-updates>>)。
在任何队列上 任何命令缓冲区命令访问图像的任何时刻，被访问该图像子资源的布局必须都匹配 API控制访问所指定的布局。

每个图像子资源的图像布局必须在该图像子资源的生命周期的每个时刻都是良好定义的。
这意味这在 该图像上操作 布局转换，老的布局值必须 等同于当前 图像子资源的布局 (在转换执行过程中), 或者是
ename:VK_IMAGE_LAYOUT_UNDEFINED ( 意味着该图像子资源的内容不需要被保留)。
转移中使用的新布局 不能是 ename:VK_IMAGE_LAYOUT_UNDEFINED或 ename:VK_IMAGE_LAYOUT_PREINITIALIZED。

// refEnd VkImageLayout


[[resources-image-views]]
== 图像视图

// refBegin VkImageView Opaque handle to a image view object

图像对象不会被管线着色器直接读写访问。作为替代，_图像视图_，表示图像资源连续的一部分，带有附加的元信息，可用作上述目的。
视图必须以与图像兼容的类型来被创建，必须表示图像资源的一个有效子集合。
 
图像视图通过sname:VkImageView 类型的handle表示：

include::../api/handles/VkImageView.txt[]

// refEnd VkImageView

// refBegin VkImageViewType Image view types

可以被创建的 图像视图的类型：

include::../api/enums/VkImageViewType.txt[]

图像视图的准确类型部分是隐式的，基于图像的类型、采样数量，和 <<resources-image-views-compatibility, 下表>>
描述的视图创建参数。这个表格也展示了每一个图像视图类型在SPIR-V中对应的OpTypeImage Dim 和 Arrayed等参数。

// refEnd VkImageViewType

// refBegin vkCreateImageView Create an image view from an existing image

可调用下面命令来创建图像视图：

include::../api/protos/vkCreateImageView.txt[]

  * pname:device 是创建图像视图的逻辑设备。
  * pname:pCreateInfo 是一个指针，指向一个 sname:VkImageViewCreateInfo 数据结构实例，它包含了创建图像视图所需的信息。
  * pname:pAllocator 控制CPU端内存分配，如 <<memory-allocation, 内存分配 >> 一章详述。
  * pname:pView 指向一个 sname:VkImageView handle，它是被返回的新生成的图像视图对象。

图像创建参数的一部分被视图所继承，剩余的参数被包含在pname:pCreateInfo中。

include::../validity/protos/vkCreateImageView.txt[]

// refBegin VkImageViewCreateInfo Structure specifying parameters of a newly created image view

sname:VkImageViewCreateInfo类型定义如下：

include::../api/structs/VkImageViewCreateInfo.txt[]

  * pname:sType 是这个数据结构的类型。
  * pname:pNext 是`NULL` 或者一个指向拓展特定的数据结构的指针。
  * pname:flags 被保留使用。
  * pname:image is a sname:VkImage on which the view will be created.
  * pname:viewType 是图像视图的类型。
  * pname:format 是一个 elink:VkFormat 类型数据，描述了用于结束图像中数据元素的格式和类型。
  * pname:components 指定了颜色成员(或深度成员，或转换到颜色成员之后的 stencil 成员)重映射。
    参考 slink:VkComponentMapping。
  * pname:subresourceRange 是一个 slink:VkImageSubresourceRange，选择来view可访问的mipmap levels和array layers。  

若以ename:VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT 创建 pname:image，pname:format可以与该图像的格式不同， 但是若它们不等同，
那么它们必须是兼容的。
图像格式兼容性在 <<features-formats-compatibility-classes,Format Compatibility Classes>>
小节中定义。

[[resources-image-views-compatibility]]
.Image and image view parameter compatibility requirements
[cols="15%h,35%,50%",options="header"]
|====
| Dim, Arrayed, MS | Image parameters | View parameters
| | pname:imageType = ci.pname:imageType +
    pname:width = ci.pname:extent.width +
    pname:height = ci.pname:extent.height +
    pname:depth = ci.pname:extent.depth +
    pname:arrayLayers = ci.pname:arrayLayers +
    pname:samples = ci.pname:samples +
    where ci is the slink:VkImageCreateInfo used创建 pname:image.
  | pname:baseArrayLayer and pname:layerCount are members of the
    pname:subresourceRange member.
| 1D, 0, 0 |
pname:imageType = ename:VK_IMAGE_TYPE_1D +
pname:width {geq} 1 +
pname:height = 1 +
pname:depth = 1 +
pname:arrayLayers {geq} 1 +
pname:samples = 1 |
pname:viewType = ename:VK_VIEW_TYPE_1D +
pname:baseArrayLayer {geq} 0 +
pname:layerCount = 1
| 1D, 1, 0 |
pname:imageType = ename:VK_IMAGE_TYPE_1D +
pname:width {geq} 1 +
pname:height = 1 +
pname:depth = 1 +
pname:arrayLayers {geq} 1 +
pname:samples = 1 |
pname:viewType = ename:VK_VIEW_TYPE_1D_ARRAY +
pname:baseArrayLayer {geq} 0 +
pname:layerCount {geq} 1
| 2D, 0, 0 |
pname:imageType = ename:VK_IMAGE_TYPE_2D +
pname:width {geq} 1 +
pname:height {geq} 1 +
pname:depth = 1 +
pname:arrayLayers {geq} 1 +
pname:samples = 1 |
pname:viewType = ename:VK_VIEW_TYPE_2D +
pname:baseArrayLayer {geq} 0 +
pname:layerCount = 1
| 2D, 1, 0 |
pname:imageType = ename:VK_IMAGE_TYPE_2D +
pname:width {geq} 1 +
pname:height {geq} 1 +
pname:depth = 1 +
pname:arrayLayers {geq} 1 +
pname:samples = 1 |
pname:viewType = ename:VK_VIEW_TYPE_2D_ARRAY +
pname:baseArrayLayer {geq} 0 +
pname:layerCount {geq} 1
| 2D, 0, 1 |
pname:imageType = ename:VK_IMAGE_TYPE_2D +
pname:width {geq} 1 +
pname:height {geq} 1 +
pname:depth = 1 +
pname:arrayLayers {geq} 1 +
pname:samples > 1 |
pname:viewType = ename:VK_VIEW_TYPE_2D +
pname:baseArrayLayer {geq} 0 +
pname:layerCount = 1
| 2D, 1, 1 |
pname:imageType = ename:VK_IMAGE_TYPE_2D +
pname:width {geq} 1 +
pname:height {geq} 1 +
pname:depth = 1 +
pname:arrayLayers {geq} 1 +
pname:samples > 1 |
pname:viewType = ename:VK_VIEW_TYPE_2D_ARRAY +
pname:baseArrayLayer {geq} 0 +
pname:layerCount {geq} 1
| CUBE, 0, 0 |
pname:imageType = ename:VK_IMAGE_TYPE_2D +
pname:width {geq} 1 +
pname:height = pname:width +
pname:depth = 1 +
pname:arrayLayers {geq} 6 +
pname:samples = 1 +
pname:flags 包含 ename:VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT |
pname:viewType = ename:VK_VIEW_TYPE_CUBE +
pname:baseArrayLayer {geq} 0 +
pname:layerCount = 6
| CUBE, 1, 0 |
pname:imageType = ename:VK_IMAGE_TYPE_2D +
pname:width {geq} 1 +
pname:height = width +
pname:depth = 1 +
_N_ {geq} 1 +
pname:arrayLayers {geq} 6 {times} _N_ +
pname:samples = 1 +
pname:flags 包含 ename:VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT |
pname:viewType = ename:VK_VIEW_TYPE_CUBE_ARRAY +
pname:baseArrayLayer {geq} 0 +
pname:layerCount = 6 {times} _N_, _N_ {geq} 1
| 3D, 0, 0 |
pname:imageType = ename:VK_IMAGE_TYPE_3D +
pname:width {geq} 1 +
pname:height {geq} 1 +
pname:depth {geq} 1 +
pname:arrayLayers = 1 +
pname:samples = 1 |
pname:viewType = ename:VK_VIEW_TYPE_3D +
pname:baseArrayLayer = 0 +
pname:layerCount = 1
ifdef::VK_KHR_maintenance1[]
| 3D, 0, 0 |
pname:imageType = ename:VK_IMAGE_TYPE_3D +
pname:width {geq} 1 +
pname:height {geq} 1 +
pname:depth {geq} 1 +
pname:arrayLayers = 1 +
pname:samples = 1 +
pname:flags 包含 ename:VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT +
pname:flags 不包含 VK_IMAGE_CREATE_SPARSE_BINDING_BIT, VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT, and VK_IMAGE_CREATE_SPARSE_ALIASED_BIT |
pname:viewType = ename:VK_VIEW_TYPE_2D +
pname:levelCount = 1 +
pname:baseArrayLayer {geq} 0 +
pname:layerCount = 1
| 3D, 0, 0 |
pname:imageType = ename:VK_IMAGE_TYPE_3D +
pname:width {geq} 1 +
pname:height {geq} 1 +
pname:depth {geq} 1 +
pname:arrayLayers = 1 +
pname:samples = 1 +
pname:flags 包含 ename:VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT +
pname:flags 不包含 VK_IMAGE_CREATE_SPARSE_BINDING_BIT, VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT, and VK_IMAGE_CREATE_SPARSE_ALIASED_BIT |
pname:viewType = ename:VK_VIEW_TYPE_2D_ARRAY +
pname:levelCount = 1 +
pname:baseArrayLayer {geq} 0 +
pname:layerCount {geq} 1
endif::VK_KHR_maintenance1[]
|====

.Valid Usage
****
  * 若创建pname:image时没有带有 ename:VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT，那么 pname:viewType 不能是
     ename:VK_IMAGE_VIEW_TYPE_CUBE或 ename:VK_IMAGE_VIEW_TYPE_CUBE_ARRAY
  * 若 <<features-features-imageCubeArray,image cubemap arrays>> 特征没有被启用，pname:viewType 不能是
    ename:VK_IMAGE_VIEW_TYPE_CUBE_ARRAY
ifdef::VK_KHR_maintenance1[]
  * 若创建 pname:image时带有 ename:VK_IMAGE_TYPE_3D 但未带有 ename:VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT_KHR，
   那么 pname:viewType 不能是 ename:VK_IMAGE_VIEW_TYPE_2D或
    ename:VK_IMAGE_VIEW_TYPE_2D_ARRAY
endif::VK_KHR_maintenance1[]
  * 若 <<features-features-textureCompressionETC2,ETC2 texture
    compression>>特征没有被启用， pname:format 不能是
    ename:VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK,
    ename:VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK,
    ename:VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK,
    ename:VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK,
    ename:VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK,
    ename:VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK,
    ename:VK_FORMAT_EAC_R11_UNORM_BLOCK,
    ename:VK_FORMAT_EAC_R11_SNORM_BLOCK,
    ename:VK_FORMAT_EAC_R11G11_UNORM_BLOCK,或
    ename:VK_FORMAT_EAC_R11G11_SNORM_BLOCK
  * 若<<features-features-textureCompressionASTC_LDR,ASTC LDR texture
    compression>>特征没有被启用， pname:format 不能是
    ename:VK_FORMAT_ASTC_4x4_UNORM_BLOCK,
    ename:VK_FORMAT_ASTC_4x4_SRGB_BLOCK,
    ename:VK_FORMAT_ASTC_5x4_UNORM_BLOCK,
    ename:VK_FORMAT_ASTC_5x4_SRGB_BLOCK,
    ename:VK_FORMAT_ASTC_5x5_UNORM_BLOCK,
    ename:VK_FORMAT_ASTC_5x5_SRGB_BLOCK,
    ename:VK_FORMAT_ASTC_6x5_UNORM_BLOCK,
    ename:VK_FORMAT_ASTC_6x5_SRGB_BLOCK,
    ename:VK_FORMAT_ASTC_6x6_UNORM_BLOCK,
    ename:VK_FORMAT_ASTC_6x6_SRGB_BLOCK,
    ename:VK_FORMAT_ASTC_8x5_UNORM_BLOCK,
    ename:VK_FORMAT_ASTC_8x5_SRGB_BLOCK,
    ename:VK_FORMAT_ASTC_8x6_UNORM_BLOCK,
    ename:VK_FORMAT_ASTC_8x6_SRGB_BLOCK,
    ename:VK_FORMAT_ASTC_8x8_UNORM_BLOCK,
    ename:VK_FORMAT_ASTC_8x8_SRGB_BLOCK,
    ename:VK_FORMAT_ASTC_10x5_UNORM_BLOCK,
    ename:VK_FORMAT_ASTC_10x5_SRGB_BLOCK,
    ename:VK_FORMAT_ASTC_10x6_UNORM_BLOCK,
    ename:VK_FORMAT_ASTC_10x6_SRGB_BLOCK,
    ename:VK_FORMAT_ASTC_10x8_UNORM_BLOCK,
    ename:VK_FORMAT_ASTC_10x8_SRGB_BLOCK,
    ename:VK_FORMAT_ASTC_10x10_UNORM_BLOCK,
    ename:VK_FORMAT_ASTC_10x10_SRGB_BLOCK,
    ename:VK_FORMAT_ASTC_12x10_UNORM_BLOCK,
    ename:VK_FORMAT_ASTC_12x10_SRGB_BLOCK,
    ename:VK_FORMAT_ASTC_12x12_UNORM_BLOCK,或
    ename:VK_FORMAT_ASTC_12x12_SRGB_BLOCK
  * 若 <<features-features-textureCompressionBC,BC texture compression>>
   特征没有被启用， pname:format 不能是
    ename:VK_FORMAT_BC1_RGB_UNORM_BLOCK, ename:VK_FORMAT_BC1_RGB_SRGB_BLOCK,
    ename:VK_FORMAT_BC1_RGBA_UNORM_BLOCK,
    ename:VK_FORMAT_BC1_RGBA_SRGB_BLOCK, ename:VK_FORMAT_BC2_UNORM_BLOCK,
    ename:VK_FORMAT_BC2_SRGB_BLOCK, ename:VK_FORMAT_BC3_UNORM_BLOCK,
    ename:VK_FORMAT_BC3_SRGB_BLOCK, ename:VK_FORMAT_BC4_UNORM_BLOCK,
    ename:VK_FORMAT_BC4_SNORM_BLOCK, ename:VK_FORMAT_BC5_UNORM_BLOCK,
    ename:VK_FORMAT_BC5_SNORM_BLOCK, ename:VK_FORMAT_BC6H_UFLOAT_BLOCK,
    ename:VK_FORMAT_BC6H_SFLOAT_BLOCK, ename:VK_FORMAT_BC7_UNORM_BLOCK,或
    ename:VK_FORMAT_BC7_SRGB_BLOCK
  * 若创建pname:image 时带有 ename:VK_IMAGE_TILING_LINEAR，
    pname:format 必须是 一种格式，至少有一个受支持的bit 是
    通过以相同值的pname:format调用fname:vkGetPhysicalDeviceFormatProperties  返回的sname:VkFormatProperties::pname:linearTilingFeatures
	其中的一个bit值。    
  * 创建pname:image时 必须让 pname:usage value包含 至少 ename:VK_IMAGE_USAGE_SAMPLED_BIT,
    ename:VK_IMAGE_USAGE_STORAGE_BIT,
    ename:VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT,
    ename:VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT,或
    ename:VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT 其中的一个
  * 若创建pname:image时带有 ename:VK_IMAGE_TILING_LINEAR 且
    pname:usage包含 ename:VK_IMAGE_USAGE_SAMPLED_BIT, pname:format
    必须 针对 采样图像支持      
    通过以相同值的pname:format调用fname:vkGetPhysicalDeviceFormatProperties 返回的sname:VkFormatProperties::pname:linearTilingFeatures 
    的ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT 指定的值。
  * 若pname:image was created with ename:VK_IMAGE_TILING_LINEAR and
    pname:usage包含ing ename:VK_IMAGE_USAGE_STORAGE_BIT, pname:format
    必须 be supported for storage images, as specified by the
    ename:VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT flag in
    sname:VkFormatProperties::pname:linearTilingFeatures returned by
    fname:vkGetPhysicalDeviceFormatProperties with the same value of
    pname:format
  * 若pname:image was created with ename:VK_IMAGE_TILING_LINEAR and
    pname:usage包含ing ename:VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT,
    pname:format 必须 be supported for color attachments, as specified by
    the ename:VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT flag in
    sname:VkFormatProperties::pname:linearTilingFeatures returned by
    fname:vkGetPhysicalDeviceFormatProperties with the same value of
    pname:format
  * 若pname:image was created with ename:VK_IMAGE_TILING_LINEAR and
    pname:usage包含ing
    ename:VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT, pname:format 必须 be
    supported for depth/stencil attachments, as specified by the
    ename:VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT flag in
    sname:VkFormatProperties::pname:linearTilingFeatures returned by
    fname:vkGetPhysicalDeviceFormatProperties with the same value of
    pname:format
  * 若pname:image was created with ename:VK_IMAGE_TILING_OPTIMAL,
    pname:format 必须 be format that has至少 one supported feature bit
    present in the value of
    sname:VkFormatProperties::pname:optimalTilingFeatures returned by
    fname:vkGetPhysicalDeviceFormatProperties with the same value of
    pname:format
  * 若pname:image was created with ename:VK_IMAGE_TILING_OPTIMAL and
    pname:usage包含ing ename:VK_IMAGE_USAGE_SAMPLED_BIT, pname:format
    必须 be supported for sampled images, as specified by the
    ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT flag in
    sname:VkFormatProperties::pname:optimalTilingFeatures returned by
    fname:vkGetPhysicalDeviceFormatProperties with the same value of
    pname:format
  * 若pname:image was created with ename:VK_IMAGE_TILING_OPTIMAL and
    pname:usage包含ing ename:VK_IMAGE_USAGE_STORAGE_BIT, pname:format
    必须 be supported for storage images, as specified by the
    ename:VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT flag in
    sname:VkFormatProperties::pname:optimalTilingFeatures returned by
    fname:vkGetPhysicalDeviceFormatProperties with the same value of
    pname:format
  * 若pname:image was created with ename:VK_IMAGE_TILING_OPTIMAL and
    pname:usage包含ing ename:VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT,
    pname:format 必须 be supported for color attachments, as specified by
    the ename:VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT flag in
    sname:VkFormatProperties::pname:optimalTilingFeatures returned by
    fname:vkGetPhysicalDeviceFormatProperties with the same value of
    pname:format
  * 若pname:image was created with ename:VK_IMAGE_TILING_OPTIMAL and
    pname:usage包含ing
    ename:VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT, pname:format 必须 be
    supported for depth/stencil attachments, as specified by the
    ename:VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT flag in
    sname:VkFormatProperties::pname:optimalTilingFeatures returned by
    fname:vkGetPhysicalDeviceFormatProperties with the same value of
    pname:format
  * pname:subresourceRange 必须 be a valid image subresource range for
    pname:image (see <<resources-image-views>>)
  * 若pname:image was created with the
    ename:VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT flag, pname:format 必须 be
    compatible with the pname:format used创建 pname:image, as defined
    in <<features-formats-compatibility-classes,Format Compatibility
    Classes>>
  * 若pname:image was not created with the
    ename:VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT flag, pname:format 必须 be
    identical to the pname:format used创建 pname:image
  * 若pname:image is non-sparse then it 必须 be bound completely and
    contiguously to a single sname:VkDeviceMemory object
  * pname:subResourceRange and pname:viewType 必须 be compatible with the
    image, as described in the
    <<resources-image-views-compatibility,compatibility table>>
****

include::../validity/structs/VkImageViewCreateInfo.txt[]

// refBegin VkImageSubresourceRange Structure specifying a image subresource range

sname:VkImageSubresourceRange类型数据结构定义如下：

include::../api/structs/VkImageSubresourceRange.txt[]

  * pname:aspectMask is a bitmask indicating which aspect(s) of该图像
    are included in the view.
    See elink:VkImageAspectFlagBits.
  * pname:baseMipLevel is the first mipmap level accessible to the view.
  * pname:levelCount is the number of mipmap levels (starting from
    pname:baseMipLevel) accessible to the view.
  * pname:baseArrayLayer is the first array layer accessible to the view.
  * pname:layerCount is the number of array layers (starting from
    pname:baseArrayLayer) accessible to the view.

mipmap 层数和array layers的数量必须是图像中图像资源的子集。
如果一个应用程序想要使用在pname:baseMipLevel 或 pname:baseArrayLayer之后的所有的mipmap层或者图像的layer，
它可以设置pname:levelCount 和 pname:layerCount为特殊值 ename:VK_REMAINING_MIP_LEVELS 和
ename:VK_REMAINING_ARRAY_LAYERS，而不用知道mipmap层和layer的准确大小。

对于立方和cube array视图，图像视图的layer从pname:baseArrayLayer开始，依序分别对应+X, -X, +Y, -Y, +Z, -Z 面。
For cube arrays, each set of six sequential layers is a single cube, so the
number of cube maps in a cube map array view is _pname:layerCount / 6_, and
image array layer _pname:baseArrayLayer + i_ is face index _i mod 6_ of cube
_i / 6_.
若the number of layers in the view, whether set explicitly in
pname:layerCount或 implied by ename:VK_REMAINING_ARRAY_LAYERS, is not a
multiple of 6, behavior when indexing the last cube is undefined.

pname:aspectMask is a bitmask indicating the format being used.
Bits which may: be set include:

// refBegin VkImageAspectFlagBits Bitmask specifying which aspects of an image are included in a view
include::../api/enums/VkImageAspectFlagBits.txt[]

The mask 必须 be only ename:VK_IMAGE_ASPECT_COLOR_BIT,
ename:VK_IMAGE_ASPECT_DEPTH_BIT或 ename:VK_IMAGE_ASPECT_STENCIL_BIT if
pname:format is a color, depth-only或 stencil-only format, respectively.
若using a depth/stencil format with both depth and stencil components,
pname:aspectMask 必须 include至少 one of
ename:VK_IMAGE_ASPECT_DEPTH_BIT and ename:VK_IMAGE_ASPECT_STENCIL_BIT, and
can: include both.

When using an imageView of a depth/stencil image to populate a descriptor
set (e.g. for sampling in the shader,或 for use as an input attachment),
the pname:aspectMask 必须 only include one bit and selects whether the
imageView is used for depth reads (i.e. using a floating-point sampler或
input attachment in the shader)或 stencil reads (i.e. using an unsigned
integer sampler或 input attachment in the shader).
When an imageView of a depth/stencil image is used as a depth/stencil
framebuffer attachment, the pname:aspectMask is ignored and both depth and
stencil image subresources are used.

The pname:components member is of type slink:VkComponentMapping, and
describes a remapping from components of该图像 to components of the
vector returned by shader image instructions.
This remapping 必须 be identity for storage image descriptors, input
attachment descriptors, and framebuffer attachments.

.Valid Usage
****
  * 若pname:levelCount is not ename:VK_REMAINING_MIP_LEVELS,
    [eq]#pname:levelCount# 必须 be non-zero and [eq]#(pname:baseMipLevel
    {plus} pname:levelCount)# 必须 be小于或 等于 the
    pname:mipLevels specified in slink:VkImageCreateInfo when该图像 was
    created
ifndef::VK_KHR_maintenance1[]
  * 若pname:layerCount is not ename:VK_REMAINING_ARRAY_LAYERS,
    [eq]#pname:layerCount# 必须 be non-zero and [eq]#(pname:baseArrayLayer
    + pname:layerCount)# 必须 be小于或 等于 the
    pname:arrayLayers specified in slink:VkImageCreateInfo when该图像
    was created
endif::VK_KHR_maintenance1[]
ifdef::VK_KHR_maintenance1[]
  * 若the pname:imageType specified in slink:VkImageCreateInfo when the
    image was created was ename:VK_IMAGE_TYPE_3D and该图像 view is
    created with the pname:viewType of slink:VkImageViewCreateInfo set to
    ename:VK_VIEW_TYPE_2D_ARRAY then pname:layerCount 必须 be
    ename:VK_REMAINING_ARRAY_LAYERS,或 [eq]#pname:layerCount# 必须 be
    non-zero and [eq]#(pname:baseArrayLayer + pname:layerCount)# 必须 be
   小于或 等于 the pname:extent.depth specified in
    slink:VkImageCreateInfo when该图像 was created
  * 若the pname:imageType specified in slink:VkImageCreateInfo when the
    image was created was not ename:VK_IMAGE_TYPE_3D或该图像 view is
    not created with the pname:viewType of slink:VkImageViewCreateInfo set
    to ename:VK_VIEW_TYPE_2D_ARRAY then pname:layerCount 必须 be
    ename:VK_REMAINING_ARRAY_LAYERS,或 [eq]#pname:layerCount# 必须 be
    non-zero and [eq]#(pname:baseArrayLayer + pname:layerCount)# 必须 be
   小于或 等于 the pname:arrayLayers specified in
    slink:VkImageCreateInfo when该图像 was created
endif::VK_KHR_maintenance1[]


****

include::../validity/structs/VkImageSubresourceRange.txt[]

// refBegin VkComponentMapping Structure specifying a color component mapping

sname:VkComponentMapping 类型数据结构定义如下：

include::../api/structs/VkComponentMapping.txt[]

  * pname:r 决定了输出向量中R成员的值。
  * pname:g 决定了输出向量中G成员的值。
  * pname:b 决定了输出向量中B成员的值。
  * pname:a 决定了输出向量中A成员的值。

pname:r, pname:g, pname:b, and pname:a 其一的值都是如下的一个:

// refBegin VkComponentSwizzle Specify how a component is swizzled
include::../api/enums/VkComponentSwizzle.txt[]

  * ename:VK_COMPONENT_SWIZZLE_IDENTITY: the component is set to the
    identity swizzle.
  * ename:VK_COMPONENT_SWIZZLE_ZERO: the component is set to zero.
  * ename:VK_COMPONENT_SWIZZLE_ONE: the component is set to either 1或 1.0
    depending on whether the type of该图像 view format is integer或
    floating-point respectively, as determined by the
    <<features-formats-definition,Format Definition>> section for each
    elink:VkFormat.
  * ename:VK_COMPONENT_SWIZZLE_R: the component is set to the value of the R
    component of该图像.
  * ename:VK_COMPONENT_SWIZZLE_G: the component is set to the value of the G
    component of该图像.
  * ename:VK_COMPONENT_SWIZZLE_B: the component is set to the value of the B
    component of该图像.
  * ename:VK_COMPONENT_SWIZZLE_A: the component is set to the value of the A
    component of该图像.

Setting the identity swizzle on a component is equivalent to setting the
identity mapping on that component.
That is:

[[resources-image-views-identity-mappings]]
.Component Mappings Equivalent To ename:VK_COMPONENT_SWIZZLE_IDENTITY
[options="header"]
|====
| Component          | Identity Mapping
| pname:components.r | ename:VK_COMPONENT_SWIZZLE_R
| pname:components.g | ename:VK_COMPONENT_SWIZZLE_G
| pname:components.b | ename:VK_COMPONENT_SWIZZLE_B
| pname:components.a | ename:VK_COMPONENT_SWIZZLE_A
|====

include::../validity/structs/VkComponentMapping.txt[]

// refBegin vkDestroyImageView Destroy an image view object

可调用下列命令来销毁图像视图：

include::../api/protos/vkDestroyImageView.txt[]

  * pname:device 是销毁图像视图的逻辑设备。
  * pname:imageView 是需要被销毁的图像视图。
  * pname:pAllocator 控制CPU端内存分配，如 <<memory-allocation, 内存分配 >> 一章详述。

.Valid Usage
****
  * 所有指向pname:imageView 的被提交的命令 必须已经完成执行。
  * 若当创建 pname:imageView 时提供了 sname:VkAllocationCallbacks，那么此处必须提供兼容的回调函数。
  * 若当创建  pname:imageView时没有提供sname:VkAllocationCallbacks ，那么此处 pname:pAllocator 必须为 `NULL`
****

include::../validity/protos/vkDestroyImageView.txt[]


[[resources-association]]
== 资源内存关联

资源初始都是以_虚拟分配_ 的方式创建的，并不占内存。
设备内存被单独分配（参看<<memory-device>>），然后再和资源关联上。
这个关联操作对于稀疏、非稀疏资源来说是不同的。

任何以稀疏标志创建资源都被认为是稀疏资源。
以这些标志之外的标志创建的资源被认为是非稀疏资源。
关于稀疏资源的内存关联在 <<sparsememory>>中有描述。

在资源被当作参数传递到以下任何一个操作之前，非稀疏资源必须完全并连续的绑定到一个sname:VkDeviceMemory 对象：

  * 创建图像或者缓冲区视图
  * 更新描述符集合
  * 在命令缓冲区中记录命令

一旦绑定了，内存绑定在资源的生命周期内就是不变的。

// refBegin vkGetBufferMemoryRequirements Returns the memory requirements for specified Vulkan object

想要知道一个缓冲区资源的内存限制条件，可调用：

include::../api/protos/vkGetBufferMemoryRequirements.txt[]

  * pname:device 是持有缓冲区的逻辑设备。
  * pname:buffer 被查询的缓冲区。
  * pname:pMemoryRequirements 指向一个 slink:VkMemoryRequirements实例，装载了被返回的内存限制条件信息。

include::../validity/protos/vkGetBufferMemoryRequirements.txt[]

// refBegin vkGetImageMemoryRequirements Returns the memory requirements for specified Vulkan object

想要知道图像资源内存限制条件，可调用：

include::../api/protos/vkGetImageMemoryRequirements.txt[]

  * pname:device 是拥有该图像的逻辑设备。
  * pname:image 是被查询的图像。
  * pname:pMemoryRequirements 指向了一个slink:VkMemoryRequirements是列，装载了该图像对象内存限制条件信息。

include::../validity/protos/vkGetImageMemoryRequirements.txt[]

// refBegin VkMemoryRequirements Structure specifying memory requirements

sname:VkMemoryRequirements类型数据结构定义如下：

include::../api/structs/VkMemoryRequirements.txt[]

  * pname:size 该资源所需的内存分配的大小，以字节为单位。
  * pname:alignment 是资源所要求的内存分配的对齐大小，以字节为单位。
  * pname:memoryTypeBits 是一个标志位，每一bit表示每一个受支持的内存类型。但是，
  只有当 `i` 在物理设备支持的内存类型 sname:VkPhysicalDeviceMemoryProperties中的时候，`i` 才会被设置。

include::../validity/structs/VkMemoryRequirements.txt[]

Vulkan实现保证关于内存限制条件的某些属性通过flink:vkGetBufferMemoryRequirements 和
flink:vkGetImageMemoryRequirements返回：

  * The pname:memoryTypeBits member always包含s至少 one bit set.
  * 若pname:buffer is a sname:VkBuffer not created with the
    ename:VK_BUFFER_CREATE_SPARSE_BINDING_BIT bit set,或 if pname:image is
    a sname:VkImage that was created with a ename:VK_IMAGE_TILING_LINEAR
    value in the pname:tiling member of the sname:VkImageCreateInfo
    structure passed to fname:vkCreateImage, then the pname:memoryTypeBits
    member always包含s至少 one bit set corresponding to a
    sname:VkMemoryType with a pname:propertyFlags that has both the
    ename:VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT bit and the
    ename:VK_MEMORY_PROPERTY_HOST_COHERENT_BIT bit set.
    In other words, mappable coherent memory可以 always be attached to
    these objects.
  * The pname:memoryTypeBits member always包含s至少 one bit set
    corresponding to a sname:VkMemoryType with a pname:propertyFlags that
    has the ename:VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT bit set.
  * The pname:memoryTypeBits member is identical for all sname:VkBuffer
    objects created with the same value for the pname:flags and pname:usage
    members in the sname:VkBufferCreateInfo structure passed to
    fname:vkCreateBuffer.
    Further, if code:usage1 and code:usage2 of type elink:VkBufferUsageFlags
    are such that the bits set in code:usage2 are a subset of the bits set
    in code:usage1, and they have the same pname:flags, then the bits set in
    pname:memoryTypeBits returned for code:usage1 必须 be a subset of the
    bits set in pname:memoryTypeBits returned for code:usage2, for all
    values of pname:flags.
  * The pname:alignment member is a power of two.
  * The pname:alignment member is identical for all sname:VkBuffer objects
    created with the same combination of values for the pname:usage and
    pname:flags members in the sname:VkBufferCreateInfo structure passed to
    fname:vkCreateBuffer.
  * For images created with a color format, the pname:memoryTypeBits member
    is identical for all sname:VkImage objects created with the same
    combination of values for the pname:tiling member, the
    ename:VK_IMAGE_CREATE_SPARSE_BINDING_BIT bit of the pname:flags member,
    and the ename:VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT of the pname:usage
    member in the sname:VkImageCreateInfo structure passed to
    fname:vkCreateImage.
  * For images created with a depth/stencil format, the pname:memoryTypeBits
    member is identical for all sname:VkImage objects created with the same
    combination of values for the pname:format member, the pname:tiling
    member, the ename:VK_IMAGE_CREATE_SPARSE_BINDING_BIT bit of the
    pname:flags member, and the
    ename:VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT of the pname:usage member
    in the sname:VkImageCreateInfo structure passed to fname:vkCreateImage.
  * 若the memory requirements are for a sname:VkImage, the
    pname:memoryTypeBits member 必须 not refer to a sname:VkMemoryType with
    a pname:propertyFlags that has the
    ename:VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT bit set if the
    flink:vkGetImageMemoryRequirements::pname:image did not have
    ename:VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT bit set in the pname:usage
    member of the sname:VkImageCreateInfo structure passed to
    fname:vkCreateImage.
  * 若the memory requirements are for a sname:VkBuffer, the
    pname:memoryTypeBits member 必须 not refer to a sname:VkMemoryType with
    a pname:propertyFlags that has the
    ename:VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT bit set.
+
--
[NOTE]
.注意
====
The implication of this requirement is that lazily allocated memory is
disallowed for buffers in all cases.
====
--

// refBegin vkBindBufferMemory Bind device memory to a buffer object

把内存附着在一个缓冲区对象，可调用：

include::../api/protos/vkBindBufferMemory.txt[]

  * pname:device 是拥有该缓冲区和内存的逻辑设备。
  * pname:buffer 是缓冲区。
  * pname:memory 是一个 sname:VkDeviceMemory 类型对象，描述了需附着的设备内存。
  * pname:memoryOffset 是  pname:memory区域的起始偏移，该内存被绑定到缓冲区上。    
    被返回的pname:memory的成员sname:VkMemoryRequirements::pname:size 带有的字节数，从pname:memoryOffset 开始的字节数，
	将被绑定到特定的缓冲区。

.Valid Usage
****
  * pname:buffer 必须 not already be backed by a memory object
  * pname:buffer 必须 not have been created with any sparse memory binding
    flags
  * pname:memoryOffset 必须 be小于 the size of pname:memory
  * 若pname:buffer was created with the
    ename:VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT或
    ename:VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT, pname:memoryOffset must:
    be a multiple of
    sname:VkPhysicalDeviceLimits::pname:minTexelBufferOffsetAlignment
  * 若pname:buffer was created with the
    ename:VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT, pname:memoryOffset 必须 be a
    multiple of
    sname:VkPhysicalDeviceLimits::pname:minUniformBufferOffsetAlignment
  * 若pname:buffer was created with the
    ename:VK_BUFFER_USAGE_STORAGE_BUFFER_BIT, pname:memoryOffset 必须 be a
    multiple of
    sname:VkPhysicalDeviceLimits::pname:minStorageBufferOffsetAlignment
  * pname:memory 必须 have been allocated using one of the memory types
    allowed in the pname:memoryTypeBits member of the
    sname:VkMemoryRequirements structure returned from a call to
    fname:vkGetBufferMemoryRequirements with pname:buffer
  * pname:memoryOffset 必须 be an integer multiple of the pname:alignment
    member of the sname:VkMemoryRequirements structure returned from a call
    to fname:vkGetBufferMemoryRequirements with pname:buffer
  * The pname:size member of the sname:VkMemoryRequirements structure
    returned from a call to fname:vkGetBufferMemoryRequirements with
    pname:buffer 必须 be小于或 等于 the size of pname:memory
    minus pname:memoryOffset
ifdef::VK_NV_dedicated_allocation[]
  * 若pname:buffer was created with
    sname:VkDedicatedAllocationBufferCreateInfoNV::pname:dedicatedAllocation
    等于 ename:VK_TRUE, pname:memory 必须 have been created with
    sname:VkDedicatedAllocationMemoryAllocateInfoNV::pname:buffer 等于
    pname:buffer and pname:memoryOffset 必须 be zero
  * 若pname:buffer was not created with
    sname:VkDedicatedAllocationBufferCreateInfoNV::pname:dedicatedAllocation
    等于 ename:VK_TRUE, pname:memory 必须 not have been allocated
    dedicated for a specific buffer或 image
endif::VK_NV_dedicated_allocation[]
****

include::../validity/protos/vkBindBufferMemory.txt[]

// refBegin vkBindImageMemory Bind device memory to an image object

把内存附着到一个图像对象上，可调用：

include::../api/protos/vkBindImageMemory.txt[]

  * pname:device 是拥有该图像和内存的逻辑设备。
  * pname:image 是图像。
  * pname:memory 是一个sname:VkDeviceMemory对象，描述了需被附着的设备内存。
  * pname:memoryOffset is the start offset of the region of pname:memory
    which is to be bound to该图像.
    The number of bytes returned in the
    sname:VkMemoryRequirements::pname:size member in pname:memory, starting
    from pname:memoryOffset bytes, will be bound to the specified image.

.Valid Usage
****
  * pname:image 必须 not already be backed by a memory object
  * pname:image 必须 not have been created with any sparse memory binding
    flags
  * pname:memoryOffset 必须 be小于 the size of pname:memory
  * pname:memory 必须 have been allocated using one of the memory types
    allowed in the pname:memoryTypeBits member of the
    sname:VkMemoryRequirements structure returned from a call to
    fname:vkGetImageMemoryRequirements with pname:image
  * pname:memoryOffset 必须 be an integer multiple of the pname:alignment
    member of the sname:VkMemoryRequirements structure returned from a call
    to fname:vkGetImageMemoryRequirements with pname:image
  * The pname:size member of the sname:VkMemoryRequirements structure
    returned from a call to fname:vkGetImageMemoryRequirements with
    pname:image 必须 be小于或 等于 the size of pname:memory
    minus pname:memoryOffset
ifdef::VK_NV_dedicated_allocation[]
  * 若pname:image was created with
    sname:VkDedicatedAllocationImageCreateInfoNV::pname:dedicatedAllocation
    等于 ename:VK_TRUE, pname:memory 必须 have been created with
    sname:VkDedicatedAllocationMemoryAllocateInfoNV::pname:image 等于
    pname:image and pname:memoryOffset 必须 be zero
  * 若pname:image was not created with
    sname:VkDedicatedAllocationImageCreateInfoNV::pname:dedicatedAllocation
    等于 ename:VK_TRUE, pname:memory 必须 not have been allocated
    dedicated for a specific buffer或 image
endif::VK_NV_dedicated_allocation[]
****

include::../validity/protos/vkBindImageMemory.txt[]

[[resources-bufferimagegranularity,Buffer-Image Granularity]]
.Buffer-Image Granularity
There is an implementation-dependent limit, pname:bufferImageGranularity,
which specifies a page-like granularity at which buffer, linear image and
optimal image resources 必须 be placed in adjacent memory locations to
avoid aliasing.
Two resources which do not satisfy this granularity requirement are said to
<<resources-memory-aliasing,alias>>.
Linear image resource are images created with ename:VK_IMAGE_TILING_LINEAR
and optimal image resources are those created with
ename:VK_IMAGE_TILING_OPTIMAL.
pname:bufferImageGranularity is specified in bytes, and 必须 be a power of
two.
Implementations which do not require such an additional granularity may:
report a value of one.

[NOTE]
.注意
====
pname:bufferImageGranularity is really a granularity between "linear"
resources, including buffers and images with linear tiling, vs.
"optimal" resources, i.e. images with optimal tiling.
It would have been better named "linearOptimalGranularity".
====

Given resourceA at the lower memory offset and resourceB at the higher
memory offset in the same sname:VkDeviceMemory object, where one of the
resources is a buffer或 a linear image and the other is an optimal image,
and the following:

[source,c]
---------------------------------------------------
resourceA.end       = resourceA.memoryOffset + resourceA.size - 1
resourceA.endPage   = resourceA.end & ~(bufferImageGranularity-1)
resourceB.start     = resourceB.memoryOffset
resourceB.startPage = resourceB.start & ~(bufferImageGranularity-1)
---------------------------------------------------

The following property 必须 hold:

[source,c]
---------------------------------------------------
resourceA.endPage < resourceB.startPage
---------------------------------------------------

That is, the end of the first resource (A) and the beginning of the second
resource (B) 必须 be on separate "`pages`" of size
pname:bufferImageGranularity.
pname:bufferImageGranularity may: be different than the physical page size
of the memory heap.
This restriction is only needed when a buffer或 a linear image is at
adjacent memory location with an optimal image and both will被用于
simultaneously.
Adjacent buffers'或 adjacent images' memory ranges可以 be closer than
pname:bufferImageGranularity, provided they meet the pname:alignment
requirement for the objects in question.

Sparse block size in bytes and sparse image and buffer memory alignments
必须 all be multiples of the pname:bufferImageGranularity.
Therefore, memory bound to sparse resources naturally satisfies the
pname:bufferImageGranularity.

[[resources-sharing]]
== 资源共享模式

// refBegin VkSharingMode Buffer and image sharing modes

缓冲区和图像对象能以 _共享模式_ 被创建，控制它们如何被队列访问。
受支持的共享模式如下：

include::../api/enums/VkSharingMode.txt[]

  * ename:VK_SHARING_MODE_EXCLUSIVE specifies that access to any range或
    image subresource of the object will be exclusive to a single queue
    family at a time.
  * ename:VK_SHARING_MODE_CONCURRENT specifies that concurrent access to any
    range或 image subresource of the object from multiple queue families is
    supported.

[NOTE]
.注意
====
与ename:VK_SHARING_MODE_EXCLUSIVE相比，ename:VK_SHARING_MODE_CONCURRENT 也许会导致访问缓冲区或者图像时效率较低。
====

Ranges of buffers and image subresources of image objects created using
ename:VK_SHARING_MODE_EXCLUSIVE 必须 only be accessed by queues in the same
queue family at any given time.
In或der for a different queue family to be able to interpret the memory
contents of a range或 image subresource, the application 必须 perform a
<<synchronization-queue-transfers,queue family ownership transfer>>.

Upon creation, resources using ename:VK_SHARING_MODE_EXCLUSIVE are not owned
by any queue family.
A buffer或 image memory barrier is not required to acquire _ownership_ when
no queue family owns the resource - it is implicitly acquired upon first use
within a queue.

[NOTE]
.注意
====
Images still require a <<resources-image-layouts, layout transition>> from
ename:VK_IMAGE_LAYOUT_UNDEFINED或 ename:VK_IMAGE_LAYOUT_PREINITIALIZED
before being used on the first queue.
====

A queue family可以 take ownership of an image subresource或 buffer range
of a resource created with ename:VK_SHARING_MODE_EXCLUSIVE, without an
ownership transfer, in the same way as for a resource that was just created;
however, taking ownership in this way has the effect that the contents of
the image subresource或 buffer range are undefined.

Ranges of buffers and image subresources of image objects created using
ename:VK_SHARING_MODE_CONCURRENT 必须 only be accessed by queues from the
queue families specified through the pname:queueFamilyIndexCount and
pname:pQueueFamilyIndices members of the corresponding create info
structures.

// refEnd VkSharingMode


[[resources-memory-aliasing]]
== 内存别名

sname:VkDeviceMemory 内存的一段区间可以被称为 _aliased_（被别名），若它通过 flink:vkBindImageMemory，
flink:vkBindBufferMemory，或者通过<<sparsememory-resource-binding,稀疏内存绑定>>，被同时绑定到多个资源上。
在两个图像或者两个缓冲区之间的 一段别名内存区间，其定义是：在绑定到两个资源上的内存的一段内存区间。
在两个资源之间（一个是缓冲区或者线性图像，另一个是优化图像）的 一个内存区间别名，其他定义是 绑定到两个资源的内存区间的
相交区域。每个区间首先被填补并按照pname:bufferImageGranularity 对齐。
应用程序可以给内存起别名，但是使用多个别名需要遵循多个限制条件。


[NOTE]
.注意
====
如果一些大型的资源被用于不连续的阶段，内存别名可以有效的减少应用程序中设备内存使用痕迹。
====

当一个不透明，非 ename:VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT 图像被绑定到一个别名区间，图像所有的
图像子资源 在区间上重叠。
当一个线性图像被绑定到一个别名区间，包含 别名区间的图像子资源（遵顼图像被建议的布局方式）将重叠该区域。
当一个 ename:VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT 图像有稀疏图像块被绑定一个别名区间上，
只有包含这些稀疏图像块的图像子资源会重叠该区间，且当内存被绑定到图像的mip tail与别名区间重叠时，mip tail中的图像子资源
将重叠该区间。

在ename:VK_IMAGE_LAYOUT_PREINITIALIZED 或者 ename:VK_IMAGE_LAYOUT_GENERAL 
布局的缓冲区，线性图像子资源，都是  _host-accessible subresources_。
亦即，只有host端能够正确的寻址，并解释其内容，故若这些别名时是host-accessible 子资源，内存中数据的布局可以通过别名被一致性的解释。
其他布局下的不透明图像和图像子资源，不是host-accessible。

若两个别名都是both host-accessible，那么它们使用一致的方式去解读内存的内容，且写入到别名内的数据可以被另外一个别名读取。


若两个别名都不是host-accessible，那么别名依不同的方式解读内存的内容，通过一个别名写入的内容对于另外一个别名来说也是部分或全未定义的。
若第一个别名是 host-accessible 子资源，那么受影响的字节，是那些通过它的寻址方式内存操作写入的部分。
若第一个别名不能被主机端访问，那么被影响的字节是那些被写入的图像子资源重叠的部分。
若第二个别名是不能被主机端访问的子资源，那么被影响的字节将变得未定义。
若第二个别名不能被主机端访问，所有的稀疏图像块（为稀疏部分驻留图像）或者所有的图像子资源（为非稀疏图像和全驻留稀疏图像）重叠的字节将变得未定义。

若any image subresources are made undefined due to writes to an alias, then
each of those image subresources 必须 have its layout transitioned from
ename:VK_IMAGE_LAYOUT_UNDEFINED to a valid layout before it is used,或 from
ename:VK_IMAGE_LAYOUT_PREINITIALIZED if the memory has been written by the
host.
若any sparse blocks of a sparse image have been made undefined, then only
the image subresources包含ing them 必须 be transitioned.

Use of an overlapping range by two aliases 必须 be separated by a memory
dependency using the appropriate <<synchronization-access-types, access
types>> if至少 one of those uses performs writes, whether the aliases
interpret memory consistently或 not.
若buffer或 image memory barriers are used, the scope of the barrier must:
contain the entire range and/or set of image subresources that overlap.

若在同一个缓冲区中使用两个别名图像视图，那么render pass 必须使用 <<renderpass-aliasing,ename:VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT>>
声明附件，且必须符合该节中其他的规则。

在着色器中使用 code:Coherent修饰的变量来访问别名内存的资源，将不会自动保持一致性。

[NOTE]
.注意
====
Memory recycled via an application suballocator (i.e. without freeing and
reallocating the memory objects) is not substantially different from memory
aliasing.
However, a suballocator usually waits on a fence before recycling a region
of memory, and signaling a fence involves sufficient implicit dependencies
to satisfy all the above requirements.
====
