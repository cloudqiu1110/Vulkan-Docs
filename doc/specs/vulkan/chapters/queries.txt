// Copyright (c) 2015-2017 The Khronos Group Inc.
// Copyright notice at https://www.khronos.org/registry/speccopyright.html

[[queries]]
= 查询

_Queries_ 提供了一种机制，返回关于处理一个队列的vulkan命令的返回值的有关信息。
查询操作是异步的，故，它们的结果并不会立即被返回。
相反，它们的结果与它们可用性的状态，被存储在一个 <<queries-pools, 查询池>>.
这些查询的状态可以在CPU端读取，或者复制到device上一个缓冲区对象。

受支持的查询类型是<<queries-occlusion,Occlusion Queries>>,
<<queries-pipestats,Pipeline Statistics Queries>>, 和 <<queries-timestamps,
Timestamp Queries>>。


[[queries-pools]]
== 查询池

// refBegin VkQueryPool Opaque handle to a query pool object

使用 _query pool_ 对象来管理查询。
每一个查询池是一个特定类型的查询的集合。

可使用 sname:VkQueryPool handles 来表示查询池：

include::../api/handles/VkQueryPool.txt[]

// refEnd VkQueryPool

// refBegin vkCreateQueryPool Create a new query pool object

可调用如下命令来创建一个查询池：:

include::../api/protos/vkCreateQueryPool.txt[]

  * pname:device 是创建查询池的逻辑设备。
  * pname:pCreateInfo 是一个指针，指向一个 sname:VkQueryPoolCreateInfo 数据结构实例， 包含池所管理的查询的类型与数量。
  * pname:pAllocator 控制CPU端内存分配，如  <<memory-allocation, Memory Allocation>> 章描述。
  * pname:pQueryPool 是一个指针，指向一个  sname:VkQueryPool handle，它是被返回的查询池对象。
    resulting query pool object is returned.

include::../validity/protos/vkCreateQueryPool.txt[]

// refBegin VkQueryPoolCreateInfo Structure specifying parameters of a newly created query pool

sname:VkQueryPoolCreateInfo 类型数据结构定义如下：

include::../api/structs/VkQueryPoolCreateInfo.txt[]

  * pname:sType 是数据结构的类型。
  * pname:pNext 是 `NULL` 或者一个指向拓展特定的数据结构的指针。
  * pname:flags 被保留。
  * pname:queryType 是池所管理的查询的类型，必须是如下值之一：
    one of the values
+
--
// refBegin VkQueryType Specify the type of queries managed by a query pool
include::../api/enums/VkQueryType.txt[]
--
  * pname:queryCount 是池所管理的查询的数量。
  * pname:pipelineStatistics 是一个位掩码，指示新的池中查询返回的计数，如下所述  <<queries-pipestats>>。
    若 pname:queryType 不是 ename:VK_QUERY_TYPE_PIPELINE_STATISTICS， pname:pipelineStatistics 就会被忽略。

.正确使用
****
  * 若 <<features-features-pipelineStatisticsQuery, pipeline statistics
    queries>> 特征没有被启用， pname:queryType 不能是    ename:VK_QUERY_TYPE_PIPELINE_STATISTICS
  * 若pname:queryType 是 ename:VK_QUERY_TYPE_PIPELINE_STATISTICS，
    pname:pipelineStatistics 必须是 elink:VkQueryPipelineStatisticFlagBits 值的位运算结果。
****

include::../validity/structs/VkQueryPoolCreateInfo.txt[]

// refBegin vkDestroyQueryPool Destroy a query pool object

可调用如下命令来销毁一个查询池：

include::../api/protos/vkDestroyQueryPool.txt[]

  * pname:device 是销毁查询池的逻辑设备。
  * pname:queryPool 需要被销毁的查询池。
  * pname:pAllocator 控制CPU端内存分配，如  <<memory-allocation, Memory Allocation>> 章所述。

.正确使用
****
  * 所有涉及到 pname:queryPool 的已提交命令必须已经完成。
  * 若 创建pname:queryPool 时提供了sname:VkAllocationCallbacks，那么必须在此处提供兼容的一系列回调。    
  * 若 创建  pname:queryPool 时没有提供sname:VkAllocationCallbacks，pname:pAllocator 必须为 `NULL`。
****

include::../validity/protos/vkDestroyQueryPool.txt[]


[[queries-operation]]
== 查询操作

查询操作受 flink:vkCmdBeginQuery，flink:vkCmdEndQuery，flink:vkCmdResetQueryPool，
flink:vkCmdCopyQueryPoolResults， 和 flink:vkCmdWriteTimestamp 命令控制。

为了让 sname:VkCommandBuffer 记录查询管理命令，为sname:VkCommandPool创建的队列族必须支持针对一个给定查询池的查询类型而言合适的操作的类型（图形、计算）。

查询池中每个查询都有一个状态量，要么是 _unavailable_ ，要么是_available_，且有查询池按照操作类型而创建的一个存储查询操作的数值结果。

可通过 flink:vkCmdResetQueryPool 重置一个查询可设置其状态为unavailable 且让数值结果变得未定义。
当查询<<queries-operation-finished, 完成>>了，通过 flink:vkCmdBeginQuery 操作和flink:vkCmdEndQuery 来执行查询操作，可把状态变为available，
且更新数值结果。
可通过 flink:vkGetQueryPoolResults 或者 flink:vkCmdCopyQueryPoolResults来获取可用性状态和数值结果。

[[queries-order]]
Query commands, for the same query and submitted to the same queue, execute
in their entirety in <<synchronization-submission-order, submission order>>,
relative to each other.
In effect there is an implicit execution dependency from each such query
command to all query command previously submitted to the same queue.
There is one significant exception to this; if the pname:flags parameter of
flink:vkCmdCopyQueryPoolResults does not include
ename:VK_QUERY_RESULT_WAIT_BIT, execution of flink:vkCmdCopyQueryPoolResults
may: happen-before the results of flink:vkCmdEndQuery are available.

查询池创建了之后，每一个查询都处于未定义状态，且必须在使用之前被重置。
查询必须在每次使用之前都需要被重置。
使用了一个未重置的查询，其结果是未定义的。

// refBegin vkCmdResetQueryPool Reset queries in a query pool

可调用如下命令来重置查询池中一个区间的查询：:

include::../api/protos/vkCmdResetQueryPool.txt[]

  * pname:commandBuffer 是记录命令的命令缓冲区。
  * pname:queryPool 是管理需要被重置的查询的查询池handle。
  * pname:firstQuery 需要被重置的起始查询索引。
  * pname:queryCount 是需要重置的查询个数。

When executed on a queue, this command sets the status of query indices
[eq]#[pname:firstQuery, pname:firstQuery + pname:queryCount - 1]# to
unavailable.

.正确使用
****
  * pname:firstQuery 必须小于  pname:queryPool中查询的个数。
  * pname:firstQuery 与 pname:queryCount 之和必须小于等于 pname:queryPool中查询的个数。
****

include::../validity/protos/vkCmdResetQueryPool.txt[]

一旦查询被重置，可以被使用，查询命令就可以被记录到命令缓冲区了。
遮挡查询和管线统计查询记录事件-各自对应采样绘制和阶段调用-
Occlusion queries and pipeline statistics queries count events - drawn
samples and pipeline stage invocations, respectively -来自于一个特定命令缓冲区的flink:vkCmdBeginQuery 命令和
flink:vkCmdEndQuery 命令之间，有效的限定了一系列的绘制和计算命令。时间戳查询记录时间戳到查询池。

一个查询必须在同一个命令缓冲区中开始与结束，即使这是一个主命令缓冲区，且
<<features-features-inheritedQueries,inherited queries>> 特征被开启了。
它可以在查询操作期间执行次级命令缓冲。
对于查询激活期间执行的一个次级命令缓冲区，它必须设置slink:VkCommandBufferInheritanceInfo的成员 pname:occlusionQueryEnable, pname:queryFlags, 和/或 pname:pipelineStatistics 
为保留值，如 <<commandbuffers-recording, Command Buffer Recording>> 小节所描述。
一个查询要么在同一个render pass实例的subpass中开始和结束，要们在一个render pass实例之外开始和结束
(i.e. 包含整个render pass实例)。

// refBegin vkCmdBeginQuery Begin a query

调用如下命令来开始一个查询：

include::../api/protos/vkCmdBeginQuery.txt[]

  * pname:commandBuffer 是记录此命令的命令缓冲区。
  * pname:queryPool 是管理查询结果的查询池。
  * pname:query 是包含结果的查询池内查询的索引。
  * pname:flags i是一个位掩码，包含指示可以执行的查询你类型的限制条件。
    Bits which can: be set include:
+
// refBegin VkQueryControlFlagBits Bitmask specifying constraints on a query
include::../api/enums/VkQueryControlFlagBits.txt[]

若池的 pname:queryType 是ename:VK_QUERY_TYPE_OCCLUSION 且
pname:flags 包含 ename:VK_QUERY_CONTROL_PRECISE_BIT，vulakn实现必须返回匹配传入的实际采样数。
详细信息在 <<queries-occlusion,Occlusion Queries>>小节。

[[queries-operation-active]]
在一个查询开始后，此查询就被认为在被调用的命令缓冲区内就是  _active_ 的，直到相同的查询结束。
Queries active in a primary command buffer when secondary command buffers
are executed are considered active for those secondary command buffers.

.正确使用
****
  * The query identified by pname:queryPool and pname:query must: currently
    not be <<queries-operation-active,active>>
  * pname:queryPool 和 pname:query 指定的查询必须是非可用状态。
  * 若 <<features-features-occlusionQueryPrecise, 精确遮挡查询 >> 特征被启用，或者 被用于创建  pname:queryPool的pname:queryType并不是  
     ename:VK_QUERY_TYPE_OCCLUSION, pname:flags 不能包含 ename:VK_QUERY_CONTROL_PRECISE_BIT
  * pname:queryPool 必须在创建是带有 pname:queryType 标志，以区别于那些已经被
    <<queries-operation-active, 激活>>，且在pname:commandBuffer内仍处于激活状态的查询.
  * pname:query 必须小于pname:queryPool 中查询的数量
  * 若被用于创建pname:queryPool的 pname:queryType 是 ename:VK_QUERY_TYPE_OCCLUSION，分配pname:commandBuffer的sname:VkCommandPool 必须支持图形操作。
  * 若被用于创建pname:queryPool的 pname:queryType 是  ename:VK_QUERY_TYPE_PIPELINE_STATISTICS 且  
    pname:pipelineStatistics 中任何一个都是图形操作， 分配pname:commandBuffer 的
    sname:VkCommandPool 必须支持图形操作。
  * 若被用于创建pname:queryPool的pname:queryType 是 
    ename:VK_QUERY_TYPE_PIPELINE_STATISTICS 且 
    pname:pipelineStatistics 中任何一个都是计算操作， 分配pname:commandBuffer 的sname:VkCommandPool 表现支持计算操作。
****

include::../validity/protos/vkCmdBeginQuery.txt[]

// refBegin vkCmdEndQuery Ends a query

在目标的一系列绘制或者分发命令之后，可调用如下命令来结束一个查询，:

include::../api/protos/vkCmdEndQuery.txt[]

  * pname:commandBuffer 是记录命令的命令缓冲区。
  * pname:queryPool 是管理查询结果的查询池。
  * pname:query 是储存结果的查询池中查询的索引。 

[[queries-operation-finished]]
查询是异步的，结束一个查询并不会立即设置查询的状态为可用状态。
一个查询，只有在其结果准备好被 flink:vkGetQueryPoolResults 和
flink:vkCmdCopyQueryPoolResults 获取时，才能被认为是 完成了，此时，查询的状态才被设置为可用。

一旦一个查询结束了，查询被吸在有限时间内完成，除非查询的状态被其他命令改变，例如使用命令重置了查询。

.正确使用
****
  * pname:queryPool 和 pname:query 确定的查询，必须在当前是 
      <<queries-operation-active, 激活的>>
  * pname:query 必须小于 pname:queryPool中查询的数量。
****

include::../validity/protos/vkCmdEndQuery.txt[]

[[queries-operation-memorylayout]]
应用程序可以通过把它们写入应用程序指定的内存，或者要求它们复制到一个 sname:VkBuffer 来获取结果。
任一情形，内存的布局的定义如下：

  * The first query's result is written starting at the first byte requested
    by the command, and each subsequent query's result begins pname:stride
    bytes later.
  * Each query's result is a tightly packed array of unsigned integers,
    either 32- or 64-bits as requested by the command, storing the numerical
    results and, if requested, the availability status.
  * If ename:VK_QUERY_RESULT_WITH_AVAILABILITY_BIT is used, the final
    element of each query's result is an integer indicating whether the
    query's result is available, with any non-zero value indicating that it
    is available.
  * Occlusion queries write one integer value - the number of samples
    passed.
    Pipeline statistics queries write one integer value for each bit that is
    enabled in the pname:pipelineStatistics when the pool is created, and
    the statistics values are written in bit order starting from the least
    significant bit.
    Timestamps write one integer value.
  * If more than one query is retrieved and pname:stride is not at least as
    large as the size of the array of integers corresponding to a single
    query, the values written to memory are undefined.

// refBegin vkGetQueryPoolResults Copy results of queries in a query pool to a host memory region

To retrieve status and results for a set of queries, call:

include::../api/protos/vkGetQueryPoolResults.txt[]

  * pname:device 是持有该查询池的逻辑设备。
  * pname:queryPool 管理包含期望结果的查询的查询池。
  * pname:firstQuery 是初始查询的索引。
  * pname:queryCount 是查询的数量。
    pname:firstQuery 和 pname:queryCount 逻辑上定义了查询的一个范围。
  * pname:dataSize 是  pname:pData指向的缓冲区的字节大小。
  * pname:pData 是一个指针，指向用户定义的一个缓冲区，包含将要写入的结果。
  * pname:stride 是pname:pData中每个独立查询之间的步长。
  * pname:flags 是一个位掩码，  elink:VkQueryResultFlagBits 类型，指定了结果将如何、何时返回。
    可以设置的bit 包含如下：
+
--
// refBegin VkQueryResultFlagBits Bitmask specifying how and when query results are returned
include::../api/enums/VkQueryResultFlagBits.txt[]
--
+
  ** ename:VK_QUERY_RESULT_64_BIT 表示结果将被当作64bit无符号整型的数组写入。若这个bit没有被设置，结果将被当作32bit无符号整型值数组写入。
  ** ename:VK_QUERY_RESULT_WAIT_BIT 表示Vulkan将在获取结果之前等待每个查询的状态变为可用。
  ** ename:VK_QUERY_RESULT_WITH_AVAILABILITY_BIT 表示 可用性状态和结果在一起。 
  ** ename:VK_QUERY_RESULT_PARTIAL_BIT 表示返回部分结果也是可以接受的。

If no bits are set in若 pname:flags中没有设置任何bit，且所有请求的查询都处于可用状态，结果就会以32bit无符号整型值数组写入。
当并非所有查询都是可用状态时的行为，在<<queries-wait-bit-not-set, 下方>>描述。

若ename:VK_QUERY_RESULT_64_BIT 没有被设置，且结果32-bit值溢出，那么结果将wrap或者饱和。
同理，若 ename:VK_QUERY_RESULT_64_BIT 被设置，且结果64bit溢出，结果将wrap或者饱和。

若 ename:VK_QUERY_RESULT_WAIT_BIT 被设置，Vulkan 将在获取查询的数值结果之前等待每个查询变为可用状态。
此情形下，若在有限的时间内查询变为可用状态( 亦即，它们已经被发出且没有被重置)，fname:vkGetQueryPoolResults 保证成功，且返回ename:VK_SUCCESS。
若查询永远不会完成(亦即由于被重置了却未被发出)，那么 fname:vkGetQueryPoolResults 将不会在有限时间内返回。

[[queries-wait-bit-not-set]]
若ename:VK_QUERY_RESULT_WAIT_BIT 和 ename:VK_QUERY_RESULT_PARTIAL_BIT 都未被设置，那么，对于在调用时处于非可用状态的查询，没有数据将会被写入到
pname:pData  ，且fname:vkGetQueryPoolResults 返回 ename:VK_NOT_READY。
然而，若 ename:VK_QUERY_RESULT_WITH_AVAILABILITY_BIT 被设置，对于那些查询，可用性状态仍被写入到 pname:pData。

[NOTE]
.注意
====
应用程序必须小心保证
ename:VK_QUERY_RESULT_WAIT_BIT bit 的使用有期望的效果。

例如，若一个查询在之前已经被使用，且一个命令缓冲区为该查询记录了命令 fname:vkCmdResetQueryPool， fname:vkCmdBeginQuery和
fname:vkCmdEndQuery，那么该查询将持续处于可用性状态，直至 fname:vkCmdResetQueryPool 命令在队列上被执行。
应用程序可使用栅栏或者事件来保证查询在检查结果或者可用性状态之前已经被重置。
否则，状态值可用是上一次查询的结果。

当ename:VK_QUERY_RESULT_WAIT_BIT 和 
 ename:VK_QUERY_RESULT_WITH_AVAILABILITY_BIT 联合使用时，如上的规则也有效。
 此情形下，返回的可用性状态可能反映了前一次查询的结果，除非 fname:vkCmdResetQueryPool 命令在上一次使用查询之后已经被执行了。
====

[NOTE]
.注意
====
应用程序可以使用双缓冲查询池，每一帧用一个池，且在帧结束后重置查询。
====

若 ename:VK_QUERY_RESULT_PARTIAL_BIT 被设置了，ename:VK_QUERY_RESULT_WAIT_BIT没有被设置，且
查询的状态是非可用，对于该查询，一个0到最终产生值之间的立即值将被写入到pname:pData。

若池的pname:queryType 是 ename:VK_QUERY_TYPE_TIMESTAMP，ename:VK_QUERY_RESULT_PARTIAL_BIT 不能被使用。

如果ename:VK_QUERY_RESULT_WITH_AVAILABILITY_BIT 被设置，若查询的状态是可用状态,对于每个查询最终写入的整型值是非0，若状态是非可用状态，结果是0.
当 ename:VK_QUERY_RESULT_WITH_AVAILABILITY_BIT 被使用，Vulkan实现必须保证若他们返回一个非0可用性值，那么数值结果必须是有效的，假设结果没有被后续的命令重置。

[NOTE]
.注意
====
Satisfying this guarantee may: require careful ordering by the application,
e.g. to read the availability status before reading the results.
====

.正确使用
****
  * pname:firstQuery 必须小于 pname:queryPool中查询的数量。
  * 若ename:VK_QUERY_RESULT_64_BIT 不在  pname:flags 中，那么 pname:pData 和 pname:stride 必须是  `4`的倍数
  * 若 ename:VK_QUERY_RESULT_64_BIT 在 pname:flags 中，那么 pname:pData和 pname:stride 必须是 `8`的倍数
  * pname:firstQuery 和 pname:queryCount 之和必须小于等于pname:queryPool中查询的数量
  * pname:dataSize 必须足够大，以包含每个查询的结果，如 <<queries-operation-memorylayout, 此处>>描述
  * 若 用于创建 pname:queryPool 的pname:queryType 是
    ename:VK_QUERY_TYPE_TIMESTAMP， pname:flags 不能包含
    ename:VK_QUERY_RESULT_PARTIAL_BIT
****

include::../validity/protos/vkGetQueryPoolResults.txt[]

// refBegin vkCmdCopyQueryPoolResults Copy the results of queries in a query pool to a buffer object

可调用如下命令来复制查询状态和数值结果直接到缓冲区内存：

include::../api/protos/vkCmdCopyQueryPoolResults.txt[]

  * pname:commandBuffer 是记录本命令的命令缓冲区。
  * pname:queryPool 是管理包含期望结果的查询的查询池。
  * pname:firstQuery 是初始查询的索引。
  * pname:queryCount 是查询的数量。
    pname:firstQuery 和 pname:queryCount 一起定义了一个范围的查询。
  * pname:dstBuffer 是一个 sname:VkBuffer 对象，包含接受copy命令结果。
  * pname:dstOffset 是pname:dstBuffer的偏移
  * pname:stride 是 pname:dstBuffer内每个查询结果之间的步长
      pname:dstBuffer 实际内存的申请大小由上面提到的 flink:vkGetQueryPoolResults决定
  * pname:flags 是一个位掩码 elink:VkQueryResultFlagBits ，指定了结果如何、何时被返回

fname:vkCmdCopyQueryPoolResults 被保证可以看到上一次使用同一个队列中的 fname:vkCmdResetQueryPool 结果，不需要同步。
故，结果总是反映了最近一次查询的影响。

pname:flags has the same possible values described above for the pname:flags
parameter of flink:vkGetQueryPoolResults, but the different style of
execution causes some subtle behavioral differences.
Because fname:vkCmdCopyQueryPoolResults executes in order with respect to
other query commands, there is less ambiguity about which use of a query is
being requested.

若 pname:flags中没有设置bit，所有处于可用状态的要求的查询的结果被当作32-bit无符号整型写入，对于处于非可用状态的查询，不会写入结果。

若设置了 ename:VK_QUERY_RESULT_64_BIT，结果就会被当作64-bit无符号整型数组写入，如
flink:vkGetQueryPoolResults所描述。

若 ename:VK_QUERY_RESULT_WAIT_BIT 被设置，Vulkan实现将在获取到该查询的数值结果之前等待每个查询的状态变为可用状态。
这保证反映了最近一次对同一个队列使用查询所带来的影响，假定查询不会被其他队列同时使用。
若查询在有限时间内（比如，从上一次重置后没有激发新的查询）并不变为可用状态 ，会抛出一个  ename:VK_ERROR_DEVICE_LOST 错误。

同样，若 ename:VK_QUERY_RESULT_WITH_AVAILABILITY_BIT 被设置，且ename:VK_QUERY_RESULT_WAIT_BIT 没有被设置，可用性被保证反映同一个
队列上查询最近一次使用，假定该查询没有同时被其他队列好似用。
和 fname:vkGetQueryPoolResults同样，Vulkan实现必须保证若它们返回一个非0可用值，那么数值结果就是有效的。


若 ename:VK_QUERY_RESULT_PARTIAL_BIT 被设置，ename:VK_QUERY_RESULT_WAIT_BIT没有被设置，且查询处于非可用状态，就会为该查询写入 0和最终结果值之间的一个值。

若池的pname:queryType 是 ename:VK_QUERY_TYPE_TIMESTAMP，ename:VK_QUERY_RESULT_PARTIAL_BIT 不能被使用，

fname:vkCmdCopyQueryPoolResults 被认为是一个转移操作，在使用结果之前，它对于缓冲区内存的写入必须使用 
ename:VK_PIPELINE_STAGE_TRANSFER_BIT 和 ename:VK_ACCESS_TRANSFER_WRITE_BIT 来同步。

.正确使用
****
  * pname:dstOffset 必须小于 pname:dstBuffer的大小
  * pname:firstQuery 必须小于 pname:queryPool中查询的数量
  * pname:firstQuery 和 pname:queryCount 之和必须小于等于 pname:queryPool中查询的数量
  * 若 ename:VK_QUERY_RESULT_64_BIT 没有被设置给pname:flags，那么
    pname:dstOffset 和 pname:stride 必须是  `4`的倍数
  * 若ename:VK_QUERY_RESULT_64_BIT 设置给pname:flags 那么
    pname:dstOffset 和 pname:stride 必须是`8`的倍数
  * pname:dstBuffer 从 pname:dstOffset开始必须足够大，以包含每个查询的结果，如 
    <<queries-operation-memorylayout, 此处>>所描述
  * pname:dstBuffer 必须在创建时带有
    ename:VK_BUFFER_USAGE_TRANSFER_DST_BIT 使用标志 
  * 若 pname:dstBuffer 是非稀疏的，那么它必须被完全且连续绑定到一个sname:VkDeviceMemory 对象
  * 若创建pname:queryPool 时 pname:queryType是
    ename:VK_QUERY_TYPE_TIMESTAMP，pname:flags 不能包含 ename:VK_QUERY_RESULT_PARTIAL_BIT
****

include::../validity/protos/vkCmdCopyQueryPoolResults.txt[]


[[queries-operation-undefined]]
Rendering operations such as clears, MSAA resolves, attachment load/store
operations, and blits may: count towards the results of queries.
This behavior is implementation-dependent and may: vary depending on the
path used within an implementation.
For example, some implementations have several types of clears, some of
which may: include vertices and some not.


[[queries-occlusion]]
== 遮挡查询

Occlusion queries track the number of samples that pass the per-fragment
tests for a set of drawing commands.
As such, occlusion queries are only available on queue families supporting
graphics operations.
The application can: then use these results to inform future rendering
decisions.
An occlusion query is begun and ended by calling fname:vkCmdBeginQuery and
fname:vkCmdEndQuery, respectively.
When an occlusion query begins, the count of passing samples always starts
at zero.
For each drawing command, the count is incremented as described in
<<fragops-samplecount,Sample Counting>>.
If pname:flags does not contain ename:VK_QUERY_CONTROL_PRECISE_BIT an
implementation may: generate any non-zero result value for the query if the
count of passing samples is non-zero.

[NOTE]
.注意
====
Not setting ename:VK_QUERY_CONTROL_PRECISE_BIT mode may: be more efficient
on some implementations, and should: be used where it is sufficient to know
a boolean result on whether any samples passed the per-fragment tests.
In this case, some implementations may: only return zero or one, indifferent
to the actual number of samples passing the per-fragment tests.
====

When an occlusion query finishes, the result for that query is marked as
available.
The application can: then either copy the result to a buffer (via
fname:vkCmdCopyQueryPoolResults) or request it be put into host memory (via
fname:vkGetQueryPoolResults).

[NOTE]
.注意
====
If occluding geometry is not drawn first, samples can: pass the depth test,
but still not be visible in a final image.
====


[[queries-pipestats]]
== 管线统计查询

Pipeline statistics queries allow the application to sample a specified set
of sname:VkPipeline counters.
These counters are accumulated by Vulkan for a set of either draw or
dispatch commands while a pipeline statistics query is active.
As such, pipeline statistics queries are available on queue families
supporting either graphics or compute operations.
Further, the availability of pipeline statistics queries is indicated by the
pname:pipelineStatisticsQuery member of the sname:VkPhysicalDeviceFeatures
object (see fname:vkGetPhysicalDeviceFeatures and fname:vkCreateDevice for
detecting and requesting this query type on a sname:VkDevice).

A pipeline statistics query is begun and ended by calling
fname:vkCmdBeginQuery and fname:vkCmdEndQuery, respectively.
When a pipeline statistics query begins, all statistics counters are set to
zero.
While the query is active, the pipeline type determines which set of
statistics are available, but these must: be configured on the query pool
when it is created.
If a statistic counter is issued on a command buffer that does not support
the corresponding operation, that counter is undefined after the query has
finished.
At least one statistic counter relevant to the operations supported on the
recording command buffer must: be enabled.

The pipeline statistic counters are individually enabled for query pools
with sname:VkQueryPoolCreateInfo::pname:pipelineStatistics, and for
secondary command buffers with
sname:VkCommandBufferInheritanceInfo::pname:pipelineStatistics.

// refBegin VkQueryPipelineStatisticFlagBits Bitmask specifying queried pipeline statistics

pname:pipelineStatistics 中可以设置的位包含如下：

include::../api/enums/VkQueryPipelineStatisticFlagBits.txt[]

这些bit有如下含义：

  *若 ename:VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_VERTICES_BIT 被设置，
    池所管理的查询将记录<<drawing,input assembly>>阶段处理的顶点数量。 
    对于不完整的图元的顶点，也包含在内。
  * 若 ename:VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_PRIMITIVES_BIT 被设置，
    池所管理的查询将记录<<drawing,input assembly>> 阶段所处理的图元数量。
    若 primitive restart 被开启，重启图元拓扑对于数量没有影响。不完整的图元也会被计数。    
  * 若 ename:VK_QUERY_PIPELINE_STATISTIC_VERTEX_SHADER_INVOCATIONS_BIT 被设置，
    池所管理的查询将记录顶点着色器被调用的次数。计数器的值在每个顶点着色器被    <<shaders-vertex-execution, 调用>>时自增。
  * 若 ename:VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_INVOCATIONS_BIT 被设置，
    池所管理的查询将会记录几何着色器调用次数。计数器的值在每个几何着色器被 <<shaders-geometry-execution,调用>>是自增。
    <<geometry-invocations,instanced geometry shaders>>，对于每个单独的实例调用，几何着色器调用次数就会自增一个。 
  * 若 ename:VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_PRIMITIVES_BIT 被设置，
    池所管理的查询将记录几何着色器调用所产生的图元的数量。计数器的值在几何着色器每次发射一个图元之后自增1。
    使用 SPIR-V指令    code:OpEndPrimitive or code:OpEndStreamPrimitive 重启图元拓扑，对于几何着色器输出的图元数量并没有影响。
  * 若 ename:VK_QUERY_PIPELINE_STATISTIC_CLIPPING_INVOCATIONS_BIT 被设置，
    池所管理的查询将会对管线的 <<vertexpostproc-clipping,Primitive Clipping>>阶段所处理的图元进行计数。 
      计数器的值在每个到达图元剪裁阶段时自增1。
  * 若 ename:VK_QUERY_PIPELINE_STATISTIC_CLIPPING_PRIMITIVES_BIT 被设置，
    池所管理的查询将对管线的 <<vertexpostproc-clipping,Primitive Clipping>> 阶段所输出的图元进行计数。
     计数器的值在每个通过了图元剪裁阶段后自增1。
    对于一个特定的图元，图元剪裁阶段实际输出的图元数量，对于Vulkan实现而言是不确定，且必须满足如下条件：
  ** If at least one vertex of the input primitive lies inside the clipping
     volume, the counter is incremented by one or more.
  ** Otherwise, the counter is incremented by zero or more.
  * 若 ename:VK_QUERY_PIPELINE_STATISTIC_FRAGMENT_SHADER_INVOCATIONS_BIT 被设置，
    池所管理的查询将对每个片元着色器调用进行计数。 
    计数器的值在每个片元着色器被 <<shaders-fragment-execution,invoked>>时自增1。
  * 若
    ename:VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_CONTROL_SHADER_PATCHES_BIT被设置，
    池所管理的查询将对细分控制着色器所处理的patch进行计数。 
    计数器的值在每个细分控制着色器被    <<shaders-tessellation-control-execution,invoked>>时自增1。
  * 若
    ename:VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_EVALUATION_SHADER_INVOCATIONS_BIT被设置，
     池所管理的查询将对每个细分求值着色器调用进行计数。计数器的值在每个细分求值着色器被 <<shaders-tessellation-evaluation-execution,invoked>>时自增1。
  * 若 ename:VK_QUERY_PIPELINE_STATISTIC_COMPUTE_SHADER_INVOCATIONS_BIT 被设置，
    池所管理的查询将对每个计算着色器调用进行计数。计数器的值在计算着色器被每次调用是自增1。
	Vulkan实现可能跳过某些计算着色器调用的执行，或者为Vulkan实现特定的原因执行一些额外的计算着色器调用，只要渲染的结果保持不变。
 

在Vulkan实现上，这些值只能测量出相对统计数据。
各种设备架构都会以不同的方式来计量。
计数器可能受<<queries-operation-undefined,Query Operation>>中描述的内容所影响。

[NOTE]
.注意
====
例如，tile-based 渲染设备可能需要回放场景多次，影响一些计数。
====

若一个管线开启了 pname:rasterizerDiscardEnable，Vulkan实现可能在最终顶点处理阶段丢弃一些图元。
结果，如果开启了pname:rasterizerDiscardEnable，剪裁输入和输出图元计算器可能并不会增加。

当一个管线统计查询完成，该查询的结果被标记为可用。
应用程序能复制结果到缓冲区 (通过
fname:vkCmdCopyQueryPoolResults), 或者要求它被写入到CPU端内存 (通过fname:vkGetQueryPoolResults).

// refEnd VkQueryPipelineStatisticFlagBits


[[queries-timestamps]]
== 时间戳查询

_Timestamps_ provide applications with a mechanism for timing the execution
of commands.
A timestamp is an integer value generated by the sname:VkPhysicalDevice.
Unlike other queries, timestamps do not operate over a range, and so do not
use flink:vkCmdBeginQuery or flink:vkCmdEndQuery.
The mechanism is built around a set of commands that allow the application
to tell the sname:VkPhysicalDevice to write timestamp values to a
<<queries-pools,query pool>> and then either read timestamp values on the
host (using flink:vkGetQueryPoolResults) or copy timestamp values to a
sname:VkBuffer (using flink:vkCmdCopyQueryPoolResults).
The application can: then compute differences between timestamps to
determine execution time.

The number of valid bits in a timestamp value is determined by the
sname:VkQueueFamilyProperties::pname:timestampValidBits property of the
queue on which the timestamp is written.
Timestamps are supported on any queue which reports a non-zero value for
pname:timestampValidBits via flink:vkGetPhysicalDeviceQueueFamilyProperties.
If the <<features-limits-timestampComputeAndGraphics,
pname:timestampComputeAndGraphics>> limit is ename:VK_TRUE, timestamps are
supported by every queue family that supports either graphics or compute
operations (see slink:VkQueueFamilyProperties).

The number of nanoseconds it takes for a timestamp value to be incremented
by 1 can: be obtained from
sname:VkPhysicalDeviceLimits::pname:timestampPeriod after a call to
fname:vkGetPhysicalDeviceProperties.

// refBegin vkCmdWriteTimestamp Write a device timestamp into a query object

可调用如下命令来获取一个时间戳：

include::../api/protos/vkCmdWriteTimestamp.txt[]

  * pname:commandBuffer 是记录此命令的命令缓冲区。
  * pname:pipelineStage 是 elink:VkPipelineStageFlagBits中的一个值，指定了管线的阶段。
  * pname:queryPool 是管理该时间戳的查询池。
  * pname:query 是查询池中包含该时间戳的查询。

fname:vkCmdWriteTimestamp latches the value of the timer when all previous
commands have completed executing as far as the specified pipeline stage,
and writes the timestamp value to memory.
When the timestamp value is written, the availability status of the query is
set to available.

[NOTE]
.注意
====
If an implementation is unable to detect completion and latch the timer at
any specific stage of the pipeline, it may: instead do so at any logically
later stage.
====

flink:vkCmdCopyQueryPoolResults can: then be called to copy the timestamp
value from the query pool into buffer memory, with ordering and
synchronization behavior equivalent to how other queries operate.
Timestamp values can: also be retrieved from the query pool using
flink:vkGetQueryPoolResults.
As with other queries, the query must: be reset using
flink:vkCmdResetQueryPool before requesting the timestamp value be written
to it.

While fname:vkCmdWriteTimestamp can: be called inside or outside of a render
pass instance, flink:vkCmdCopyQueryPoolResults must: only be called outside
of a render pass instance.

.正确使用
****
  * The query identified by pname:queryPool and pname:query must: be
    _unavailable_
  * The command pool's queue family must: support a non-zero
    pname:timestampValidBits
****

include::../validity/protos/vkCmdWriteTimestamp.txt[]
