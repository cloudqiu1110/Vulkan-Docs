// Copyright (c) 2015-2017 The Khronos Group Inc.
// Copyright notice at https://www.khronos.org/registry/speccopyright.html

[[devsandqueues]]
= 设备和队列

一旦Vulkan完成初始化，设备和队列是用来和Vulkan实现交互的主要对象。

// refBegin VkPhysicalDevice Opaque handle to a physical device object

Vulkan把 _physical_ 和 _logical_ 设备的概念分开了。一个物理设备通常表示单独的一个系统（也许由几个单独的硬件组成一起工作），
个数是有限的。逻辑设备表示从应用程序的角度看设备。

物理设备通过 sname:VkPhysicalDevice handles表示：

include::../api/handles/VkPhysicalDevice.txt[]

// refEnd VkPhysicalDevice


[[devsandqueues-physical-device-enumeration]]
== 物理设备

// refBegin vkEnumeratePhysicalDevices Enumerates the physical devices accessible to a Vulkan instance

要从系统中获取表示已安装的物理设备的对象列表，可调用：

include::../api/protos/vkEnumeratePhysicalDevices.txt[]

  * pname:instance 是一个handle，指向了之前用  fname:vkCreateInstance 创建的Vulkan实例。
  * pname:pPhysicalDeviceCount 是一个指针，指向了可用的或者已查询到的物理设备数量的整数，如下面所描述。
  * pname:pPhysicalDevices 要么是 `NULL` ，要么是一个指向 sname:VkPhysicalDevice 数组的指针。

如果pname:pPhysicalDevices 为 `NULL`，那么可用的物理设备的个数通过pname:pPhysicalDeviceCount返回。
否则，pname:pPhysicalDeviceCount必须指向一个用户端设置的、值为pname:pPhysicalDevices数组大小的变量，
且返回时，变量被覆写为pname:pPhysicalDevices数组的大小。
如果pname:pPhysicalDeviceCount 比可用的物理设备个数小，最多pname:pPhysicalDeviceCount被覆盖。
如果pname:pPhysicalDeviceCount 比可用的物理设备个数小，ename:VK_INCOMPLETE 将被返回，表示不是所有可用设备被返回。

include::../validity/protos/vkEnumeratePhysicalDevices.txt[]

// refBegin vkGetPhysicalDeviceProperties Returns properties of a physical device

要查询一个获取的物理设备的通用属性，调用：

include::../api/protos/vkGetPhysicalDeviceProperties.txt[]

  * pname:physicalDevice 是将被查询各种属性的物理设备的handle。  
  * pname:pProperties 指向一个 slink:VkPhysicalDeviceProperties 类型数据结构的实例，将被返回的信息所填充。

include::../validity/protos/vkGetPhysicalDeviceProperties.txt[]

// refBegin VkPhysicalDeviceProperties Structure specifying physical device properties

sname:VkPhysicalDeviceProperties 数据结构定义如下：

include::../api/structs/VkPhysicalDeviceProperties.txt[]

  * pname:apiVersion 是设备所支持的Vulkan版本，如<<fundamentals-versionnum,API Version
    Numbers and Semantics>> 一节所描述的那样被编码.
  * pname:driverVersion 是显卡生产商所提供的驱动版本号。
  * pname:vendorID 是物理设备的 _vendor_ (see below) 对应的唯一标识。
  * pname:deviceID is a 供应商所有设备中此设备的唯一标识。
  * pname:deviceType 一个 elink:VkPhysicalDeviceType ，指定了设备的类型。
  * pname:deviceName 是一个以 null 结束的UTF-8字符串，包含了设备的名字。
  * pname:pipelineCacheUUID 是一个大小为ename:VK_UUID_SIZE 的数组，每个元素包含8-bit，表示该设备的唯一编号。
  * pname:limits 是一个 slink:VkPhysicalDeviceLimits 数据结构，给出了物理设备特定的物理限制。细节部分请参考<<features-limits,Limits>> 。
  * pname:sparseProperties 是一个 slink:VkPhysicalDeviceSparseProperties 数据结构，给出了和物理设备的各种稀疏相关的属性。
     细节部分请参考<<sparsememory-physicalprops,Sparse Properties>> 。

pname:vendorID 和 pname:deviceID 域可以让应用程序适配硬件的没有通过其他Vulkan查询暴露出来的特性，
这些也可能包括性能分析，硬件勘误，或者其他的特性。在基于PCI的Vulkan实现中，pname:vendorID 和
pname:deviceID最低6位必须包含 PCI供应商和硬件设备关联的设备ID，剩下的位必须设置为0。
在非PCI实现中，渲染返回什么值可以由操作系统或者平台策略来决定。
其他方面，则由Vulkan实现者根据如下限制条件或者指导意见来自由决定：

  * For purposes of physical device identification, the _vendor_ of a
    physical device is the entity responsible for the most salient
    characteristics of the hardware represented by the physical device
    handle.
    In the case of a discrete GPU, this should: be the GPU chipset vendor.
    In the case of a GPU or other accelerator integrated into a
    system-on-chip (SoC), this should: be the supplier of the silicon IP
    used to create the GPU or other accelerator.
  * If the vendor of the physical device has a valid PCI vendor ID issued by
    https://pcisig.com/[PCI-SIG], that ID should: be used to construct
    pname:vendorID as described above for PCI-based implementations.
    Implementations that do not return a PCI vendor ID in pname:vendorID
    must: return a valid Khronos vendor ID, obtained as described in the
    <<vulkan-styleguide,Vulkan Documentation and Extensions>> document in
    the section "`Registering a Vendor ID with Khronos`".
    Khronos vendor IDs are allocated starting at 0x10000, to distinguish
    them from the PCI vendor ID namespace.
  * The vendor of the physical device is responsible for selecting
    pname:deviceID.
    The value selected should: uniquely identify both the device version and
    any major configuration options (for example, core count in the case of
    multicore devices).
    The same device ID should: be used for all physical implementations of
    that device version and configuration.
    For example, all uses of a specific silicon IP GPU version and
    configuration should: use the same device ID, even if those uses occur
    in different SoCs.

include::../validity/structs/VkPhysicalDeviceProperties.txt[]

// refBegin VkPhysicalDeviceType Supported physical device types

物理设备的类型为：

include::../api/enums/VkPhysicalDeviceType.txt[]

  * ename:VK_PHYSICAL_DEVICE_TYPE_OTHER 此设备不与其他任何可用的类型匹配。
  * ename:VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU 此设备通常是嵌入式的，或者是集成到CPU内部的。
  * ename:VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU 此设备通常是一个与CPU通过内部总线直接相连的独立设备。
  * ename:VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU 此设备通常是虚拟环境中的一个虚拟节点。
  * ename:VK_PHYSICAL_DEVICE_TYPE_CPU 此设备通常和CPU一样运行在同一个处理器上。

物理设备类型只是提供建议性的信息，并不直接影响系统的操作。
然而，设备类型可能与其他宣称的属性或者系统兼容性 有关，比如有多少个内存堆。

// refEnd VkPhysicalDeviceType

ifdef::VK_KHR_get_physical_device_properties2[]

// refBegin vkGetPhysicalDeviceProperties2KHR Returns properties of a physical device

可调用如下函数来查询列举的物理设备的属性：

include::../api/protos/vkGetPhysicalDeviceProperties2KHR.txt[]

  * pname:physicalDevice 是将被查询各种属性的物理设备的handle。
  * pname:pProperties 指向一个 slink:VkPhysicalDeviceProperties2KHR 类型数据结构的实例，将被返回的信息所填充。

pname:pProperties内每一个数据结构和它的 pname:pNext 链包含了许多成员，对应着属性或者实现特定的限制。

fname:vkGetPhysicalDeviceProperties2KHR 向每一个成员写入值，表明该属性或者限制。

include::../validity/protos/vkGetPhysicalDeviceProperties2KHR.txt[]

// refBegin VkPhysicalDeviceProperties2KHR Structure specifying physical device properties

sname:VkPhysicalDeviceProperties2KHR 数据结构定义如下：

include::../api/structs/VkPhysicalDeviceProperties2KHR.txt[]

  * pname:sType 是数据结构的类型。
  * pname:pNext 是 `NULL` 或者指向一个拓展特定的数据结构。
  * pname:properties 是一个 slink:VkPhysicalDeviceProperties 类型的数据结构，描述了物理设备的属性。
     这个数据结构被写入的值同调用flink:vkGetPhysicalDeviceProperties写入的值。
   

这个数据结构的pname:pNext 链 被用来拓展 Vulkan拓展定义的属性。   

include::../validity/structs/VkPhysicalDeviceProperties2KHR.txt[]

endif::VK_KHR_get_physical_device_properties2[]

// refBegin vkGetPhysicalDeviceQueueFamilyProperties Reports properties of the queues of the specified physical device

可调用下列命令来查询在物理设备上可用的队列的属性：

include::../api/protos/vkGetPhysicalDeviceQueueFamilyProperties.txt[]

  * pname:physicalDevice 是将被查询各种属性的物理设备的handle。
  * pname:pQueueFamilyPropertyCount 是一个指针，指向一个和可用的或者查询到的队列族数量相关的整数，如下所描述。 
  * pname:pQueueFamilyProperties 是`NULL`，或者是一个指向 slink:VkQueueFamilyProperties 类型数组的指针。

如果pname:pQueueFamilyProperties 为`NULL`，那么可用的队列族的数量通过 pname:pQueueFamilyPropertyCount 返回。
否则，pname:pQueueFamilyPropertyCount 必须: 指向一个变量，由用户设置的pname:pQueueFamilyProperties 数组的个数，
返回的时候，这个变量值被 写入到pname:pQueueFamilyProperties的个数所覆盖。
如果pname:pQueueFamilyPropertyCount 比可用的队列族少，最多有 pname:pQueueFamilyPropertyCount 个数据被写入。

include::../validity/protos/vkGetPhysicalDeviceQueueFamilyProperties.txt[]

// refBegin VkQueueFamilyProperties Structure providing information about a queue family

sname:VkQueueFamilyProperties 数据结构定义如下：

include::../api/structs/VkQueueFamilyProperties.txt[]

  * pname:queueFlags 包含了此队列在队列族中兼容性的标志位。
  * pname:queueCount 是队列族中队列的个数。
  * pname:timestampValidBits 是通过 fname:vkCmdWriteTimestamp写入的时间戳的有效位个数。有效位的范围是 36-64，或者值为0，表示不支持时间戳。
	 在有效bit位之外的位置被保证都为0。    
  * pname:minImageTransferGranularity 是队列族中的队列支持的转移图像的最小粒度。

  
pname:queueFlags 的标志位如下:

// refBegin VkQueueFlagBits Bitmask specifying capabilities of queues in a queue family
include::../api/enums/VkQueueFlagBits.txt[]

  * if ename:VK_QUEUE_GRAPHICS_BIT is set, then the queues in this queue
    family support graphics operations.
  * if ename:VK_QUEUE_COMPUTE_BIT is set, then the queues in this queue
    family support compute operations.
  * if ename:VK_QUEUE_TRANSFER_BIT is set, then the queues in this queue
    family support transfer operations.
  * if ename:VK_QUEUE_SPARSE_BINDING_BIT is set, then the queues in this
    queue family support sparse memory management operations (see
    <<sparsememory,Sparse Resources>>).
    If any of the sparse resource features are enabled, then at least one
    queue family must: support this bit.

如果Vulkan实现保留了任何支持图形操作的队列族，那么至少一个物理设备中至少有一个队列族必须都支持图形和计算操作。	

[NOTE]
.注意
====
All commands that are allowed on a queue that supports transfer operations
are also allowed on a queue that supports either graphics or compute
operations thus if the capabilities of a queue family include
ename:VK_QUEUE_GRAPHICS_BIT or ename:VK_QUEUE_COMPUTE_BIT then reporting the
ename:VK_QUEUE_TRANSFER_BIT capability separately for that queue family is
optional:.
====

更多细节请参考<<devsandqueues-queues,Queues>>.

The value returned in pname:minImageTransferGranularity has a unit of
compressed texel blocks for images having a block-compressed format, and a
unit of texels otherwise.

Possible values of pname:minImageTransferGranularity are:

  * [eq]#(0,0,0)# which indicates that only whole mip levels must: be
    transferred using the image transfer operations on the corresponding
    queues.
    In this case, the following restrictions apply to all offset and extent
    parameters of image transfer operations:

  ** The pname:x, pname:y, and pname:z members of a slink:VkOffset3D
     parameter must: always be zero.
  ** The pname:width, pname:height, and pname:depth members of a
     slink:VkExtent3D parameter must: always match the width, height, and
     depth of the image subresource corresponding to the parameter,
     respectively.

  * [eq]#(A~x~, A~y~, A~z~)# where [eq]#A~x~#, [eq]#A~y~#, and [eq]#A~z~#
    are all integer powers of two.
    In this case the following restrictions apply to all image transfer
    operations:

  ** pname:x, pname:y, and pname:z of a slink:VkOffset3D parameter must: be
     integer multiples of [eq]#A~x~#, [eq]#A~y~#, and [eq]#A~z~#,
     respectively.
  ** pname:width of a slink:VkExtent3D parameter must: be an integer
     multiple of [eq]#A~x~#, or else [eq]#pname:x + pname:width# must: equal
     the width of the image subresource corresponding to the parameter.
  ** pname:height of a slink:VkExtent3D parameter must: be an integer
     multiple of [eq]#A~y~#, or else [eq]#pname:y + pname:height# must:
     equal the height of the image subresource corresponding to the
     parameter.
  ** pname:depth of a slink:VkExtent3D parameter must: be an integer
     multiple of [eq]#A~z~#, or else [eq]#pname:z + pname:depth# must: equal
     the depth of the image subresource corresponding to the parameter.
  ** If the format of the image corresponding to the parameters is one of
     the block-compressed formats then for the purposes of the above
     calculations the granularity must: be scaled up by the compressed texel
     block dimensions.

Queues supporting graphics and/or compute operations must: report
[eq]#(1,1,1)# in pname:minImageTransferGranularity, meaning that there are
no additional restrictions on the granularity of image transfer operations
for these queues.
Other queues supporting image transfer operations are only required: to
support whole mip level transfers, thus pname:minImageTransferGranularity
for queues belonging to such queue families may: be [eq]#(0,0,0)#.

include::../validity/structs/VkQueueFamilyProperties.txt[]

<<memory-device,Device Memory>>一节描述了从物理设备中查询出来的内存属性。

对于物理设备特征查询，请参考 <<features, Features>> 一章。

ifdef::VK_KHR_get_physical_device_properties2[]

// refBegin vkGetPhysicalDeviceQueueFamilyProperties2KHR Reports properties of the queues of the specified physical device

可调用下列命令来查询物理设备上可用的队列的属性：

include::../api/protos/vkGetPhysicalDeviceQueueFamilyProperties2KHR.txt[]

  * pname:physicalDevice 是将被查询各种属性的物理设备的handle。
  * pname:pQueueFamilyPropertyCount 是一个指针，指向了一个整数包含有可用的或者被查询的队列族的个数，如 flink:vkGetPhysicalDeviceQueueFamilyProperties中所描述。
  * pname:pQueueFamilyProperties是 `NULL` ，或者是一个指针，指向元素为slink:VkQueueFamilyProperties2KHR 类型的数组。

fname:vkGetPhysicalDeviceQueueFamilyProperties2KHR 和
flink:vkGetPhysicalDeviceQueueFamilyProperties 表现类似，把拓展的信息通过链式数据结构输出。

include::../validity/protos/vkGetPhysicalDeviceQueueFamilyProperties2KHR.txt[]

// refBegin VkQueueFamilyProperties2KHR Structure providing information about a queue family

sname:VkQueueFamilyProperties2KHR 数据结构定义如下：

include::../api/structs/VkQueueFamilyProperties2KHR.txt[]

  * pname:sType  是数据结构的类型。
  * pname:pNext 是 `NULL` 或者指向一个拓展特定的数据结构。
  * pname:queueFamilyProperties 是一个类型为slink:VkQueueFamilyProperties 的数据结构，和调用flink:vkGetPhysicalDeviceQueueFamilyProperties 产生的值完全相同。

include::../validity/structs/VkQueueFamilyProperties2KHR.txt[]

endif::VK_KHR_get_physical_device_properties2[]


[[devsandqueues-devices]]
== 设备

设备对象表示和物理设备之间的一个连接。每一个设备对外暴露一些 _队列族_，每一个都有一个或多个_队列_。
在一个队列族中的所有队列都支持相同的操作。

如在<<devsandqueues-physical-device-enumeration,Physical Devices>>中所描述的，一个Vulkan应用程序将首先查询
一个系统中所有的物理设备。
每一个物理设备可以被查询它的能力，包含队列和队列族的属性。一旦一个可接受的物理设备被确认了，应用程序将创建对应的
逻辑设备。应用程序必须对每一个使用的物理设备创建单独的逻辑设备。被创建的逻辑设备然后就是和物理设备之间的接口了。

如何遍历一个系统中的物理设备并查询这些物理设备的队列族属性在之前的
<<devsandqueues-physical-device-enumeration, Physical Device Enumeration>>小节讲解过。


[[devsandqueues-device-creation]]
=== 设备创建

// refBegin VkDevice Opaque handle to a device object

逻辑设备通过sname:VkDevice handles表示：

include::../api/handles/VkDevice.txt[]

// refEnd VkDevice

// refBegin vkCreateDevice Create a new device instance

一个逻辑设备被当作和物理设备的连接被创建。调用下面的命令来创建逻辑设备：

include::../api/protos/vkCreateDevice.txt[]

  * pname:physicalDevice  必须: 是fname:vkEnumeratePhysicalDevices调用返回的多个队列中的一个的handle(参考
    <<devsandqueues-physical-device-enumeration, Physical Device
    Enumeration>>)。
  * pname:pCreateInfo 是一个指针，指向一个类型为 slink:VkDeviceCreateInfo 的数据结构，包含如何创建设备的信息。    
  * pname:pAllocator 控制了CPU端内存分配，如 <<memory-allocation, Memory Allocation>> 一章所描述。
  * pname:pDevice 指向了创建得到的 sname:VkDevice 的handle。    

可以在同一个物理设备上创建多个逻辑设备。因为物理资源的缺乏（和其他错误），逻辑设备的创建可能失败。
如果发生了失败，fname:vkCreateDevice 将返回ename:VK_ERROR_TOO_MANY_OBJECTS。

include::../validity/protos/vkCreateDevice.txt[]

// refBegin VkDeviceCreateInfo Structure specifying parameters of a newly created device

sname:VkDeviceCreateInfo 数据结构定义如下：

include::../api/structs/VkDeviceCreateInfo.txt[]

  * pname:sType 是数据结构的类型。
  * pname:pNext 是 `NULL` 或者一个指向拓展特定的数据结构。
  * pname:flags 被保留使用。
  * pname:queueCreateInfoCount 是 pname:pQueueCreateInfos 数组的大小。参考 下面的<<devsandqueues-queue-creation,Queue Creation>> 一节来获取更多信息。    
  * pname:pQueueCreateInfos 是一个指针，指向一个元素类型为 slink:VkDeviceQueueCreateInfo 的数组，描述了 describing the queues that are
    requested to be created along with the logical device.
    Refer to the <<devsandqueues-queue-creation,Queue Creation>> section
    below for further details.
  * pname:enabledLayerCount 已弃用，被忽略。
  * pname:ppEnabledLayerNames 已弃用，被忽略。参考 <<extended-functionality-device-layer-deprecation,Device Layer Deprecation>>.
  * pname:enabledExtensionCount 是启用的设备拓展的个数。
  * pname:ppEnabledExtensionNames 是一个指针，指向了一个长度为 pname:enabledExtensionCount ，null-terminated UTF-8 字符串， 包含了将对创建的设备所启用的拓展名字。
     参考<<extended-functionality-extensions,Extensions>> 一节来获取更多细节。
  * pname:pEnabledFeatures 是 `NULL`，或者是一个指针，指向一个 slink:VkPhysicalDeviceFeatures 数据结构，其包含了所有将被启用的特征的 boolean标志位。
     参考<<features-features,Features>> 一节获取更多细节。

.正确使用
****
  * The pname:queueFamilyIndex member of any given element of
    pname:pQueueCreateInfos must: be unique within pname:pQueueCreateInfos
ifdef::VK_KHR_get_physical_device_properties2[]
  * If the pname:pNext chain includes a slink:VkPhysicalDeviceFeatures2KHR
    structure, then pname:pEnabledFeatures must: be `NULL`
endif::VK_KHR_get_physical_device_properties2[]
ifdef::VK_KHR_maintenance1[]
ifdef::VK_AMD_negative_viewport_height[]
  * pname:ppEnabledExtensionNames must: not contain both
    code:VK_KHR_maintenance1 and code:VK_AMD_negative_viewport_height
endif::VK_AMD_negative_viewport_height[]
endif::VK_KHR_maintenance1[]
****

include::../validity/structs/VkDeviceCreateInfo.txt[]


[[devsandqueues-use]]
=== 使用设备

下面是如何使用 sname:VkDevice 的上层列表，还有详细信息的参考点：

  * 创建队列。
    请参考下面的<<devsandqueues-queues,Queues>> 一节来获取更多细节。
  * 创建并跟踪各种同步对象。
    参考 <<synchronization,Synchronization and Cache Control>> 来获取更多细节。
  * 分配，释放和管理内存。
    参考 <<memory,Memory Allocation>> 和 <<resources,Resource Creation>> 以获取更多细节。
  * 创建和销毁命令缓冲区、命令缓存池。
    参考 <<commandbuffers,Command Buffers>> 以获取更多细节。
  * 创建，销毁和管理图形状态。
    参考 <<pipelines,Pipelines>> 和 <<descriptorsets,Resource Descriptors>>还有其他的小节，以获取更多细节。


[[devsandqueues-lost-device]]
=== 设备丢失

逻辑设备可能因为硬件错误、执行超时、电源管理事件和平台某些事件而丢失。这会导致待执行的命令执行失败和硬件资源损坏。
当发生这种情况时，某些命令会返回name:VK_ERROR_DEVICE_LOST（参考<<fundamentals-errorcodes,Error Codes>>）。
发生了这种情况后，逻辑设备被认为已经丢失了。
不可能重置逻辑设备到非丢失状态，然而，这个丢失状态只是针对逻辑设备而言的，对应的物理设备（sname:VkPhysicalDevice）可能不受影响。
一些情况下，物理设备也可能丢失，尝试创建逻辑设备会失败，返回ename:VK_ERROR_DEVICE_LOST。这通常意味着潜在的硬件问题，或者和
CPU端的连接问题。
如果物理设备没有被丢失，在它上面一个新的逻辑设备成功的被创建了，物理设备一定是非丢失状态。

[NOTE]
.注意
====
同时，逻辑设备丢失是可恢复的，物理设备丢失的情况下，除非系统中有另外未受影响的物理设备，否则应用程序不可能会恢复。
错误大体上是信息性的，试图通知用户他们的硬件可能产生了错误或连接不良，应该自己调查一下。一些情况下，物理设备丢失可能导致
其他严重的问题，比如操作系统崩溃，这样的话Vulkan API就不会给出原因了。
====

[NOTE]
.注意
====
应用程序导致的未知行为可能导致设备丢失。然而，这些未定义行为也会导致进程内存损坏，此时就不能保证API对象，包括
sname:VkPhysicalDevice 或者sname:VkInstance仍然是有效的，或者是可恢复的。 
====

当设备丢失了，它的子对象并没有隐式的被销毁，它们的handle仍然有效。这些对象必须要在他们父对象
或者设备被销毁之前被销毁（参考 <<fundamentals-objectmodel-lifetime,Object Lifetime>> 小节 ）。
使用flink:vkMapMemory把设备内存映射到CPU端寻址空间的内存依然有效，对于被映射区域的CPU端内存访问仍然是有效的，但是内存内容是未定义的。
仍然可以对设备和它的子对象调用任何API命令。

一旦设备丢失，命令执行可能失败:，返回elink:VkResult 的命令有可能:  返回ename:VK_ERROR_DEVICE_LOST。
不允许运行时错误的命令有可能仍然正常使用中，有可能的话，仍返回有效的数据。

Commands that wait indefinitely for device execution (namely
flink:vkDeviceWaitIdle, flink:vkQueueWaitIdle, flink:vkWaitForFences
ifdef::VK_KHR_swapchain[]
or flink:vkAcquireNextImageKHR
endif::VK_KHR_swapchain[]
with a maximum pname:timeout, and flink:vkGetQueryPoolResults with the
ename:VK_QUERY_RESULT_WAIT_BIT bit set in pname:flags) must: return in
finite time even in the case of a lost device, and return either
ename:VK_SUCCESS or ename:VK_ERROR_DEVICE_LOST.
For any command that may: return ename:VK_ERROR_DEVICE_LOST, for the purpose
of determining whether a command buffer is pending execution, or whether
resources are considered in-use by the device, a return value of
ename:VK_ERROR_DEVICE_LOST is equivalent to ename:VK_SUCCESS.

ifdef::editing-notes[]
[NOTE]
.editing-note
====
TODO (piman) - I do not think we are very clear about what "`in-use by the
device`" means.
====
endif::editing-notes[]


[[devsandqueues-destruction]]
=== 设备销毁

// refBegin vkDestroyDevice Destroy a logical device

可调用如下命令来销毁设备：

include::../api/protos/vkDestroyDevice.txt[]

  * pname:device 是需要被销毁的逻辑设备。
  * pname:pAllocator 控制CPU内存分配，如 <<memory-allocation, Memory Allocation>> 一章讲解。

为了保证在设备上没有正在进行的工作，vkDeviceWaitIdle 可以: 用来守护设备的销毁。
在销毁设备之前，应用程序需要负责销毁/释放从该设备上创建出来的Vulkan对象（使用ftext:vkCreate* 、ftext:vkAllocate* 等命令并以该device作为第一个参数）。

[NOTE]
.注意
====
The lifetime of each of these objects is bound by the lifetime of the
sname:VkDevice object.
Therefore, to avoid resource leaks, it is critical that an application
explicitly free all of these resources prior to calling
fname:vkDestroyDevice.
====

.正确使用
****
  * All child objects created on pname:device must: have been destroyed
    prior to destroying pname:device
  * If sname:VkAllocationCallbacks were provided when pname:device was
    created, a compatible set of callbacks must: be provided here
  * If no sname:VkAllocationCallbacks were provided when pname:device was
    created, pname:pAllocator must: be `NULL`
****

include::../validity/protos/vkDestroyDevice.txt[]


[[devsandqueues-queues]]
== 队列


[[devsandqueues-queueprops]]
=== 队列族的属性

如之前的<<devsandqueues-physical-device-enumeration,Physical Device Enumeration>>一节讲过，flink:vkGetPhysicalDeviceQueueFamilyProperties
命令是用来获取设备所支持的队列族的属性的。

flink:vkGetPhysicalDeviceQueueFamilyProperties返回的pname:pQueueFamilyProperties数组的每一个索引描述了
物理设备上唯一的队列族。
这些索引被用来创建队列，它们通过下节<<devsandqueues-queue-creation,Queue Creation>> 讲解的slink:VkDeviceQueueCreateInfo类型数据
直接对应着传递给 flink:vkCreateDevice命令的 pname:queueFamilyIndex。

同一个物理设备上的队列族的分组取决于Vulkan实现。

[NOTE]
.注意
====
可以假定一个物理设备会把能力匹配的所有队列分组到一个族。
然而，这是对Vulkan实现的一个推荐，很可能，物理设备可能会返回两个拥有相同能力的族。
====

一旦应用程序以它想用的族来确定了物理设备，它将结合逻辑设备来创建这些队列。
这在下节讲述。


[[devsandqueues-queue-creation]]
=== 创建队列

// refBegin VkQueue Opaque handle to a queue object

创建一个逻辑设备也会创建该设备相关的队列。需要创建的队列通过传递给flink:vkCreateDevice 
的参数pname:pQueueCreateInfos的一系列slink:VkDeviceQueueCreateInfo类型数据描述。

队列通过sname:VkQueue handles表示：

include::../api/handles/VkQueue.txt[]

// refEnd VkQueue

// refBegin VkDeviceQueueCreateInfo Structure specifying parameters of a newly created device queue

sname:VkDeviceQueueCreateInfo 数据结构定义如下：

include::../api/structs/VkDeviceQueueCreateInfo.txt[]

  * pname:sType 是数据结构的类型。
  * pname:pNext 是 `NULL` 或者一个指向拓展特定的数据结构。
  * pname:flags 被保留使用。
  * pname:queueFamilyIndex 是一个无符号整形数字，表示在此设备上创建的队列族的索引。
    这个索引对应着 fname:vkGetPhysicalDeviceQueueFamilyProperties返回的pname:pQueueFamilyProperties 数组中的元素的索引。
  * pname:queueCount 是一个无符号整形数字，指定了 pname:queueFamilyIndex表示的队列族中的队列个数。
  * pname:pQueuePriorities 是一个元素为归一化浮点数的数组，大小为pname:queueCount，指定了提交到已创建队列的任务的优先级。 
     参考<<devsandqueues-priority,Queue Priority>> 以获取更多信息。

.正确使用
****
  * pname:queueFamilyIndex must: be less than
    pname:pQueueFamilyPropertyCount returned by
    fname:vkGetPhysicalDeviceQueueFamilyProperties
  * pname:queueCount must: be less than or equal to the pname:queueCount
    member of the sname:VkQueueFamilyProperties structure, as returned by
    fname:vkGetPhysicalDeviceQueueFamilyProperties in the
    pname:pQueueFamilyProperties[pname:queueFamilyIndex]
  * Each element of pname:pQueuePriorities must: be between `0.0` and `1.0`
    inclusive
****

include::../validity/structs/VkDeviceQueueCreateInfo.txt[]

// refBegin vkGetDeviceQueue Get a queue handle from a device

可调用如下命令来获取一个队列的handle：

include::../api/protos/vkGetDeviceQueue.txt[]

  * pname:device 是拥有该队列的逻辑设备。
  * pname:queueFamilyIndex 是队列所属的队列族的索引。
  * pname:queueIndex 是需要获取的队列在队列族中的索引。
  * pname:pQueue 是一个指针，指向了sname:VkQueue 对象，它将被获取到的队列的handle所覆盖。

.正确使用
****
  * pname:queueFamilyIndex must: be one of the queue family indices
    specified when pname:device was created, via the
    sname:VkDeviceQueueCreateInfo structure
  * pname:queueIndex must: be less than the number of queues created for the
    specified queue family index when pname:device was created, via the
    pname:queueCount member of the sname:VkDeviceQueueCreateInfo structure
****

include::../validity/protos/vkGetDeviceQueue.txt[]


[[devsandqueues-index]]
=== 队列族索引

队列族索引在Vulkan中多处被使用，它可以把操作和特定的队列族绑定起来。

当通过fname:vkGetDeviceQueue获取到一个队列的handle时，队列族的索引被用来选择从哪个队列族中获取队列handle（上上节所述）。

当创建sname:VkCommandPool 对象时(参考
<<commandbuffers-pools,Command Pools>>)，一个队列族索引通过 slink:VkCommandPoolCreateInfo 数据结构指定。
从缓存池中获取的命令缓冲区 只能提交到对应着此队列族的队列上。

当创建 sname:VkImage (参考 <<resources-images,Images>>) 和
sname:VkBuffer (参考 <<resources-buffers,Buffers>>) 资源时，一系列的队列族被包含到slink:VkImageCreateInfo 和
slink:VkBufferCreateInfo 数据结构中，来指定可以访问到这些资源的队列族。

当插入一个slink:VkBufferMemoryBarrier 或 slink:VkImageMemoryBarrier
(see <<synchronization-events>>) 时，一个源和目标队列族索引被指定来允许把缓冲区或图像转移到另外一个队列族。
参考 <<resources-sharing,Resource Sharing>> 一节以获取细节。


[[devsandqueues-priority]]
=== 队列优先级

每一个队列都被分配了一个优先级，在创建设备过程中slink:VkDeviceQueueCreateInfo的数据结构中设置的。
每一个队列的优先级是一个归一化的浮点值，在0.0和1.0之间，然后有Vulkan实现转换到离散的的优先级级别。
高的值表示更高的优先级，0.0表示最低的优先级，1.0表示最高。一个设备内，拥有高优先级的队列将会比
优先级低的队列获得更多的处理时间。Vulkan实现不保证相同优先级的队列的排序或者调度，
不管<<synchronization, explicit synchronization primitives>>中已定义的限制如何。
Vulkan实现不保证不同设备之间的队列要如何安排优先级。

一个Vulkan实现也许允许更高优先级的队列会让同一个设备上的低优先级的队列挨饿，直到自己完成所有命令的执行。
队列优先级的关系必须不能导致另外一个设备上的队列暂停工作。

没有任何明确的保证高优先级的队列比低优先级的队列接受更多的处理时间和服务质量。

[[devsandqueues-submission]]
=== 队列提交

通过_队列提交_命令，如flink:vkQueueSubmit，工作就被提交到队列了。队列提交命令定义了一系列的需要
物理设备执行的_队列操作_，包括使用信号量和栅栏来同步。

提交命令接受目标设备为参数，零个或者多个_batches_的任务，和一个可选的栅栏来激发任务完成的信号。
每一个批次由三个部分组成：

  . Zero or more semaphores to wait on before execution of the rest of the
    batch.
  ** If present, these describe a <<synchronization-semaphores-waiting,
     semaphore wait operation>>.
  . Zero or more work items to execute.
  ** If present, these describe a _queue operation_ matching the work
     described.
  . Zero or more semaphores to signal upon completion of the work items.
  ** If present, these describe a <<synchronization-semaphores-signaling,
     semaphore signal operation>>.

If a fence is present in a queue submission, it describes a
<<synchronization-fences-signaling, fence signal operation>>.

通过一个队列提交命令描述的所有任务必须在命令返回前提交到队列。


[[devsandqueues-sparsebinding]]
==== 稀疏内存绑定

在Vulkan里，可以稀疏的绑定内存到缓冲区或者图像，这点在前面的<<sparsememory,Sparse Resource>>一章讲过。
稀疏内存绑定是一个队列操作。包含ename:VK_QUEUE_SPARSE_BINDING_BIT标志的队列必须能支持在设备上
映射虚拟地址到物理地址。这将导致设备上映射表的更新。这个更新必须让队列保持同步，以避免在图形命令执行期间
损坏page table映射。通过在队列上绑定稀疏内存，所有依赖于被更新的绑定的命令在绑定更新之后同步的执行。
查看 <<synchronization,Synchronization and Cache Control>> 一章可知如何实现同步。


[[devsandqueues-queuedestruction]]
=== 队列销毁

队列和fname:vkCreateDevice创建的逻辑设备一同被创建。当调用fname:vkDestroyDevice后，和逻辑设备关联的所有队列都被销毁了。
