// Copyright (c) 2015-2017 The Khronos Group Inc.
// Copyright notice at https://www.khronos.org/registry/speccopyright.html

[[interfaces]]
= 着色器接口

当创建了一个管线，在对应的 stext:Vk*PipelineCreateInfo数据结构中指定的着色器集合被隐式的链接到一系列不同的接口。

  * <<interfaces-iointerfaces, 着色器输入输出接口>>
  * <<interfaces-vertexinput, 顶点输入接口>>
  * <<interfaces-fragmentoutput, 片元输出接口>>
  * <<interfaces-inputattachment, 片元输入附件接口>>
  * <<interfaces-resources, 着色器资源接口>>

接口定义使用下列SPIR-V 修饰符：

  * code:DescriptorSet 和 code:Binding
  * code:Location, code:Component, and code:Index
  * code:Flat, code:NoPerspective, code:Centroid, and code:Sample
  * code:Block and code:BufferBlock
  * code:InputAttachmentIndex
  * code:Offset, code:ArrayStride, and code:MatrixStride
  * code:BuiltIn

本规范文档描述了Vulkan 正确的使用这些修饰符。

[[interfaces-iointerfaces]]
== 着色器输入输出接口

当一个管线内有多个阶段时，一个阶段的输出和下一个阶段的输入形成了一个接口。
当这个接口涉及到着色器时，着色器输出和下一个阶段的输入相匹配，着色器输入和上一个阶段的输出相匹配。

有两类变量可以在着色器阶段间匹配：内置变量，用户自定义变量。
每一类都有不同的匹配条件。通常，当不同阶段之间的是非着色器阶段，用户自定义的变量基本上是内置变量，在着色器
阶段之间形成接口。

形成输入、输出 _接口_ 的变量被当作 code:OpEntryPoint 指令的操作对象，
在SPIR-V模块中各以code:Input 或 code:Output 存储描述符所修饰。

一个着色器阶段的code:Output 变量在着色器写入它们或者使用code:Initializer来声明操作对象之前，它们的值是未知的。


[[interfaces-iointerfaces-builtin]]
=== 内置的接口Block

着色器<<interfaces-builtin-variables,  内置>> 变量须满足以下定义 _内置接口block_ 要求：

  * 被显式的声明（并没有隐式的内置变量）
  * 被 code:BuiltIn 修饰，
  * 形成如<<interfaces-builtin-variables,Built-in Variables>> 一节所描述的变量类型
  * 在顶层成员都是内置类型的block中被声明。

如果在这样的block中被声明了，内置变量只参与接口匹配。
它们不能有 code:Location 或 code:Component修饰符。
在每一个着色器接口内，不能有多个内置接口block。


[[interfaces-iointerfaces-user]]
=== 用户自定义变量接口

被以code:Input 或 code:Output 存储修饰符列举的code:OpEntryPoint 变量形成了 _用户自定义变量接口_ 。
这些变量必须以code:Location 修饰符指定，也可以被 code:Component 修饰符指定。


[[interfaces-iointerfaces-matching]]
=== 接口匹配

一个用户自定义输出变量被认为与下一个阶段的输入变量匹配，若两个变量被相同code:Location 和 code:Component
描述符修饰，并类型匹配，除了<<shaders-interpolation-decorations,interpolation decorations>> 没有要求被匹配。
为了做到接口匹配，没有以code:Component修饰的变量被认为有以 值为0的code:Component 来修饰。


若数据结构成员在类型、修饰符、数量、声明顺序上是匹配的，变量或者被声明为数据结构的块成员被认为是类型匹配的，
若声明中元素类型与个数相同，则变量或者声明为数组的块成员被认为是匹配的。

细分控制着色器逐顶点输出变量与块，细分控制、细分求值、几何着色器的逐顶点输入变量与块要求必须被声明为数组，其每一个元素表示输入或者输出值是一个顶点或者多顶点的图元。
为了接口匹配，变量或者块最外层的数组维度被忽略了。

在两个非片元着色器阶段的接口，内置的接口block 必须严格匹配，如上所述。
在涉及到片元着色器输入的接口，内置的输出变量的出现或者缺失并不影响接口匹配。

absence of any built-in output does not affect the interface matching.

在两个着色器阶段接口之间，用户自定义的接口必须准确匹配，如上所述。

对于着色器阶段的任何输入值，只要在前一个阶段写入到匹配的输出中，这个输入值就是良好定义的，如上所述。

另外，标量和向量输入，如果对应输入符合一下条件，那么它们就是良好定义的：

  * 输入与输出变量在修饰符上准确匹配。
  * 输出是一个vector，其元素类型是基础类型，且和输入便俩个的成员个数相同，且
  * 输入与输出变量的共同的成员类型 是32-bit 的整型或者浮点型（64-bit元素类型被排除在外）。

在此种情形下，输入变量的元素将会从输出的第一个元素中获取，输出中 另外的元素将会被忽略。


[[interfaces-iointerfaces-locations]]
=== Location 指配

本节描述一个给定的类型会消耗多少locations。
如前所述，几何着色器输入、细分控制着色器输入与输出、细分求值的输入，如其他着色器的输入输出相比，都带有一些额外的数组信息。
在计算输出数组类型消耗多少个location之前，输出中数组中数组信息已经被抹除。

code:Location 值指定了一个接口槽，其由一个32位的四分量数组组成，在不同的阶段中传送。
code:Component 指定了在这些数组中<<interfaces-iointerfaces-components, 分量>>。
着色器接口只支持位宽32或者64bit的类型。

输入、输出中如下类型消耗一个接口 location:

  * 32-bit 标量与向量类型，与
  * 64-bit 标量和2元素向量类型。

64-bit 3- 和 4- 成员向量消耗两个连续location。

若一个输入输出声明是大小为 _n_ 的数组，且每个元素占 _m_ 个location，它将被赋予  _m_ {times} _n_ 个连续的location，从指定的location开始。

若一个输入输出声明是一个 _n_ {times} _m_ 的 32- 或 64-bit 矩阵，它将被赋予指定的location起始的多个location。
每个矩阵所分配的location个数 和 一个 _n_-个数组元素且元素为_m_个成员的数组所消耗的location个数一样。

code:Input or code:Output 的数据结构类型的布局依赖于它是否是一个code:Block（即，是否有code:Block 修饰符）。

若它不是code:Block，那么数据结构类型必须有一个code:Location 修饰符。
它的成员将依它们被声明的顺序被赋予连续的location，第一个成员被赋予该数据类型所指定的location。
它的成员，和它们的嵌套类型，不能有code:Location描述符。

若数据结构是一个code:Block，但是没有code:Location描述符，那么它的每个成语必须有一个 code:Location 描述符。
若它是一个code:Block且带有一个code:Location 描述符，那么它的成员依声明顺序被赋予连续的location，从第一个成员开始，
第一个成员被赋予该code:Block所指定的location。
每个带有自己的code:Location的成员都被赋予该location，每个剩余的成员都️依它们声明顺序被立即赋予location。

一个块、数据结构成员消耗的location由应用上述的规则进行深度优先遍历实例化的成员所决定，如同数据结构或块的成员被声明为一个同类型的输入、输出变量。

Any two inputs listed as operands on the same code:OpEntryPoint must: not be
assigned the same location, either explicitly or implicitly.
Any two outputs listed as operands on the same code:OpEntryPoint must: not
be assigned the same location, either explicitly or implicitly.

一个着色器可用的输入与输出location数量是有限制的，取决于着色器阶段，如<<interfaces-iointerfaces-limits>>所述。


[[interfaces-iointerfaces-limits]]
.Shader Input and Output Locations
[width="90%",cols="<6,<13",options="header"]
|====
| Shader Interface              | Locations Available
| vertex input                  | pname:maxVertexInputAttributes
| vertex output                 | pname:maxVertexOutputComponents / 4
| tessellation control input    | pname:maxTessellationControlPerVertexInputComponents / 4
| tessellation control output   | pname:maxTessellationControlPerVertexOutputComponents / 4
| tessellation evaluation input | pname:maxTessellationEvaluationInputComponents / 4
| tessellation evaluation output| pname:maxTessellationEvaluationOutputComponents / 4
| geometry input                | pname:maxGeometryInputComponents / 4
| geometry output               | pname:maxGeometryOutputComponents / 4
| fragment input                | pname:maxFragmentInputComponents / 4
| fragment output               | pname:maxFragmentOutputAttachments
|====


[[interfaces-iointerfaces-components]]
=== 成员赋值

code:Component 修饰符允许 code:Location 更精细的被指定为标量和向量，精细到location内每个独立分量的消耗。
一个location内的分量分别是 are 0, 1, 2, 和 3.
从分量N开始的一个变量或块成员，将消耗分量N, N+1, N+2, ...，up through its size.
对于单精度类型，若此分量序列大于3，那么它就是无效的。
一个标量64位将消耗此序列中两个分量，一个 2-分量的64位数组类型将消耗一个location内可用的四个分量。
一个 3-分量或4-分量的的64位数组类型不能指定code:Component 修饰符。
一个 3-分量64-位数组类型将消耗第一个location所有四个分量，且消耗第二个location的分量0和1。
这导致分量2和3对于其他的分量限定的声明可用。

一个标量或者两个分量64位数据类型不能指定 code:Component描述1或者3.
一个code:Component 声明不能对不是标量或者数组类型
A code:Component decoration must: not be specified for any type that is not
a scalar or vector.


[[interfaces-vertexinput]]
== 顶点输入接口

当管线有顶点阶段时，顶点着色器输入变量就顶点输入属性形成了一个接口，
顶点着色器输入变量通过 code:Location 和 code:Component 修饰符 来匹配 由slink:VkGraphicsPipelineCreateInfo数据结构的成员pname:pVertexInputState 顶点输入属性。
带有code:Input存储class的修饰符 的 code:OpEntryPoint列出的顶点着色器输入变量 形成了 顶点输入接口。
这些变量必须通过code:Location修饰符唯一确定，且可以通过code:Component 修饰符唯一确定。

为了接口匹配，没有code:Component修饰的变量被认为带有一个值为0 的 code:Component修饰。

可用的顶点输入location 是通过 sname:VkPhysicalDeviceLimits数据结构的 pname:maxVertexInputAttributes 成员指定的。


参考 <<fxvertex-attrib-location>> 以获取更加详细的信息。

上述的所有的着色器输入必须在管线中与对应的属性和绑定。

[[interfaces-fragmentoutput]]
== 片元输出接口

当管线中存在片元着色阶段，片元着色器输出与当前subpass的输出附件之间 形成了一个接口。
片元着色器输出变量通过code:Location 和code:Component 修饰，与颜色附件匹配，
颜色附件由slink:VkSubpassDescription 类型的数组指定，
该数据类型描述了片元着色器执行所在的subpass。

通过code:Output存储类型修饰，被code:OpEntryPoint 列举的 片元着色器输出变量 形成了 片元输出接口。
这些变量必须被不同的code:Location所修饰。
它们也可以被code:Component和code:Index 联合唯一修饰。
为了接口匹配：没有code:Component 修饰的变量被认为其隐式的 code:Component 为0，
没有code:Index修饰的变量被认为其有一个隐式的 code:Index，值为0.

一个片元着色器输出变量有唯一的 code:Location _i_ 修饰，
颜色附件由pname:pColorAttachments[_i_] 表示，若其被启用了，如<<framebuffer-blending>>中所描述的
在传递万blending单元之后，将被定向到颜色附件，
Locations 的情况如
<<interfaces-iointerfaces-locations,Location Assignment>>所述。


可用的片元输出locations数量由sname:VkPhysicalDeviceLimits 数据结构的pname:maxFragmentOutputAttachments 所指定。

Components of the output variables are assigned as described in
<<interfaces-iointerfaces-components,Component Assignment>>.
Output components identified as 0, 1, 2, and 3 will be directed to the R, G,
B, and A inputs to the blending unit, respectively, or to the output
attachment if blending is disabled.
If two variables are placed within the same location, they must: have the
same underlying type (floating-point or integer).
The input to blending or color attachment writes is undefined for components
which do not correspond to a fragment shader output.

code:Index为0的片元输出被导向关联的对应code:Location的第一个blending单元输入。

No _component aliasing_ of output variables is allowed, that is there must:
not be two output variables which have the same location, component, and
index, either explicitly declared or implied.

Output values written by a fragment shader must: be declared with either
code:OpTypeFloat or code:OpTypeInt, and a Width of 32.
Composites of these types are also permitted.
If the color attachment has a signed or unsigned normalized fixed-point
format, color values are assumed to be floating-point and are converted to
fixed-point as described in <<fundamentals-fixedfpconv>>; otherwise no type
conversion is applied.
If the type of the values written by the fragment shader do not match the
format of the corresponding color attachment, the result is undefined for
those components.


[[interfaces-inputattachment]]
== 片元着色器输入附件接口

当管线将要执行到片元阶段，片元着色器subpass输入与当前subpass的输入附件之间 形成了一个接口。
片元着色器subpass输入变量与输入附件之间通过 code:InputAttachmentIndex修饰 匹配一致，
输入附件由slink:VkSubpassDescription数据类型的数组name:pInputAttachments指定，
该数据结构描述了片元着色器执行时所在的subpass。

带有code:UniformConstant描述类型，且带有被code:OpEntryPoint 静态使用的一个code:OpEntryPoint的
片元着色器subpass 输入变量形成了 片元输入附件接口。
这些变量必须被声明为 code:OpTypeImage 类型，一个code:Dim维的code:SubpassData操作数，
一个code:Sampled 操作数为2。

A subpass input variable identified with an code:InputAttachmentIndex
decoration of _i_ reads from the input attachment indicated by
pname:pInputAttachments[_i_] member of sname:VkSubpassDescription.
If the subpass input variable is declared as an array of size N, it consumes
N consecutive input attachments, starting with the index specified.
There must: not be more than one input variable with the same
code:InputAttachmentIndex whether explicitly declared or implied by an array
declaration.
The number of available input attachment indices is given by the
pname:maxPerStageDescriptorInputAttachments member of the
sname:VkPhysicalDeviceLimits structure.

带有 code:InputAttachmentIndex的变量必须只能在片元阶段被使用。
subpass 输入的基础的数据类型(floating-point, integer, unsigned integer) 必须与对应的输入附件的基础格式要匹配，
否则subpass从这些变量中取出的值将是未定义的。

参考 <<descriptorsets-inputattachment>> 获取更多细节。


[[interfaces-resources]]
== 着色器资源接口

当一个着色器阶段访问缓冲区或者图像资源，如<<descriptorsets,Resource Descriptors>> 一节所述，
着色器资源变量必须与 <<descriptorsets-pipelinelayout,pipeline layout>> 匹配，该布局在创建管线是被提供。

为一个管线阶段 形成了 着色器资源接口 形成着色器资源接口的着色器资源的集合，就是被带有
storage class of code:Uniform, code:UniformConstant, 或 code:PushConstant的code:OpEntryPoint静态使用的变量。
对于片元着色器，这包括 <<interfaces-inputattachment, fragment input attachment interface>>。

着色器资源接口有两个子接口组成：push constant接口和 描述符集合接口。


[[interfaces-resources-pushconst]]
=== Push Constant 接口

被code:PushConstant存储类别修饰符（被着色器入口点静态使用）定义的着色器变量  定义了一个 push constant接口。
它们必须是：

  * code:OpTypeStruct类型,
  * 使用code:Block 修饰来唯一确定， 且
  * 使用code:Offset , code:ArrayStride, 和
    code:MatrixStride 等修饰来显式布局，如 <<interfaces-resources-layout,Offset and Stride Assignment>>所述。

在每个着色器入口点内静态使用的 push constant不能多于一个。

在push constant block内的每一个变量必须在放在一个code:Offset处，故针对每个使用 slink:VkPushConstantRange的code:OpEntryPoint
全部constant值都保存在slink:VkPushConstantRange中，且该区间的 必须为用途指定合适的 elink:VkShaderStageFlagBits 。

push constant块内的任何变量的 code:Offset 修饰符都不能导致 该变量需求的空间超出区间
[eq]#[0, pname:maxPushConstantsSize)#.

在push constant 块内的任何被声明为数组的变量必须可以被  _dynamically uniform_ 索引访问。


[[interfaces-resources-descset]]
=== 描述符集合接口

描述符集合接口 由 code:Uniform 或 code:UniformConstant (including the
variables in the <<interfaces-inputattachment,fragment input attachment
interface>>) 存储类型修饰的 着色器变量组成， 变量被管线的着色器入口点 静态使用。

这些变量必须 由 code:DescriptorSet 和 code:Binding 修饰符指定，
管线布局中的sname:VkDescriptorSetLayout 对象对其赋值于匹配，管线布局如
<<interfaces-resources-setandbinding,DescriptorSet and Binding Assignment>>所述。

Variables identified with the code:UniformConstant storage class are used
only as handles to refer to opaque resources.
Such variables must: be typed as code:OpTypeImage, code:OpTypeSampler,
code:OpTypeSampledImage, or arrays of only these types.
Variables of type code:OpTypeImage must: have a code:Sampled operand of 1
(sampled image) or 2 (storage image).

Any array of these types must: only be indexed with constant integral
expressions, except under the following conditions:

  * For arrays of code:OpTypeImage variables with code:Sampled operand of 2,
    if the pname:shaderStorageImageArrayDynamicIndexing feature is enabled
    and the shader module declares the code:StorageImageArrayDynamicIndexing
    capability, the array must: only be indexed by dynamically uniform
    expressions.
  * For arrays of code:OpTypeSampler, code:OpTypeSampledImage variables, or
    code:OpTypeImage variables with code:Sampled operand of 1, if the
    pname:shaderSampledImageArrayDynamicIndexing feature is enabled and the
    shader module declares the code:SampledImageArrayDynamicIndexing
    capability, the array must: only be indexed by dynamically uniform
    expressions.

The code:Sampled code:Type of an code:OpTypeImage declaration must: match
the same basic data type as the corresponding resource, or the values
obtained by reading or sampling from this image are undefined.

The code:Image code:Format of an code:OpTypeImage declaration must: not be
*Unknown*, for variables which are used for code:OpImageRead or
code:OpImageWrite operations, except under the following conditions:

  * For code:OpImageWrite, if the pname:shaderStorageImageWriteWithoutFormat
    feature is enabled and the shader module declares the
    code:StorageImageWriteWithoutFormat capability.
  * For code:OpImageRead, if the pname:shaderStorageImageReadWithoutFormat
    feature is enabled and the shader module declares the
    code:StorageImageReadWithoutFormat capability.

Variables identified with the code:Uniform storage class are used to access
transparent buffer backed resources.
Such variables must: be:

  * typed as code:OpTypeStruct, or arrays of only this type,
  * identified with a code:Block or code:BufferBlock decoration, and
  * laid out explicitly using the code:Offset, code:ArrayStride, and
    code:MatrixStride decorations as specified in
    <<interfaces-resources-layout,Offset and Stride Assignment>>.

Any array of these types must: only be indexed with constant integral
expressions, except under the following conditions.

  * For arrays of code:Block variables, if the
    pname:shaderUniformBufferArrayDynamicIndexing feature is enabled and the
    shader module declares the code:UniformBufferArrayDynamicIndexing
    capability, the array must: only be indexed by dynamically uniform
    expressions.
  * For arrays of code:BufferBlock variables, if the
    pname:shaderStorageBufferArrayDynamicIndexing feature is enabled and the
    shader module declares the code:StorageBufferArrayDynamicIndexing
    capability, the array must: only be indexed by dynamically uniform
    expressions.

The code:Offset decoration for any variable in a code:Block must: not cause
the space required for that variable to extend outside the range [eq]#[0,
pname:maxUniformBufferRange)#.
The code:Offset decoration for any variable in a code:BufferBlock must: not
cause the space required for that variable to extend outside the range
[eq]#[0, pname:maxStorageBufferRange)#.

Variables identified with a storage class of code:UniformConstant and a
decoration of code:InputAttachmentIndex must: be declared as described in
<<interfaces-inputattachment,Fragment Input Attachment Interface>>.

Each shader variable declaration must: refer to the same type of resource as
is indicated by the pname:descriptorType.
See <<interfaces-resources-correspondence,Shader Resource and Descriptor
Type Correspondence>> for the relationship between shader declarations and
descriptor types.

[[interfaces-resources-correspondence]]
.Shader Resource and Descriptor Type Correspondence
[width="90%",cols="<1,<2",options="header"]
|====
| Resource type          | Descriptor Type
| sampler                | ename:VK_DESCRIPTOR_TYPE_SAMPLER
| sampled image          | ename:VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE
| storage image          | ename:VK_DESCRIPTOR_TYPE_STORAGE_IMAGE
| combined image sampler | ename:VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER
| uniform texel buffer   | ename:VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER
| storage texel buffer   | ename:VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER
| uniform buffer         | ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER +
                           ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC
| storage buffer         | ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER +
                           ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC
| input attachment       | ename:VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT
|====

.Shader Resource and Storage Class Correspondence
[width="100%",cols="<21%,<22%,<27%,<30%",options="header"]
|====
| Resource type   | Storage Class | Type | Decoration(s)^1^
| sampler
        | code:UniformConstant | code:OpTypeSampler |
| sampled image
        | code:UniformConstant | code:OpTypeImage (code:Sampled=1)|
| storage image
        | code:UniformConstant | code:OpTypeImage (code:Sampled=2) |
| combined image sampler
        | code:UniformConstant | code:OpTypeSampledImage |
| uniform texel buffer
        | code:UniformConstant | code:OpTypeImage (code:Dim=code:Buffer, code:Sampled=1) |
| storage texel buffer
        | code:UniformConstant | code:OpTypeImage (code:Dim=code:Buffer, code:Sampled=2) |
| uniform buffer
        | code:Uniform         | code:OpTypeStruct
        | code:Block, code:Offset, (code:ArrayStride), (code:MatrixStride)
| storage buffer
        | code:Uniform         | code:OpTypeStruct
        | code:BufferBlock, code:Offset, (code:ArrayStride), (code:MatrixStride)
| input attachment
        | code:UniformConstant | code:OpTypeImage (code:Dim=code:SubpassData, code:Sampled=2)
        | code:InputAttachmentIndex
|====
1:: in addition to code:DescriptorSet and code:Binding


[[interfaces-resources-setandbinding]]
=== 描述符集合、绑定赋值

A variable identified with a code:DescriptorSet decoration of [eq]#s# and a
code:Binding decoration of [eq]#b# indicates that this variable is
associated with the slink:VkDescriptorSetLayoutBinding that has a
pname:binding equal to [eq]#b# in pname:pSetLayouts[_s_] that was specified
in slink:VkPipelineLayoutCreateInfo.

The range of descriptor sets is between zero and
pname:maxBoundDescriptorSets minus one.
If a descriptor set value is statically used by an entry point there must:
be an associated pname:pSetLayout in the corresponding pipeline layout as
described in <<descriptorsets-pipelinelayout-consistency,Pipeline Layouts
consistency>>.

If the code:Binding decoration is used with an array, the entire array is
identified with that binding value.
The size of the array declaration must: be no larger than the
pname:descriptorCount of that sname:VkDescriptorSetLayoutBinding.
The index of each element of the array is referred to as the _arrayElement_.
For the purposes of interface matching and descriptor set
<<descriptorsets-updates,operations>>, if a resource variable is not an
array, it is treated as if it has an arrayElement of zero.

The binding can: be any 32-bit unsigned integer value, as described in
<<descriptorsets-setlayout>>.
Each descriptor set has its own binding name space.

There is a limit on the number of resources of each type that can: be
accessed by a pipeline stage as shown in
<<interfaces-resources-limits,Shader Resource Limits>>.
The "`Resources Per Stage`" column gives the limit on the number each type
of resource that can: be statically used for an entry point in any given
stage in a pipeline.
The "`Resource Types`" column lists which resource types are counted against
the limit.
Some resource types count against multiple limits.

If multiple entry points in the same pipeline refer to the same set and
binding, all variable definitions with that code:DescriptorSet and
code:Binding must: have the same basic type.

Not all descriptor sets and bindings specified in a pipeline layout need to
be used in a particular shader stage or pipeline, but if a
code:DescriptorSet and code:Binding decoration is specified for a variable
that is statically used in that shader there must: be a pipeline layout
entry identified with that descriptor set and pname:binding and the
corresponding pname:stageFlags must: specify the appropriate
elink:VkShaderStageFlagBits for that stage.


[[interfaces-resources-limits]]
.Shader Resource Limits
[width="80%",cols="<35,<23",options="header"]
|====
| Resources per Stage                   | Resource Types
.2+<.^| pname:maxPerStageDescriptorSamplers
            | sampler           | combined image sampler
.3+<.^| pname:maxPerStageDescriptorSampledImages
            | sampled image     | combined image sampler | uniform texel buffer
.2+<.^| pname:maxPerStageDescriptorStorageImages
            | storage image     | storage texel buffer
.2+<.^| pname:maxPerStageDescriptorUniformBuffers
            | uniform buffer    | uniform buffer dynamic
.2+<.^| pname:maxPerStageDescriptorStorageBuffers
            | storage buffer    | storage buffer dynamic
| pname:maxPerStageDescriptorInputAttachments
            | input attachment^1^
|====

1::
    Input attachments can: only be used in the fragment shader stage


[[interfaces-resources-layout]]
=== 偏移、步长设值

All variables with a storage class of code:PushConstant or code:Uniform
must: be explicitly laid out using the code:Offset, code:ArrayStride, and
code:MatrixStride decorations.
There are two different layouts requirements depending on the specific
resources.

[[interfaces-resources-layout-std140]]
*Standard Uniform Buffer Layout*

Member variables of an code:OpTypeStruct with storage class of code:Uniform
and a decoration of code:Block (uniform buffers) must: be laid out according
to the following rules.

  * The code:Offset Decoration must: be a multiple of its base alignment,
    computed recursively as follows:
  ** a scalar of size [eq]#N# has a base alignment of [eq]#N#
  ** a two-component vector, with components of size [eq]#N#, has a base
     alignment of [eq]#2 N#
  ** a three- or four-component vector, with components of size [eq]#N#, has
     a base alignment of [eq]#4 N#
  ** an array has a base alignment equal to the base alignment of its
     element type, rounded up to a multiple of [eq]#16#
  ** a structure has a base alignment equal to the largest base alignment of
     any of its members, rounded up to a multiple of [eq]#16#
  ** a row-major matrix of [eq]#C# columns has a base alignment equal to the
     base alignment of vector of [eq]#C# matrix components
  ** a column-major matrix has a base alignment equal to the base alignment
     of the matrix column type
  * Any code:ArrayStride or code:MatrixStride decoration must: be an integer
    multiple of the base alignment of the array or matrix from above.
  * The code:Offset Decoration of a member must: not place it between the
    end of a structure or an array and the next multiple of the base
    alignment of that structure or array.
  * The numeric order of code:Offset Decorations need not follow member
    declaration order.

[NOTE]
.注意
====
The *std140 layout* in GLSL satisfies these rules.
====

[[interfaces-resources-layout-std430]]
*Standard Storage Buffer Layout*

Member variables of an code:OpTypeStruct with a storage class of
code:PushConstant (push constants), or a storage class of code:Uniform with
a decoration of code:BufferBlock (storage buffers) must: be laid out as
<<interfaces-resources-layout-std140,above>>, except for array and structure
base alignment which do not need to be rounded up to a multiple of [eq]#16#.

[NOTE]
.注意
====
The *std430 layout* in GLSL satisfies these rules.
====


[[interfaces-builtin-variables]]
== 内置变量

带有code:BuiltIn 修饰符修饰的变量是内置变量，可以在着色器内被访问。

每个 code:BuiltIn 修饰的含义有如下几种：
此节的剩余部分，内置变量的名称与术语带有内置修饰符的变量等同。
内置变量中整数类型的可以被声明为有符号或者无符号整数。

ifdef::VK_AMD_shader_explicit_vertex_parameter[]
code:BaryCoordNoPerspAMD::

code:BaryCoordNoPerspAMD 修饰符可以用于修饰片元着色器输入变量。
此变量将含有 (I,J)对重心坐标，对应着使用线性差值的像素中心的片元求值。
中心坐标的K坐标可以根据给定的 I + J + K = 1.0 公式推导。

code:BaryCoordNoPerspCentroidAMD::

code:BaryCoordNoPerspCentroidAMD 修饰符可以用于片元着色器输入变量。
此变量将含有 (I,J)对重心坐标，对应着在此重心使用线性差值的片元求值。
中心坐标的K坐标可以根据给定的 I + J + K = 1.0 公式推导。

code:BaryCoordNoPerspSampleAMD::

code:BaryCoordNoPerspCentroidAMD 修饰符可以用于片元着色器输入变量。
此变量将含有 (I,J)对重心坐标，对应着在每一个覆盖的采样点使用线性差值的片元求值。
中心坐标的K坐标可以根据给定的 I + J + K = 1.0 公式推导。

code:BaryCoordPullModelAMD::

code:BaryCoordPullModelAMD 修饰符 可以用于片元着色器输入变量。
This variable will contain (1/W, 1/I, 1/J) evaluated at the pixel center and
can: be used to calculate gradients and then interpolate I, J, and W at any
desired sample location.

code:BaryCoordSmoothAMD::

The code:BaryCoordSmoothAMD decoration can: be used to decorate a fragment
shader input variable.
This variable will contain the (I,J) pair of the barycentric coordinates
corresponding to the fragment evaluated using perspective interpolation at
the pixel's center.
中心坐标的K坐标可以根据给定的 I + J + K = 1.0 公式推导。

code:BaryCoordSmoothCentroidAMD::

The code:BaryCoordSmoothCentroidAMD decoration can: be used to decorate a
fragment shader input variable.
This variable will contain the (I,J) pair of the barycentric coordinates
corresponding to the fragment evaluated using perspective interpolation at
the centroid.
中心坐标的K坐标可以根据给定的 I + J + K = 1.0 公式推导。

code:BaryCoordSmoothSampleAMD::

The code:BaryCoordSmoothCentroidAMD decoration can: be used to decorate a
fragment shader input variable.
This variable will contain the (I,J) pair of the barycentric coordinates
corresponding to the fragment evaluated using perspective interpolation at
each covered sample.
中心坐标的K坐标可以根据给定的 I + J + K = 1.0 公式推导。

endif::VK_AMD_shader_explicit_vertex_parameter[]

ifdef::VK_KHR_shader_draw_parameters[]

[[interfaces-builtin-variables-baseinstance]]
code:BaseInstance::

Decorating a variable with the code:BaseInstance built-in will make that
variable contain the integer value corresponding to the first instance that
was passed to the command that invoked the current vertex shader invocation.
code:BaseInstance is the pname:firstInstance parameter to a _direct drawing
command_ or the pname:firstInstance member of a structure consumed by an
_indirect drawing command_.
+
code:BaseInstance 修饰符只能在顶点着色器内使用。
+
BaseInstance 修饰的变量必须使用 input 存储类别来声明。
+
BaseInstance 修饰的变量必须被声明为32位整型标量。

[[interfaces-builtin-variables-basevertex]]
code:BaseVertex::

Decorating a variable with the code:BaseVertex built-in will make that
variable contain the integer value corresponding to the first vertex or
vertex offset that was passed to the command that invoked the current vertex
shader invocation.
For _non-indexed drawing commands_, this variable is the pname:firstVertex
parameter to a _direct drawing command_ or the pname:firstVertex member of
the structure consumed by an _indirect drawing command_.
For _indexed drawing commands_, this variable is the pname:vertexOffset
parameter to a _direct drawing command_ or the pname:vertexOffset member of
the structure consumed by an _indirect drawing command_.
+
code:BaseVertex 修饰符只能在顶点着色器内使用。
+
code:BaseVertex 修饰的变量必须使用 input 存储类别来声明。
+
codeBaseVertex 修饰的变量必须被声明位32位整型标量。

endif::VK_KHR_shader_draw_parameters[]

code:ClipDistance::

Decorating a variable with the code:ClipDistance built-in decoration will
make that variable contain the mechanism for controlling user clipping.
code:ClipDistance is an array such that the i^th^ element of the array
specifies the clip distance for plane i.
A clip distance of 0 means the vertex is on the plane, a positive distance
means the vertex is inside the clip half-space, and a negative distance
means the point is outside the clip half-space.
+
code:ClipDistance 修饰符只能在顶点、片元、细分控制、细分求值、几何着色器内使用。
+
在顶点着色器内，code:ClipDistance 修饰的任何变量必须使用 code:Output 存储类别来声明。
+
在片元着色器内，code:ClipDistance 修饰的变量必须使用code:Input 存储类别来声明。
+
在细分控制、细分求值、几何着色器内，code:ClipDistance 修饰的任何变量只能是code:Input 或者 code:Output类别。
+
code:ClipDistance 修饰的任何变量必须位声明位32位浮点型的数组。

[NOTE]
.注意
====
code:ClipDistance修饰的数组变量，会自动被着色器填充大小。
====

[NOTE]
.注意
====
In the last vertex processing stage, these values will be linearly
interpolated across the primitive and the portion of the primitive with
interpolated distances less than 0 will be considered outside the clip
volume.
If code:ClipDistance is then used by a fragment shader, code:ClipDistance
contains these linearly interpolated values.
====

code:CullDistance::

Decorating a variable with the code:CullDistance built-in decoration will
make that variable contain the mechanism for controlling user culling.
If any member of this array is assigned a negative value for all vertices
belonging to a primitive, then the primitive is discarded before
rasterization.
+
code:CullDistance 修饰符只能在顶点、片元、细分控制、细分求值、几何着色器中使用。
+
在顶点着色器中，code:CullDistance 修饰的任何变量必须使用 code:Output 存储类别来声明。
+
在片元着色器中，code:CullDistance 修饰的任何变量必须使用 code:Input 存储类别来声明。
+
In tessellation control, tessellation evaluation, or geometry shaders, any
variable decorated with code:CullDistance must: not be declared in a storage
class other than input or output.
+
code:CullDistance 修饰的任何变量必须被声明位32位浮点型的三元素数组。

[NOTE]
.注意
====
在片元着色器中，code:CullDistance 数组的值在每个图元之间被线性差值。
====

[NOTE]
.注意
====
If code:CullDistance decorates an input variable, that variable will contain
the corresponding value from the code:CullDistance decorated output variable
from the previous shader stage.
====

ifdef::VK_KHR_shader_draw_parameters[]

[[interfaces-builtin-variables-drawindex]]
code:DrawIndex::

Decorating a variable with the code:DrawIndex built-in will make that
variable contain the integer value corresponding to the zero-based index of
the drawing command that invoked the current vertex shader invocation.
For _indirect drawing commands_, code:DrawIndex begins at zero and
increments by one for each draw command executed.
The number of draw commands is given by the pname:drawCount parameter.
For _direct drawing commands_, code:DrawIndex is always zero.
code:DrawIndex is dynamically uniform.
+
code:DrawIndex 修饰符只能在顶点着色器中使用。
+
code:DrawIndex 修饰的变量必须使用 input存储类别来声明。
+
code:DrawIndex 修饰的变量必须被声明位32位整型标量。

endif::VK_KHR_shader_draw_parameters[]

code:FragCoord::

Decorating a variable with the code:FragCoord built-in decoration will make
that variable contain the framebuffer coordinate
latexmath:[(x,y,z,\frac{1}{w})] of the fragment being processed.
The [eq]#(x,y)# coordinate [eq]#(0,0)# is the upper left corner of the upper
left pixel in the framebuffer.
+
When sample shading is enabled, the [eq]#x# and [eq]#y# components of
code:FragCoord reflect the location of the sample corresponding to the
shader invocation.
+
When sample shading is not enabled, the x and y components of code:FragCoord
reflect the location of the center of the pixel, [eq]#(0.5,0.5)#.
+
The [eq]#z# component of code:FragCoord is the interpolated depth value of
the primitive.
+
The [eq]#w# component is the interpolated latexmath:[\frac{1}{w}].
+
code:FragCoord 修饰符只能在片元着色器中使用。
+
code:FragCoord 修饰的变量必须使用code:Input 存储类别来声明。
+
code:Centroid 差值修饰副被忽略，但是在code:FragCoord上是允许的。
+
code:FragCoord 修饰的变量必须被声明位32位浮点型的四元素数组。

code:FragDepth::

Decorating a variable with the code:FragDepth built-in decoration will make
that variable contain the new depth value for all samples covered by the
fragment.
This value will be used for depth testing and, if the depth test passes, any
subsequent write to the depth/stencil attachment.
+
To write to code:FragDepth, a shader must: declare the code:DepthReplacing
execution mode.
If a shader declares the code:DepthReplacing execution mode and there is an
execution path through the shader that does not set code:FragDepth, then the
fragment's depth value is undefined for executions of the shader that take
that path.
+
code:FragDepth 修饰符只能在片元着色器中使用。
+
code:FragDepth 修饰的变量必须使用code:Output 存储类别来声明。
+
code:FragDepth 修饰的变量必须被声明位32位浮点型标量。

code:FrontFacing::

Decorating a variable with the code:FrontFacing built-in decoration will
make that variable contain whether a primitive is front or back facing.
This variable is non-zero if the current fragment is considered to be part
of a <<primsrast-polygons-basic,front-facing>> primitive and is zero if the
fragment is considered to be part of a back-facing primitive.
+
code:FrontFacing 修饰符只能在片元着色器中使用。
+
code:FrontFacing 修饰的变量必须使用 code:Input 存储类别来声明。
+
code:FrontFacing 修饰的变量必须被声明位boolean 类型。

code:GlobalInvocationId::

Decorating a variable with the code:GlobalInvocationId built-in decoration
will make that variable contain the location of the current invocation
within the global workgroup.
Each component is equal to the index of the local workgroup multiplied by
the size of the local workgroup plus code:LocalInvocationId.
+
code:GlobalInvocationId 修饰符只能在计算着色器中使用。
+
code:GlobalInvocationId 修饰的变量必须使用 code:Input 存储类别来声明。
+
code:GlobalInvocationId 修饰的变量必须被声明为32位整型的三元素数组。

code:HelperInvocation::

Decorating a variable with the code:HelperInvocation built-in decoration
will make that variable contain whether the current invocation is a helper
invocation.
This variable is non-zero if the current fragment being shaded is a helper
invocation and zero otherwise.
A helper invocation is an invocation of the shader that is produced to
satisfy internal requirements such as the generation of derivatives.
+
code:HelperInvocation 修饰符必须在片元着色器中使用。
+
code:HelperInvocation 修饰的变量必须使用 code:Input 存储类别来声明。
+
code:HelperInvocation 修饰的变量必须位声明为boolean类型。

[NOTE]
.注意
====
It is very likely that a helper invocation will have a value of
code:SampleMask fragment shader input value that is zero.
====

code:InvocationId::

Decorating a variable with the code:InvocationId built-in decoration will
make that variable contain the index of the current shader invocation in a
geometry shader, or the index of the output patch vertex in a tessellation
control shader.
+
In a geometry shader, the index of the current shader invocation ranges from
zero to the number of <<geometry-invocations,instances>> declared in the
shader minus one.
If the instance count of the geometry shader is one or is not specified,
then code:InvocationId will be zero.
+
code:InvocationId 修饰符只能在细分控制、几何着色器中使用。
+
code:InvocationId 修饰的变量必须使用code:Input 存储类别来声明。
+
code:InvocationId 修饰的变量必须被声明为32位整型标量。

code:InstanceIndex::

Decorating a variable with the code:InstanceIndex built-in decoration will
make that variable contain the index of the instance that is being processed
by the current vertex shader invocation.
code:InstanceIndex begins at the pname:firstInstance parameter to
flink:vkCmdDraw or flink:vkCmdDrawIndexed or at the pname:firstInstance
member of a structure consumed by flink:vkCmdDrawIndirect or
flink:vkCmdDrawIndexedIndirect.
+
code:InstanceIndex 修饰符只能在顶点着色器中使用。
+
code:InstanceIndex 修饰的变量必须使用code:Input 存储类别来声明。
+
code:InstanceIndex 修饰的变量必须被声明位一个32位整型标量。

code:Layer::

Decorating a variable with the code:Layer built-in decoration will make that
variable contain the select layer of a multi-layer framebuffer attachment.
+
In a geometry shader, any variable decorated with code:Layer can be written
with the framebuffer layer index to which the primitive produced by the
geometry shader will be directed.
If a geometry shader entry point's interface does not include a variable
decorated with code:Layer, then the first layer is used.
If a geometry shader entry point's interface includes a variable decorated
with code:Layer, it must: write the same value to code:Layer for all output
vertices of a given primitive.
+
In a fragment shader, a variable decorated with code:Layer contains the
layer index of the primitive that the fragment invocation belongs to.
+
code:Layer 修饰符只能在几何、片元着色器中使用。
+
在几何着色器中，code:Layer 修饰的任何变量必须使用code:Output 存储类别来声明。
+
在片元着色器中，  code:Layer 修饰的任何变量必须使用code:Input 存储类别来声明。
+
code:Layer 修饰的任何变量必须被声明位32位整型标量。

code:LocalInvocationId::

Decorating a variable with the code:LocalInvocationId built-in decoration
will make that variable contain the location of the current compute shader
invocation within the local workgroup.
Each component ranges from zero through to the size of the workgroup in that
dimension minus one.
+
code:LocalInvocationId 修饰符必须在计算着色器中使用。
+
code:LocalInvocationId 修饰的变量必须使用 code:Input 存储类别来声明。
+
code:LocalInvocationId 修饰的变量必须被声明位32位整型的三元素向量。

[NOTE]
.注意
====
If the size of the workgroup in a particular dimension is one, then the
code:LocalInvocationId in that dimension will be zero.
If the workgroup is effectively two-dimensional, then
code:LocalInvocationId.z will be zero.
If the workgroup is effectively one-dimensional, then both
code:LocalInvocationId.y and code:LocalInvocationId.z will be zero.
====

code:NumWorkgroups::

Decorating a variable with the code:NumWorkgroups built-in decoration will
make that variable contain the number of local workgroups that are part of
the dispatch that the invocation belongs to.
Each component is equal to the values of the parameters passed into
flink:vkCmdDispatch or read from the sname:VkDispatchIndirectCommand
structure read through a call to flink:vkCmdDispatchIndirect.
+
code:NumWorkgroups 修饰符只能在计算着色器中使用。
+
code:NumWorkgroups 修饰的变量必须使用code:Input 存储类别来声明。
+
code:NumWorkgroups 修饰的变量必须被声明位32位整型的三元素数组。

code:PatchVertices::

Decorating a variable with the code:PatchVertices built-in decoration will
make that variable contain the number of vertices in the input patch being
processed by the shader.
A single tessellation control or tessellation evaluation shader can: read
patches of differing sizes, so the value of the code:PatchVertices variable
may: differ between patches.
+
code:PatchVertices 修饰符只能在细分控制、细分求值着色器中使用。
+
code:PatchVertices 修饰的变量必须使用code:Input 存储类别来声明。
+
code:PatchVertices 修饰的变量必须被声明位32位整型标量。

code:PointCoord::

Decorating a variable with the code:PointCoord built-in decoration will make
that variable contain the coordinate of the current fragment within the
point being rasterized, normalized to the size of the point with origin in
the upper left corner of the point, as described in
<<primsrast-points-basic,Basic Point Rasterization>>.
If the primitive the fragment shader invocation belongs to is not a point,
then the variable decorated with code:PointCoord contains an undefined
value.
+
code:PointCoord 修饰符只能在片元着色器中使用。
+
code:PointCoord 修饰的变量必须使用code:Input  存储类别来声明。
+
code:PointCoord 修饰的变量必须被声明位32位浮点型二元素数组。


[NOTE]
.注意
====
Depending on how the point is rasterized, code:PointCoord may: never reach
[eq]#(0,0)# or [eq]#(1,1)#.
====

code:PointSize::

Decorating a variable with the code:PointSize built-in decoration will make
that variable contain the size of point primitives.
The value written to the variable decorated with code:PointSize by the last
vertex processing stage in the pipeline is used as the framebuffer-space
size of points produced by rasterization.
+
code:PointSize 修饰符只能在顶点、细分控制、细分求值、几何着色器中使用。shaders.
+
在顶点着色器中，code:PointSize 修饰的任何变量必须使用code:Output 存储类别来声明。
+
在细分控制、细分求值、几何着色器中，code:PointSize 修饰的任何变量必须使用
code:Input 或者 code:Output 存储类别来声明。
+
code:PointSize 修饰的任何变量必须被声明位一个32位浮点型标量。

[NOTE]
.注意
====
When code:PointSize decorates a variable in the code:Input storage class, it
contains the data written to the output variable decorated with
code:PointSize from the previous shader stage.
====

code:Position::

Decorating a variable with the code:Position built-in decoration will make
that variable contain the position of the current vertex.
In the last vertex processing stage, the value of the variable decorated
with code:Position is used in subsequent primitive assembly, clipping, and
rasterization operations.
+
code:Position 修饰符只能在顶点、细分控制、细分求值、几何着色器中使用。
+
在顶点着色器中，code:Position 修饰的任何变量必须使用 code:Output 存储类别来声明。
+
在细分控制、细分求值或几何着色器中，  code:Position 修饰的任何变量只能使用 input 或者 output存储类别来声明。
+
code:Position 修饰的任何变量必须被声明为32位浮点型的四元素数组。

[NOTE]
.注意
====
When code:Position decorates a variable in the code:Input storage class, it
contains the data written to the output variable decorated with
code:Position from the previous shader stage.
====

code:PrimitiveId::

Decorating a variable with the code:PrimitiveId built-in decoration will
make that variable contain the index of the current primitive.
+
In tessellation control and tessellation evaluation shaders, it will contain
the index of the patch within the current set of rendering primitives that
correspond to the shader invocation.
+
In a geometry shader, it will contain the number of primitives presented as
input to the shader since the current set of rendering primitives was
started.
+
In a fragment shader, it will contain the primitive index written by the
geometry shader if a geometry shader is present, or with the value that
would have been presented as input to the geometry shader had it been
present.
+
If a geometry shader is present and the fragment shader reads from an input
variable decorated with code:PrimitiveId, then the geometry shader must:
write to an output variable decorated with code:PrimitiveId in all execution
paths.
+
The code:PrimitiveId decoration must: be used only within fragment,
tessellation control, tessellation evaluation, and geometry shaders.
+
In a tessellation control or tessellation evaluation shader, any variable
decorated with code:PrimitiveId must: be declared using the code:Output
storage class.
+
In a geometry shader, any variable decorated with code:PrimitiveId must: be
declared using either the code:Input or code:Output storage class.
+
In a fragment shader, any variable decorated with code:PrimitiveId must: be
declared using the code:Input storage class, and either the code:Geometry or
code:Tessellation capability must also be declared.
+
Any variable decorated with code:PrimitiveId must: be declared as a scalar
32-bit integer.

[NOTE]
.注意
====
当code:PrimitiveId 修饰符被应用到几何着色器的一个输出变量上，生成的值在片元着色器中可以通过code:PrimitiveId修饰的输入变量看到。
====

code:SampleId::

Decorating a variable with the code:SampleId built-in decoration will make
that variable contain the zero-based index of the sample the invocation
corresponds to.
code:SampleId ranges from zero to the number of samples in the framebuffer
minus one.
If a fragment shader entry point's interface includes an input variable
decorated with code:SampleId, per-sample shading is enabled for draws that
use that fragment shader.
+
code:SampleId 修饰符只能在片元着色器中使用。
+
code:SampleId 修饰的变量只能使用code:Input 存储类别修饰。
+
code:SampleId修饰的变量必须被声明为32位的标量整型。

code:SampleMask::

Decorating a variable with the code:SampleMask built-in decoration will make
any variable contain the sample coverage mask for the current fragment
shader invocation.
+
A variable in the code:Input storage class decorated with code:SampleMask
will contain a bitmask of the set of samples covered by the primitive
generating the fragment during rasterization.
It has a sample bit set if and only if the sample is considered covered for
this fragment shader invocation.
code:SampleMask[] is an array of integers.
Bits are mapped to samples in a manner where bit B of mask M
(`SampleMask[M]`) corresponds to sample [eq]#32 {times} M + B#.
+
When state specifies multiple fragment shader invocations for a given
fragment, the sample mask for any single fragment shader invocation
specifies the subset of the covered samples for the fragment that correspond
to the invocation.
In this case, the bit corresponding to each covered sample will be set in
exactly one fragment shader invocation.
+
A variable in the code:Output storage class decorated with code:SampleMask
is an array of integers forming a bit array in a manner similar an input
variable decorated with code:SampleMask, but where each bit represents
coverage as computed by the shader.
Modifying the sample mask by writing zero to a bit of code:SampleMask causes
the sample to be considered uncovered.
However, setting sample mask bits to one will never enable samples not
covered by the original primitive.
If the fragment shader is being evaluated at any frequency other than
per-fragment, bits of the sample mask not corresponding to the current
fragment shader invocation are ignored.
This array must: be sized in the fragment shader either implicitly or
explicitly, to be no larger than the implementation-dependent maximum
sample-mask (as an array of 32-bit elements), determined by the maximum
number of samples.
If a fragment shader entry point's interface includes an output variable
decorated with code:SampleMask, the sample mask will be undefined for any
array elements of any fragment shader invocations that fail to assign a
value.
If a fragment shader entry point's interface does not include an output
variable decorated with code:SampleMask, the sample mask has no effect on
the processing of a fragment.
+
The code:SampleMask decoration must: be used only within fragment shaders.
+
Any variable decorated with code:SampleMask must: be declared using either
the code:Input or code:Output storage class.
+
code:SampleMask修饰的任何变量必须被声明为32位整型的数组。

code:SamplePosition::

Decorating a variable with the code:SamplePosition built-in decoration will
make that variable contain the sub-pixel position of the sample being
shaded.
The top left of the pixel is considered to be at coordinate [eq]#(0,0)# and
the bottom right of the pixel is considered to be at coordinate [eq]#(1,1)#.
If a fragment shader entry point's interface includes an input variable
decorated with code:SamplePosition, per-sample shading is enabled for draws
that use that fragment shader.
+
code:SamplePosition 修饰符必须只在片元着色器中使用。
+
code:SamplePosition修饰的变量必须使用code:Input 存储类别来声明。
+
The variable decorated with code:SamplePosition must: be declared as a
two-component vector of 32-bit floating-point values.

ifdef::VK_EXT_shader_subgroup_ballot[]

[[interfaces-builtin-variables-sgeq]]
code:SubgroupEqMaskKHR::
+
Decorating a variable with the code:SubgroupEqMaskKHR builtin decoration
will make that variable contain the _subgroup mask_ of the current subgroup
invocation.
The bit corresponding to the code:SubgroupLocalInvocationId is set in the
variable decorated with code:SubgroupEqMaskKHR.
All other bits are set to zero.
+
code:SubgroupEqMaskKHR修饰的变量必须使用code:Input 存储类别 来声明。
+
The variable decorated with code:SubgroupEqMaskKHR must: be declared as a
four-component vector of 32-bit integer values.

[[interfaces-builtin-variables-sgge]]
code:SubgroupGeMaskKHR::
+
Decorating a variable with the code:SubgroupGeMaskKHR builtin decoration
will make that variable contain the _subgroup mask_ of the invocations
greater than or equal to the current subgroup invocation.
The bits corresponding to the invocations greather than or equal to
code:SubgroupLocalInvocationId through code:SubgroupSize-1 are set in the
variable decorated with code:SubgroupGeMaskKHR.
All other bits are set to zero.
+
code:SubgroupGeMaskKHR修饰的变量必须使用 code:Input 存储类别来声明。
+
The variable decorated with code:SubgroupGeMaskKHR must: be declared as a
four-component vector of 32-bit integer values.

[[interfaces-builtin-variables-sggt]]
code:SubgroupGtMaskKHR::
+
Decorating a variable with the code:SubgroupGtMaskKHR builtin decoration
will make that variable contain the _subgroup mask_ of the invocations
greater than the current subgroup invocation.
The bits corresponding to the invocations greater than
code:SubgroupLocalInvocationId through code:SubgroupSize-1 are set in the
variable decorated with code:SubgroupGtMaskKHR.
All other bits are set to zero.
+
code:SubgroupGtMaskKHR修饰的变量必须使用  code:Input存储类别来声明。
+
code:SubgroupGtMaskKHR 修饰的变量必须被声明位32位整型的四元素数组。

[[interfaces-builtin-variables-sgle]]
code:SubgroupLeMaskKHR::
+
Decorating a variable with the code:SubgroupLeMaskKHR builtin decoration
will make that variable contain the _subgroup mask_ of the invocations less
than or equal to the current subgroup invocation.
The bits corresponding to the invocations less than or equal to
code:SubgroupLocalInvocationId are set in the variable decorated with
code:SubgroupLeMaskKHR.
All other bits are set to zero.
+
code:SubgroupLeMaskKHR 修饰的变量必须使用 code:Input 存储类别来声明。
+
code:SubgroupLeMaskKHR 声明的变量必须被声明位32位整型的四元素数组。

[[interfaces-builtin-variables-sglt]]
code:SubgroupLtMaskKHR::
+
Decorating a variable with the code:SubgroupLtMaskKHR builtin decoration
will make that variable contain the _subgroup mask_ of the invocations less
than the current subgroup invocation.
The bits corresponding to the invocations less than
code:SubgroupLocalInvocationId are set in the variable decorated with
code:SubgroupLtMaskKHR.
All other bits are set to zero.
+
code:SubgroupLtMaskKHR 修饰的变量必须使用 code:Input 存储类别来声明。
+
code:SubgroupLtMaskKHR 修饰的变量必须声明为32位整型的四元素数组。

[[interfaces-builtin-variables-sgli]]
code:SubgroupLocalInvocationId::
+
Decorating a variable with the code:SubgroupLocalInvocationId builtin
decoration will make that variable contain the index of the invocation
within the subgroup.
This variable is in range [0,code:SubgroupSize-1].
+
code:SubgroupLocalInvocationId修饰的变量必须使用 code:Input 存储类别来声明。
+
code:SubgroupLocalInvocationId 修饰的变量必须被声明为32位整型标量。


[[interfaces-builtin-variables-sgs]]
code:SubgroupSize::
+
Decorating a variable with the code:SubgroupSize builtin decoration will
make that variable contain the implementation-dependent maximum number of
invocations in a subgroup.
The maximum number of invocations that an implementation can support per
subgroup is 128.
+
code:SubgroupSize 修饰的变量必须使用 code:Input 存储类别来声明。
+
code:SubgroupSize 修饰的变量必须被声明位32位整型标量。

endif::VK_EXT_shader_subgroup_ballot[]

code:TessCoord::

Decorating a variable with the code:TessCoord built-in decoration will make
that variable contain the three-dimensional [eq]#(u,v,w)# barycentric
coordinate of the tessellated vertex within the patch.
[eq]#u#, [eq]#v#, and [eq]#w# are in the range [eq]#[0,1]# and vary linearly
across the primitive being subdivided.
For the tessellation modes of code:Quads or code:IsoLines, the third
component is always zero.
+
code:TessCoord 修饰符只能在细分求值着色器中使用。
+
code:TessCoord修饰的变量必须使用code:Input 存储类别来声明。
+
code:TessCoord 修饰的变量必须被声明为 32位浮点类型的三元素数组。

code:TessLevelOuter::

Decorating a variable with the code:TessLevelOuter built-in decoration will
make that variable contain the outer tessellation levels for the current
patch.
+
In tessellation control shaders, the variable decorated with
code:TessLevelOuter can: be written to which controls the tessellation
factors for the resulting patch.
These values are used by the tessellator to control primitive tessellation
and can: be read by tessellation evaluation shaders.
+
在细分求值着色器内，code:TessLevelOuter修饰的变量可以读取 细分控制着色器写入的值。
+
code:TessLevelOuter 修饰符只能在细分控制着色器、细分求值着色器中使用。
+
在细分控制着色器内，code:TessLevelOuter修饰的任何变量必须使用 code:Output 存储类别来声明。
+
在细分求值着色器内，code:TessLevelOuter修饰的任何变量必须使用 code:Input 存储类别来声明。
+
code:TessLevelOuter修饰的任何变量必须被声明为32位浮点型的四元素数组。

code:TessLevelInner::

Decorating a variable with the code:TessLevelInner built-in decoration will
make that variable contain the inner tessellation levels for the current
patch.
+
In tessellation control shaders, the variable decorated with
code:TessLevelInner can: be written to, which controls the tessellation
factors for the resulting patch.
These values are used by the tessellator to control primitive tessellation
and can: be read by tessellation evaluation shaders.
+
In tessellation evaluation shaders, the variable decorated with
code:TessLevelInner can: read the values written by the tessellation control
shader.
+
code:TessLevelInner 修饰符只能在细分控制着色器、细分求值着色器内使用。
+
In a tessellation control shader, any variable decorated with
code:TessLevelInner must: be declared using the code:Output storage class.
+
In a tessellation evaluation shader, any variable decorated with
code:TessLevelInner must: be declared using the code:Input storage class.
+
Any variable decorated with code:TessLevelInner must: be declared as an
array of size two, containing 32-bit floating-point values.

code:VertexIndex::

Decorating a variable with the code:VertexIndex built-in decoration will
make that variable contain the index of the vertex that is being processed
by the current vertex shader invocation.
For non-indexed draws, this variable begins at the pname:firstVertex
parameter to flink:vkCmdDraw or the pname:firstVertex member of a structure
consumed by flink:vkCmdDrawIndirect and increments by one for each vertex in
the draw.
For indexed draws, its value is the content of the index buffer for the
vertex plus the pname:vertexOffset parameter to flink:vkCmdDrawIndexed or
the pname:vertexOffset member of the structure consumed by
flink:vkCmdDrawIndexedIndirect.
+
code:VertexIndex 修饰符只能在顶点着色器内使用。
+
code:VertexIndex修饰的变量必须使用code:Input 存储类别来声明。
+
code:VertexIndex 修饰的变量必须被声明位32位的标量整型。

[NOTE]
.注意
====
code:VertexIndex starts at the same starting value for each instance.
====

code:ViewportIndex::

Decorating a variable with the code:ViewportIndex built-in decoration will
make that variable contain the index of the viewport.
+
In a geometry shader, the variable decorated with code:ViewportIndex can be
written to with the viewport index to which the primitive produced by the
geometry shader will be directed.
The selected viewport index is used to select the viewport transform and
scissor rectangle.
If a geometry shader entry point's interface does not include a variable
decorated with code:ViewportIndex, then the first viewport is used.
If a geometry shader entry point's interface includes a variable decorated
with code:ViewportIndex, it must: write the same value to code:ViewportIndex
for all output vertices of a given primitive.
+
In a fragment shader, the variable decorated with code:ViewportIndex
contains the viewport index of the primitive that the fragment invocation
belongs to.
+
code:ViewportIndex 修饰符只能在几何着色器、片元着色器中使用。
+
在几何着色器内部，code:ViewportIndex 修饰的任何变量必须使用 code:Output 存储类别来声明。
+
在片元着色器内，code:ViewportIndex 修饰的任何变量必须使用 code:Input 存储类别来声明。
+
code:ViewportIndex修饰的任何变量必须被声明为32位整型标量。

code:WorkgroupId::

Decorating a variable with the code:WorkgroupId built-in decoration will
make that variable contain the global workgroup that the current invocation
is a member of.
Each component ranges from zero to the values of the parameters passed into
flink:vkCmdDispatch or read from the sname:VkDispatchIndirectCommand
structure read through a call to flink:vkCmdDispatchIndirect.
+
code:WorkgroupId 修饰符只能在计算着色器内使用。
+
code:WorkgroupId 修饰的变量必须使用code:Input 存储类别来声明。
+
code:WorkgroupId 修饰的变量必须被声明位32位整型的三元素数组。

code:WorkgroupSize::

Decorating a variable with the code:WorkgroupSize built-in decoration will
make that variable contain the dimensions of a local workgroup.
If an object is decorated with the code:WorkgroupSize decoration, this must:
take precedence over any execution mode set for code:LocalSize.
+
code:WorkgroupSize 修饰符只能在计算着色器内使用。
+
code:WorkgroupSize 修饰的对象必须是一个特化常量或者是一个常量。
+
code:WorkgroupSize 修饰的对象必须被声明为32位整型的三元素数组。
