// Copyright (c) 2015-2017 The Khronos Group Inc.
// Copyright notice at https://www.khronos.org/registry/speccopyright.html

[[commandbuffers]]
= 命令缓冲区

// refBegin VkCommandBuffer Opaque handle to a command buffer object

命令缓冲区是用来记录命令的对象，可以顺序的提交到队列以供执行。有两个级别的命令缓冲区：
_主命令缓冲区_（可以执行次命令缓冲区，被提交到队列），_次命令缓冲区_（可以被主命令缓冲区执行，不直接被提交到队列）。

命令缓冲区通过sname:VkCommandBuffer handles表示：

include::../api/handles/VkCommandBuffer.txt[]

// refEnd VkCommandBuffer

记录的命令缓冲区包括绑定管线和描述符到命令缓冲区的命令、修改动态状态的命令、绘制命令，分发命令，执行次命令缓冲区的命令、
复制缓冲区和图像等命令。

[[commandbuffers-statereset]]
每一个命令缓冲区都独立的管理状态。主、次命令缓冲区之间或者两个次级命令缓冲区之间并不继承状态。
当一个命令缓冲区开始记录，该命令缓冲区所有的状态是未定义的。
当次级命令缓冲区被记录以备在主命令缓冲区上执行时，次级命令缓冲区并不从主命令缓冲区继承状态，
在执行次级命令缓冲区后被记录后主命令缓冲区的所有状态是未定义的。
对于这条规则有一个例外--如果主命令缓冲区在一个渲染pass实例中，那么这个renderpass和subpass状态
并不会被次级命令缓冲区的执行所干扰。
当命令缓冲区的状态是未定义时，应用程序必须在依赖诸如绘制、分发的命令被记录之前
设置命令缓冲区上的相关状态，否则执行命令缓冲区的导致的行为是未知的。

除非特别指定了，或者显式地进行同步，通过命令缓冲区把提交到队列的各种命令才能以任意的顺序，
或者同时执行。还有，若没有显式的内存依赖，这些命令带来的内存副作用可能并不会直接被其他命令看到。
在同一个命令缓冲区，提交到一个指定队列的不同命令缓冲区之间都是有效的。
查看<<synchronization, the synchronization chapter>> 来获取命令之间<<synchronization-implicit, 隐式的>> 
和显式同步的信息。

Each command buffer is always in one of three states:

  * _Initial state_: Before flink:vkBeginCommandBuffer.
    Either flink:vkBeginCommandBuffer has never been called, or the command
    buffer has been reset since it last recorded commands.
  * _Recording state_: Between flink:vkBeginCommandBuffer and
    flink:vkEndCommandBuffer.
    The command buffer is in a state where it can: record commands.
  * _Executable state_: After flink:vkEndCommandBuffer.
    The command buffer is in a state where it has finished recording
    commands and can: be executed.

_重置_ 一个命令缓冲区是一个把之前记录的命令抛弃并把命令缓冲区置为初始状态的操作。
重置是 flink:vkResetCommandBuffer、flink:vkResetCommandPool，或者
flink:vkBeginCommandBuffer（当把一个命令缓冲区放到记录状态）调用的结果。


[[commandbuffers-pools]]
== 命令池

// refBegin VkCommandPool Opaque handle to a command pool object
命令缓存池是一个不透明对象，可从之分配出命令缓冲区内存，它可允许Vulkan实现均摊多个命令缓冲区
创建资源的开销。命令缓存池需要在外部保持同步，意味着一个命令缓存池不能同时被多个线程使用。
这包括通过记录命令到任何从缓存池中获取的命令缓冲区，和分配、释放、重置命令缓冲区或命令缓存池本身
等操作。

命令缓冲池是通过sname:VkCommandPool 类型handle来表示的：

include::../api/handles/VkCommandPool.txt[]

// refEnd VkCommandPool

// refBegin vkCreateCommandPool Create a new command pool object

可调用如下命令来创建目录缓存池：

include::../api/protos/vkCreateCommandPool.txt[]

  * pname:device 是创建命令缓冲池的逻辑设备。
  * pname:pCreateInfo 包含用来创建命令缓冲池的信息。
  * pname:pAllocator 控制CPU端内存分配，如<<memory-allocation, Memory Allocation>> 一章所讲。
  * pname:pCommandPool 指向一个sname:VkCommandPool handle ，用它接收被创建缓存池。

include::../validity/protos/vkCreateCommandPool.txt[]

// refBegin VkCommandPoolCreateInfo Structure specifying parameters of a newly created command pool

sname:VkCommandPoolCreateInfo 类型数据结构定义如下：

include::../api/structs/VkCommandPoolCreateInfo.txt[]

  * pname:sType 是这个数据结构的类型。
  * pname:pNext 是 `NULL` 或者一个指向拓展特定的数据结构的指针。
  * pname:flags is a bit标志位，表示缓存池和从它分配出来的命令缓冲区的用途。
     bit位可选如下：
+
--
// refBegin VkCommandPoolCreateFlagBits Bitmask specifying usage behavior for a command pool
include::../api/enums/VkCommandPoolCreateFlagBits.txt[]
--
+
  ** ename:VK_COMMAND_POOL_CREATE_TRANSIENT_BIT indicates that command
     buffers allocated from the pool will be short-lived, meaning that they
     will be reset or freed in a relatively short timeframe.
     This flag may: be used by the implementation to control memory
     allocation behavior within the pool.
  ** ename:VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT controls whether
     command buffers allocated from the pool can: be individually reset.
     If this flag is set, individual command buffers allocated from the pool
     can: be reset either explicitly, by calling fname:vkResetCommandBuffer,
     or implicitly, by calling fname:vkBeginCommandBuffer on an executable
     command buffer.
     If this flag is not set, then fname:vkResetCommandBuffer and
     fname:vkBeginCommandBuffer (on an executable command buffer) must: not
     be called on the command buffers allocated from the pool, and they can:
     only be reset in bulk by calling fname:vkResetCommandPool.
  * pname:queueFamilyIndex designates a queue family as described in section
    <<devsandqueues-queueprops,Queue Family Properties>>.
    All command buffers allocated from this command pool must: be submitted
    on queues from the same queue family.

.正确使用
****
  * pname:queueFamilyIndex must: be the index of a queue family available in
    the calling command's pname:device parameter
****

include::../validity/structs/VkCommandPoolCreateInfo.txt[]

ifdef::VK_KHR_maintenance1[]

// refBegin vkTrimCommandPoolKHR Trim a command pool

可调用如下命令来trim一个命令缓冲池：

include::../api/protos/vkTrimCommandPoolKHR.txt[]

  * pname:device 是拥有命令缓存池的逻辑设备。
  * pname:commandPool 是需要被trim的命令缓存池。
  * pname:flags 被保留使用。

缩减一个命令缓存池会回收从缓存池分配而来的未使用内存，返回给操作系统。
从缓存池分配出来的命令缓冲区不受这个命令的影响。

[NOTE]
.注意
====
这个命令给应用程序提供了命令缓存池使用的内置内存分配之上的控制权。

未使用的内存通常来自于被记录但之后被重置的命令缓冲区，它们不再使用内存了。
重置之后，一个命令缓冲区可以把内存归还到命令缓存池，但是，释放内存归还到操作系统的唯一方式
需要调用 flink:vkResetCommandPool，在从缓存池中获取的命令仍在使用时不能执行该函数。
随后进入命令缓冲区的记录操作将重用这部分内存，但是，因为总的内存需求量随着时间波动，未使用的内存可以累积。

在这种情况下，修剪命令缓存池把内存归还到操作系统是很有用的，把从缓存池获取的总使用量显著的内存恢复到一个平均的水平。

Vulkan实现尽可能的利用内置内存分配策略，这就让所有未使用内存都被释放到系统编程不可能的事情。
例如，命令缓冲区的某种实现也许涉及到块状地从系统分配内存，并从该内存块中更小规模的分配内存。在这种实现中，
任何在使用中的并持有该块状内存reference的命令缓冲区都将阻止该内存被释放，甚至该块状内存中只有很小一部分正在被使用。

在大多数情况下，修剪工作将导致已分配但未使用内存量的减少，但是并不保证产生“理想”的行为。

修剪是代价昂贵的操作，不应该经常调用。
修剪应该被当作在应用程序在已知存在足够的未使用内存、修剪的代价值得的时候释放内存压力的一种方式。
====

include::../validity/protos/vkTrimCommandPoolKHR.txt[]

endif::VK_KHR_maintenance1[]

// refBegin vkResetCommandPool Reset a command pool

可调用如下命令来重置命令缓存池:

include::../api/protos/vkResetCommandPool.txt[]

  * pname:device 是拥有命令缓存池的逻辑设备。 
  * pname:commandPool 是需要被重置的命令缓存池。
  * pname:flags 包那好附加的标志位，可控制重置行为。
    Bits which can: be set include:
+
--
// refBegin VkCommandPoolResetFlagBits Bitmask controlling behavior of a command pool reset
include::../api/enums/VkCommandPoolResetFlagBits.txt[]
--
+
If pname:flags includes ename:VK_COMMAND_POOL_RESET_RELEASE_RESOURCES_BIT,
resetting a command pool recycles all of the resources from the command pool
back to the system.

Resetting a command pool recycles all of the resources from all of the
command buffers allocated from the command pool back to the command pool.
All command buffers that have been allocated from the command pool are put
in the initial state.

.正确使用
****
  * All sname:VkCommandBuffer objects allocated from pname:commandPool must:
    not currently be pending execution
****

include::../validity/protos/vkResetCommandPool.txt[]

// refBegin vkDestroyCommandPool Destroy a command pool object

可调用如下命令来销毁命令缓存池：

include::../api/protos/vkDestroyCommandPool.txt[]

  * pname:device 是需要销毁命令缓存池的逻辑设备。
  * pname:commandPool 是需被销毁的命令缓存池的handle。
  * pname:pAllocator controls host memory allocation as described in the
    <<memory-allocation, Memory Allocation>> chapter.

当一个缓存池被销毁了，所有从之分配命令缓冲区都被释放了，变得无效了。
从一个给定的缓存池分配而来的命令缓冲区并不需要在销毁命令缓存池之前被释放。

.正确使用
****
  * All sname:VkCommandBuffer objects allocated from pname:commandPool must:
    not be pending execution
  * If sname:VkAllocationCallbacks were provided when pname:commandPool was
    created, a compatible set of callbacks must: be provided here
  * If no sname:VkAllocationCallbacks were provided when pname:commandPool
    was created, pname:pAllocator must: be `NULL`
****

include::../validity/protos/vkDestroyCommandPool.txt[]


[[commandbuffer-allocation]]
== 命令缓冲区的分配和管理

// refBegin vkAllocateCommandBuffers Allocate command buffers from an existing command pool

可调用如下命令来分配命令缓冲区：

include::../api/protos/vkAllocateCommandBuffers.txt[]

  * pname:device 是拥有命令缓存池的逻辑设备。
  * pname:pAllocateInfo 是一个指向 sname:VkCommandBufferAllocateInfo 类型数据结构实例的指针，描述了分配行为的参数。
  * pname:pCommandBuffers 是一个指针，执行一个元素类型为sname:VkCommandBuffer handle的数组，以接收被返回的命令缓冲区对象。
	 数组的长度至少为pname:pAllocateInfo 的成员 pname:commandBufferCount 指定的大小。每一个分配的命令缓冲区都处于初始状态。

ifdef::VK_KHR_maintenance1[]
fname:vkAllocateCommandBuffers can: be used to create multiple command
buffers.
If the creation of any of those command buffers fails, the implementation
must: destroy all successfully created command buffer objects from this
command, set all entries of the pname:pCommandBuffers array to `NULL` and
return the error.
endif::VK_KHR_maintenance1[]

include::../validity/protos/vkAllocateCommandBuffers.txt[]

// refBegin VkCommandBufferAllocateInfo Structure specifying the allocation parameters for command buffer object

sname:VkCommandBufferAllocateInfo 类型数据结构定义如下：

include::../api/structs/VkCommandBufferAllocateInfo.txt[]

  * pname:sType 是这个数据结构的类型。
  * pname:pNext 是 `NULL` 或者一个指向拓展特定的数据结构的指针。
  * pname:commandPool 是分配出命令缓冲区的命令缓存池。
  * pname:level 决定命令缓冲区是主缓冲区还是次缓冲区。
    可选值包括：
+
--
// refBegin VkCommandBufferLevel Structure specifying a command buffer level
include::../api/enums/VkCommandBufferLevel.txt[]
--
+
  * pname:commandBufferCount is the number of command buffers to allocate
    from the pool.

.正确使用
****
  * pname:commandBufferCount 必须: 大于 `0`
****

include::../validity/structs/VkCommandBufferAllocateInfo.txt[]

// refBegin vkResetCommandBuffer Reset a command buffer

可调用下列命令啦重置命令缓冲区：

include::../api/protos/vkResetCommandBuffer.txt[]

  * pname:commandBuffer 是需要被重置的命令缓冲区。命令缓冲区可以处于任何状态，并把它设置到初始状态。
  * pname:flags 是一个bit标志位，控制重置操作。
     可选的bit位包括：    
+
--
// refBegin VkCommandBufferResetFlagBits Bitmask controlling behavior of a command buffer reset
include::../api/enums/VkCommandBufferResetFlagBits.txt[]
--
+
若 pname:flags 包含 ename:VK_COMMAND_BUFFER_RESET_RELEASE_RESOURCES_BIT，
那么当前占有大多数或者所有的内存资源的命令缓冲区应该被父命令池返回。
若没有设置此标志位，那么命令缓冲区可能持有内存资源并在记录命令时重用它们。


.正确使用
****
  * pname:commandBuffer must: not currently be pending execution
  * pname:commandBuffer must: have been allocated from a pool that was
    created with the ename:VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT
****

include::../validity/protos/vkResetCommandBuffer.txt[]

// refBegin vkFreeCommandBuffers Free command buffers

可调用下列命令来释放命令缓冲区

include::../api/protos/vkFreeCommandBuffers.txt[]

  * pname:device 是拥有该命令缓存池的逻辑设备。
  * pname:commandPool  是分配出命令缓冲区的命令缓存池。
  * pname:commandBufferCount 是 pname:pCommandBuffers 数组的长度。
  * pname:pCommandBuffers 是需要被释放的命令缓冲区handle的数组。

.正确使用
****
  *  pname:pCommandBuffers 中所有的元素不能是被暂停执行状态。
  * pname:pCommandBuffers 必须是一个指针，指向 pname:commandBufferCount 个元素的sname:VkCommandBuffer handle数组，每一个元素必须是一个有效的handle或者 `NULL`。
****

include::../validity/protos/vkFreeCommandBuffers.txt[]


[[commandbuffers-recording]]
== 命令缓冲区的记录

// refBegin vkBeginCommandBuffer Start recording a command buffer

可调用下列命令来开始记录命令缓冲区：

include::../api/protos/vkBeginCommandBuffer.txt[]

  * pname:commandBuffer 是需要被置为记录状态的命令缓冲区的handle。
  * pname:pBeginInfo is an instance of the sname:VkCommandBufferBeginInfo
    structure, which defines additional information about how the command
    buffer begins recording.

.正确使用
****
  * pname:commandBuffer 不能处于记录状态。
  * pname:commandBuffer 当前不能是暂停执行状态。
  * 若pname:commandBuffer 是从 一个 没有ename:VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT标志位的 sname:VkCommandPool  中分配而来的，pname:commandBuffer必须处于出事状态。
  * 若 pname:commandBuffer 是一个次级命令缓冲区， pname:pBeginInfo的pname:pInheritanceInfo 成员必须是一个有效的 sname:VkCommandBufferInheritanceInfo 数据结构。
  * 若 pname:commandBuffer 是一个次级命令缓冲区，或者pname:pBeginInfo的成员pname:pInheritanceInfo的成员pname:occlusionQueryEnable 是ename:VK_FALSE，精确occlusion查询特征没有被启用，
      那么 pname:pBeginInfo的成员 pname:pInheritanceInfo 的成员 pname:queryFlags，不能包含    ename:VK_QUERY_CONTROL_PRECISE_BIT。
****

include::../validity/protos/vkBeginCommandBuffer.txt[]

// refBegin VkCommandBufferBeginInfo Structure specifying a command buffer begin operation

sname:VkCommandBufferBeginInfo 数据类型定义如下：

include::../api/structs/VkCommandBufferBeginInfo.txt[]

  * pname:sType 是这个数据结构的类型。
  * pname:pNext 为 `NULL` 或者指向拓展特定结构的指针
  * pname:flags 是一个标志位，用来表示命令缓冲区被使用时的行为。
     Bits which can: be set include:
+
--
// refBegin VkCommandBufferUsageFlagBits Bitmask specifying usage behavior for command buffer
include::../api/enums/VkCommandBufferUsageFlagBits.txt[]
--
+
  ** ename:VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT indicates that each
     recording of the command buffer will only be submitted once, and the
     command buffer will be reset and recorded again between each
     submission.
  ** ename:VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT indicates that a
     secondary command buffer is considered to be entirely inside a render
     pass.
     If this is a primary command buffer, then this bit is ignored.
  ** Setting ename:VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT allows the
     command buffer to be resubmitted to a queue or recorded into a primary
     command buffer while it is pending execution.
  * pname:pInheritanceInfo is a pointer to a
    sname:VkCommandBufferInheritanceInfo structure, which is used if
    pname:commandBuffer is a secondary command buffer.
    If this is a primary command buffer, then this value is ignored.

.正确使用
****
  * If pname:flags contains
    ename:VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT, the
    pname:renderPass member of pname:pInheritanceInfo must: be a valid
    sname:VkRenderPass
  * If pname:flags contains
    ename:VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT, the
    pname:subpass member of pname:pInheritanceInfo must: be a valid subpass
    index within the pname:renderPass member of pname:pInheritanceInfo
  * If pname:flags contains
    ename:VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT, the
    pname:framebuffer member of pname:pInheritanceInfo must: be either
    dlink:VK_NULL_HANDLE, or a valid sname:VkFramebuffer that is compatible
    with the pname:renderPass member of pname:pInheritanceInfo
****

include::../validity/structs/VkCommandBufferBeginInfo.txt[]

// refBegin VkCommandBufferInheritanceInfo Structure specifying command buffer inheritance info

若命令缓冲区是次级命令缓冲区，那么sname:VkCommandBufferInheritanceInfo 数据结构定义了从主命令缓冲区继承而来的任何状态：

include::../api/structs/VkCommandBufferInheritanceInfo.txt[]

  * pname:sType 是数据结构的类型。
  * pname:pNext 是 `NULL` 或者一个指向拓展特定的数据结构的指针。
  * pname:renderPass is a sname:VkRenderPass object defining which render
    passes the sname:VkCommandBuffer will be <<renderpass-compatibility,
    compatible>> with and can: be executed within.
    If the sname:VkCommandBuffer will not be executed within a render pass
    instance, pname:renderPass is ignored.
  * pname:subpass is the index of the subpass within the render pass
    instance that the sname:VkCommandBuffer will be executed within.
    If the sname:VkCommandBuffer will not be executed within a render pass
    instance, pname:subpass is ignored.
  * pname:framebuffer optionally refers to the sname:VkFramebuffer object
    that the sname:VkCommandBuffer will be rendering to if it is executed
    within a render pass instance.
    It can: be dlink:VK_NULL_HANDLE if the framebuffer is not known, or if
    the sname:VkCommandBuffer will not be executed within a render pass
    instance.
+
[NOTE]
.注意
====
指定次级命令缓冲区将被执行的命令缓冲区将导致该缓冲区执行时有更好的性能。
====
  * pname:occlusionQueryEnable indicates whether the command buffer can: be
    executed while an occlusion query is active in the primary command
    buffer.
    If this is ename:VK_TRUE, then this command buffer can: be executed
    whether the primary command buffer has an occlusion query active or not.
    If this is ename:VK_FALSE, then the primary command buffer must: not
    have an occlusion query active.
  * pname:queryFlags indicates the query flags that can: be used by an
    active occlusion query in the primary command buffer when this secondary
    command buffer is executed.
    If this value includes the ename:VK_QUERY_CONTROL_PRECISE_BIT bit, then
    the active query can: return boolean results or actual sample counts.
    If this bit is not set, then the active query must: not use the
    ename:VK_QUERY_CONTROL_PRECISE_BIT bit.
  * pname:pipelineStatistics indicates the set of pipeline statistics that
    can: be counted by an active query in the primary command buffer when
    this secondary command buffer is executed.
    If this value includes a given bit, then this command buffer can: be
    executed whether the primary command buffer has a pipeline statistics
    query active that includes this bit or not.
    If this value excludes a given bit, then the active pipeline statistics
    query must: not be from a query pool that counts that statistic.

.正确使用
****
  * If the <<features-features-inheritedQueries,inherited queries>> feature
    is not enabled, pname:occlusionQueryEnable must: be ename:VK_FALSE
  * If the <<features-features-inheritedQueries,inherited queries>> feature
    is enabled, pname:queryFlags must: be a valid combination of
    elink:VkQueryControlFlagBits values
  * If the <<features-features-pipelineStatisticsQuery,pipeline statistics
    queries>> feature is not enabled, pname:pipelineStatistics must: be
    code:0
****

include::../validity/structs/VkCommandBufferInheritanceInfo.txt[]

主命令缓冲区被认为是从使用fname:vkQueueSubmit提交命令开始、直到提交操作完成之前，都处于暂停执行的状态。

次命令缓冲区被认为从它的执行被记录到主缓冲区（）到主缓冲区提交到队列完成的最终时刻，是出于暂停执行状态的。
如果，在主缓冲区完成了，次缓冲区被记录到另外一个主缓冲区上执行，第一个主缓冲区不能被再次提交，直到通过
flink:vkResetCommandBuffer 被重置，除非次命令缓冲区以ename:VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT
标志被记录。

如果没有在次命令缓冲区上设置ename:VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT，那么那个命令缓冲区就不能在
指定主命令缓冲区上使用多次。
还有，如果不带有ename:VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT的次命令缓冲区被记录到一个带有
ename:VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT标志位的主命令缓冲区上执行，那么这个主缓冲区不能被多次暂停执行。

[NOTE]
.注意
====
在一些Vulkan实现上，不使用ename:VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT 标志位将导致命令缓冲区在有需求的情况下被部分的替代，
而不是创建创建一份新的命令缓冲区复制。
====

如果一个命令缓冲区处于可执行状态，且命令缓冲区带有ename:VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT标志位
从缓存池中分配而来，那么fname:vkBeginCommandBuffer将隐式的重置命令缓冲区，就如同不带有
ename:VK_COMMAND_BUFFER_RESET_RELEASE_RESOURCES_BIT参数调用了fname:vkResetCommandBuffer。
然而它把命令缓冲区置为记录中的状态。


Once recording starts, an application records a sequence of commands
(ftext:vkCmd*) to set state in the command buffer, draw, dispatch, and other
commands.

ifdef::VK_NVX_device_generated_commands[]
Several commands can also be recorded indirectly from sname:VkBuffer
content, see <<device-generated-commands>>.
endif::VK_NVX_device_generated_commands[]

// refBegin vkEndCommandBuffer Finish recording a command buffer

可调用下来命令来结束记录命令缓冲区：

include::../api/protos/vkEndCommandBuffer.txt[]

  * pname:commandBuffer is the command buffer to complete recording.
    The command buffer must: have been in the recording state, and is moved
    to the executable state.

If there was an error during recording, the application will be notified by
an unsuccessful return code returned by fname:vkEndCommandBuffer.
If the application wishes to further use the command buffer, the command
buffer must: be reset.

.正确使用
****
  * pname:commandBuffer 必须处于记录中状态。
  * 若 pname:commandBuffer 是一个主命令缓冲区， 那么它不能有一个活跃的render pass实例。
  * All queries made <<queries-operation-active,active>> during the
    recording of pname:commandBuffer must: have been made inactive
****

include::../validity/protos/vkEndCommandBuffer.txt[]

当命令缓冲区处于可执行状态时，它可以被提交到队列等待执行。


[[commandbuffers-submission]]
== 命令缓冲区的提交

// refBegin vkQueueSubmit Submits a sequence of semaphores or command buffers to a queue

可调用下列的命令把命令缓冲区提交到队列：

include::../api/protos/vkQueueSubmit.txt[]

  * pname:queue 是命令缓冲区被提交到的队列。
  * pname:submitCount 是 pname:pSubmits 数组元素的大小。
  * pname:pSubmits 是一个指向 元素类型为slink:VkSubmitInfo 的数组的指针，每一个元素都指定了一个命令缓冲区提交batch。
  * pname:fence 是一个可选的handle，指向一个将被激发的fence。如果pname:fence 不是 dlink:VK_NULL_HANDLE，它定义了一个
    <<synchronization-fences-signaling, fence signal operation>>。

[NOTE]
.注意
====
提交可能是一个代价很高的操作，应用程序应该尝试批量的工作，尽量少的调用fname:vkQueueSubmit。
====

fname:vkQueueSubmit是一个<<devsandqueues-submission, 队列提交命令>>，每一批任务通过pname:pSubmits中由slink:VkSubmitInfo表示的一批任务定义。
pname:pSubmits中各批次的任务依出现的顺序执行，但是，完成的顺序可能是乱序的。

通过flink:vkQueueSubmit提交的栅栏和信号量操作和其他的命令提交有另外的顺序限制，依赖于队列中前后操作。
关于这些量外的限制的信息可以在<<synchronization, “同步”一章>>的<<synchronization-semaphores, 信号量>> and <<synchronization-fences, 栅栏>>
小节中看到。

关于pname:pWaitDstStageMask和同步之间的细节在<<synchronization, “同步”一章>>中的
<<synchronization-semaphores-waiting, 信号量等待操作>> 小节中描述。

在pname:pSubmits中批次出现的顺序通常由<<synchronization-submission-order, 提交顺序>>决定，故所有的<<synchronization-implicit, 隐式排序>>保证遵守这点。
除了这些隐式排序保证和任何<<synchronization, 显式的同步原语>>，这些工作批次可能重叠或者乱序执行。

.正确使用
****
  * 若 pname:fence 不是 dlink:VK_NULL_HANDLE，那么 pname:fence 必须未被发送过信号。
  * 若 pname:fence 不是 dlink:VK_NULL_HANDLE，那么pname:fence 不能和任何其他的在队列中未完成执行的队列命令关联上。
  * Any calls to flink:vkCmdSetEvent, flink:vkCmdResetEvent or
    flink:vkCmdWaitEvents that have been recorded into any of the command
    buffer elements of the pname:pCommandBuffers member of any element of
    pname:pSubmits, must: not reference any slink:VkEvent that is referenced
    by any of those commands that is pending execution on another queue.
  * Any stage flag included in any element of the pname:pWaitDstStageMask
    member of any element of pname:pSubmits must: be a pipeline stage
    supported by one of the capabilities of pname:queue, as specified in the
    <<synchronization-pipeline-stages-supported, table of supported pipeline
    stages>>.
  * Any given element of the pname:pSignalSemaphores member of any element
    of pname:pSubmits must: be unsignaled when the semaphore signal
    operation it defines is executed on the device
  * When a semaphore unsignal operation defined by any element of the
    pname:pWaitSemaphores member of any element of pname:pSubmits executes
    on pname:queue, no other queue must: be waiting on the same semaphore.
  * All elements of the pname:pWaitSemaphores member of all elements of
    pname:pSubmits must: be semaphores that are signaled, or have
    <<synchronization-semaphores-signaling, semaphore signal operations>>
    previously submitted for execution.
****

include::../validity/protos/vkQueueSubmit.txt[]

// refBegin VkSubmitInfo Structure specifying a queue submit operation

sname:VkSubmitInfo 类型数据结构定义如下：

include::../api/structs/VkSubmitInfo.txt[]

  * pname:sType 是本数据结构的类型。
  * pname:pNext 为 `NULL` 或者指向拓展特定结构的指针。
  * pname:waitSemaphoreCount is the number of semaphores upon which to wait
    before executing the command buffers for the batch.
  * pname:pWaitSemaphores is a pointer to an array of semaphores upon which
    to wait before the command buffers for this batch begin execution.
    If semaphores to wait on are provided, they define a
    <<synchronization-semaphores-waiting, semaphore wait operation>>.
  * pname:pWaitDstStageMask is a pointer to an array of pipeline stages at
    which each corresponding semaphore wait will occur.
  * pname:commandBufferCount is the number of command buffers to execute in
    the batch.
  * pname:pCommandBuffers is a pointer to an array of command buffers to
    execute in the batch.
  * pname:signalSemaphoreCount is the number of semaphores to be signaled
    once the commands specified in pname:pCommandBuffers have completed
    execution.
  * pname:pSignalSemaphores is a pointer to an array of semaphores which
    will be signaled when the command buffers for this batch have completed
    execution.
    If semaphores to be signaled are provided, they define a
    <<synchronization-semaphores-signaling, semaphore signal operation>>.

命令缓冲区在pname:pCommandBuffers中出现的顺序决定了<<synchronization-submission-order, submission order>>，
<<synchronization-implicit, implicit ordering guarantees>> 也取决于这个顺序。
除了这些隐式的顺序保证 和其他的<<synchronization, explicit synchronization primitives>>，这些命令缓冲区可能重叠或者乱序执行。


.正确使用
****
  * Any given element of pname:pCommandBuffers must: either have been
    recorded with the ename:VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT, or
    not currently be executing on the device
  * Any given element of pname:pCommandBuffers must: be in the executable
    state
  * If any given element of pname:pCommandBuffers contains commands that
    execute secondary command buffers, those secondary command buffers must:
    have been recorded with the
    ename:VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT, or not currently be
    executing on the device
  * If any given element of pname:pCommandBuffers was recorded with
    ename:VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT, it must: not have
    been previously submitted without re-recording that command buffer
  * If any given element of pname:pCommandBuffers contains commands that
    execute secondary command buffers recorded with
    ename:VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT, each such secondary
    command buffer must: not have been previously submitted without
    re-recording that command buffer
  * Any given element of pname:pCommandBuffers must: not contain commands
    that execute a secondary command buffer, if that secondary command
    buffer has been recorded in another primary command buffer after it was
    recorded into this sname:VkCommandBuffer
  * Any given element of pname:pCommandBuffers must: have been allocated
    from a sname:VkCommandPool that was created for the same queue family
    that the calling command's pname:queue belongs to
  * Any given element of pname:pCommandBuffers must: not have been allocated
    with ename:VK_COMMAND_BUFFER_LEVEL_SECONDARY
  * If the <<features-features-geometryShader,geometry shaders>> feature is
    not enabled, any given element of pname:pWaitDstStageMask must: not
    contain ename:VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT
  * If the <<features-features-tessellationShader,tessellation shaders>>
    feature is not enabled, any given element of pname:pWaitDstStageMask
    must: not contain
    ename:VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT or
    ename:VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT
  * Any given element of pname:pWaitDstStageMask must: not include
    ename:VK_PIPELINE_STAGE_HOST_BIT.
****

include::../validity/structs/VkSubmitInfo.txt[]

ifdef::VK_NV_win32_keyed_mutex[]
include::VK_NV_win32_keyed_mutex/keyed_mutex_submit.txt[]
endif::VK_NV_win32_keyed_mutex[]


[[commandbuffers-submission-progress]]
== 队列发送进度（Queue Forward Progress）

应用程序必须保证在任何队列上没有剩下的操作时命令缓冲区提交将能够完成。
在fname:vkQueueSubmit调用之后，对等待一个信号量的每个排队等待者必须是一个比信号量更早的信号，
该信号量不会被一个不同的等待者消耗。

提交的命令缓冲区可以包含等待不会被队列中更早的命令所激发的事件的flink:vkCmdWaitEvents命令，
这些事件必须通过应用程序使用flink:vkSetEvent来激发，且等待这些事件的fname:vkCmdWaitEvents命令不能在一个render pass内。
Vulkan实现可能对命令缓冲区等待的时长有限制，以避免和设备的其他clients的工作进度有干扰。
如果没有这些限制条件下事件被激发了，结果是未定义的，可能包括设备丢失。


[[commandbuffers-secondary]]
== 次级命令缓冲区的执行

// refBegin vkCmdExecuteCommands Execute a secondary command buffer from a primary command buffer

次命令缓冲区必须不能直接被提交到队列。相反，需要被记录到主命令缓冲区的一部分来被执行：

include::../api/protos/vkCmdExecuteCommands.txt[]

  * pname:commandBuffer 是主命令缓冲区，次命令缓冲区在它里面执行。
  * pname:commandBufferCount 是 pname:pCommandBuffers 数组的大小。   
  * pname:pCommandBuffers 是次命令缓冲区handle的数组，按照在数组中的位置被提交到主命令缓冲区中被记录、执行。

一旦fname:vkCmdExecuteCommands被调用，在任何主命令缓冲区中的由pname:pCommandBuffers指定的次命令缓冲区之前的任何执行工作都被无效化了，
除非这些次命令缓冲区被记录时带有ename:VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT。

.正确使用
****
  * pname:commandBuffer 必须在分配的时候带有的参数 pname:level 值为 ename:VK_COMMAND_BUFFER_LEVEL_PRIMARY
  * pname:pCommandBuffers中任何一个元素必须在分配的时候带有的参数pname:level 值为 ename:VK_COMMAND_BUFFER_LEVEL_SECONDARY
  * pname:pCommandBuffers中任何一个元素不能在pname:commandBuffer之中处于pending状态，也不能出现两次，除非带有
    ename:VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT 标志位
  *  pname:pCommandBuffers的任何元素都不能在任何其他的 sname:VkCommandBuffer中处于pending 状态，除非被记录时带有
	ename:VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT 标志位
  * pname:pCommandBuffers 中任何一个元素都不能处于可执行状态    
  * pname:pCommandBuffers 中任何一个元素都必须从队列族索引与pname:commandBuffer所在的sname:VkCommandPool 相同的sname:VkCommandPool 分配而来。    
  * 如果fname:vkCmdExecuteCommands在一个render pass 实例中被调用，此render pass实例必须在开始的时候保证 fname:vkCmdBeginRenderPass参数的成员 pname:contents
	被设置为 ename:VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS
  * 如果在一个render pass实例内调用 fname:vkCmdExecuteCommands 命令，pname:pCommandBuffers 中的任何元素必须以 
    ename:VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT的方式被记录
  * 如果在一个render pass实例内调用fname:vkCmdExecuteCommands 命令，pname:pCommandBuffers中的任何元素被记录时，
	必须让sname:VkCommandBufferInheritanceInfo::pname:subpass 被设置为指定的将所在执行的命令缓冲区的subpass的索引
  * 如果在一个render pass 实例内调用fname:vkCmdExecuteCommands， 在用来开始记录pname:pCommandBuffers 中每一个元素的
  flink:vkBeginCommandBuffer 的成员pname::pBeginInfo::pname:pInheritanceInfo::pname:renderPass 指定 render  pass实例必须和
	当前使用的render pass <<renderpass-compatibility, 兼容>> 
  * 如果在一个render pass实例中调用 fname:vkCmdExecuteCommands，pname:pCommandBuffers 中任一个以sname:VkCommandBufferInheritanceInfo::pname:framebuffer
   被记录的元素必须匹配在当前的render pass实例中使用的sname:VkFramebuffer 
  * 如果在一个render pass实例中没有调用 fname:vkCmdExecuteCommands ，pname:pCommandBuffers 中任何一个元素在被记录时不能带有
    ename:VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT
  * 如果 <<features-features-inheritedQueries,inherited queries>> 特征没有被启用，pname:commandBuffer 的queries都不能为
    <<queries-operation-active,active>>
  * 若 pname:commandBuffer 有一个ename:VK_QUERY_TYPE_OCCLUSION query
    <<queries-operation-active,active>>, 那么 pname:pCommandBuffers 的每一个元素被记录时
    sname:VkCommandBufferInheritanceInfo::pname:occlusionQueryEnable 必须设置为 ename:VK_TRUE
  * 若 pname:commandBuffer 有一个ename:VK_QUERY_TYPE_OCCLUSION query
    <<queries-operation-active,active>>, 那么 pname:pCommandBuffers 的每一个元素被记录时
    sname:VkCommandBufferInheritanceInfo::pname:queryFlags 所有的bit必须为该query设置好    
  * 若 pname:commandBuffer 有一个 ename:VK_QUERY_TYPE_PIPELINE_STATISTICS
    query <<queries-operation-active,active>>，那么 pname:pCommandBuffers 的每一个元素在记录时
    sname:VkCommandBufferInheritanceInfo::pname:pipelineStatistics 所有的bit都必须和这个query使用的sname:VkQueryPool 的bit位相同    
  * pname:pCommandBuffers 任何一个元素不能开启 在pname:commandBuffer <<queries-operation-active,active>>的 query类型    
****

include::../validity/protos/vkCmdExecuteCommands.txt[]
